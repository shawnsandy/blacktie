webpackJsonp([0],[function(module,exports,__webpack_require__){eval("/* Riot v3.9.4, @license MIT */\n(function (global, factory) {\n   true ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.riot = {})));\n}(this, (function (exports) { 'use strict';\n\n  /**\n   * Shorter and fast way to select a single node in the DOM\n   * @param   { String } selector - unique dom selector\n   * @param   { Object } ctx - DOM node where the target of our search will is located\n   * @returns { Object } dom node found\n   */\n  function $(selector, ctx) {\n    return (ctx || document).querySelector(selector)\n  }\n\n  var\n    // be aware, internal usage\n    // ATTENTION: prefix the global dynamic variables with `__`\n    // tags instances cache\n    __TAGS_CACHE = [],\n    // tags implementation cache\n    __TAG_IMPL = {},\n    YIELD_TAG = 'yield',\n\n    /**\n     * Const\n     */\n    GLOBAL_MIXIN = '__global_mixin',\n\n    // riot specific prefixes or attributes\n    ATTRS_PREFIX = 'riot-',\n\n    // Riot Directives\n    REF_DIRECTIVES = ['ref', 'data-ref'],\n    IS_DIRECTIVE = 'data-is',\n    CONDITIONAL_DIRECTIVE = 'if',\n    LOOP_DIRECTIVE = 'each',\n    LOOP_NO_REORDER_DIRECTIVE = 'no-reorder',\n    SHOW_DIRECTIVE = 'show',\n    HIDE_DIRECTIVE = 'hide',\n    KEY_DIRECTIVE = 'key',\n    RIOT_EVENTS_KEY = '__riot-events__',\n\n    // for typeof == '' comparisons\n    T_STRING = 'string',\n    T_OBJECT = 'object',\n    T_UNDEF  = 'undefined',\n    T_FUNCTION = 'function',\n\n    XLINK_NS = 'http://www.w3.org/1999/xlink',\n    SVG_NS = 'http://www.w3.org/2000/svg',\n    XLINK_REGEX = /^xlink:(\\w+)/,\n\n    WIN = typeof window === T_UNDEF ? undefined : window,\n\n    // special native tags that cannot be treated like the others\n    RE_SPECIAL_TAGS = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?|opt(?:ion|group))$/,\n    RE_SPECIAL_TAGS_NO_OPTION = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?)$/,\n    RE_EVENTS_PREFIX = /^on/,\n    RE_HTML_ATTRS = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g,\n    // some DOM attributes must be normalized\n    CASE_SENSITIVE_ATTRIBUTES = {\n      'viewbox': 'viewBox',\n      'preserveaspectratio': 'preserveAspectRatio'\n    },\n    /**\n     * Matches boolean HTML attributes in the riot tag definition.\n     * With a long list like this, a regex is faster than `[].indexOf` in most browsers.\n     * @const {RegExp}\n     * @see [attributes.md](https://github.com/riot/compiler/blob/dev/doc/attributes.md)\n     */\n    RE_BOOL_ATTRS = /^(?:disabled|checked|readonly|required|allowfullscreen|auto(?:focus|play)|compact|controls|default|formnovalidate|hidden|ismap|itemscope|loop|multiple|muted|no(?:resize|shade|validate|wrap)?|open|reversed|seamless|selected|sortable|truespeed|typemustmatch)$/,\n    // version# for IE 8-11, 0 for others\n    IE_VERSION = (WIN && WIN.document || {}).documentMode | 0;\n\n  /**\n   * Create a generic DOM node\n   * @param   { String } name - name of the DOM node we want to create\n   * @returns { Object } DOM node just created\n   */\n  function makeElement(name) {\n    return name === 'svg' ? document.createElementNS(SVG_NS, name) : document.createElement(name)\n  }\n\n  /**\n   * Set any DOM attribute\n   * @param { Object } dom - DOM node we want to update\n   * @param { String } name - name of the property we want to set\n   * @param { String } val - value of the property we want to set\n   */\n  function setAttribute(dom, name, val) {\n    var xlink = XLINK_REGEX.exec(name);\n    if (xlink && xlink[1])\n      { dom.setAttributeNS(XLINK_NS, xlink[1], val); }\n    else\n      { dom.setAttribute(name, val); }\n  }\n\n  var styleNode;\n  // Create cache and shortcut to the correct property\n  var cssTextProp;\n  var byName = {};\n  var needsInject = false;\n\n  // skip the following code on the server\n  if (WIN) {\n    styleNode = ((function () {\n      // create a new style element with the correct type\n      var newNode = makeElement('style');\n      // replace any user node or insert the new one into the head\n      var userNode = $('style[type=riot]');\n\n      setAttribute(newNode, 'type', 'text/css');\n      /* istanbul ignore next */\n      if (userNode) {\n        if (userNode.id) { newNode.id = userNode.id; }\n        userNode.parentNode.replaceChild(newNode, userNode);\n      } else { document.head.appendChild(newNode); }\n\n      return newNode\n    }))();\n    cssTextProp = styleNode.styleSheet;\n  }\n\n  /**\n   * Object that will be used to inject and manage the css of every tag instance\n   */\n  var styleManager = {\n    styleNode: styleNode,\n    /**\n     * Save a tag style to be later injected into DOM\n     * @param { String } css - css string\n     * @param { String } name - if it's passed we will map the css to a tagname\n     */\n    add: function add(css, name) {\n      byName[name] = css;\n      needsInject = true;\n    },\n    /**\n     * Inject all previously saved tag styles into DOM\n     * innerHTML seems slow: http://jsperf.com/riot-insert-style\n     */\n    inject: function inject() {\n      if (!WIN || !needsInject) { return }\n      needsInject = false;\n      var style = Object.keys(byName)\n        .map(function (k) { return byName[k]; })\n        .join('\\n');\n      /* istanbul ignore next */\n      if (cssTextProp) { cssTextProp.cssText = style; }\n      else { styleNode.innerHTML = style; }\n    },\n\n    /**\n     * Remove a tag style of injected DOM later.\n     * @param {String} name a registered tagname\n     */\n    remove: function remove(name) {\n      delete byName[name];\n      needsInject = true;\n    }\n  }\n\n  /**\n   * The riot template engine\n   * @version v3.0.8\n   */\n\n  var skipRegex = (function () { //eslint-disable-line no-unused-vars\n\n    var beforeReChars = '[{(,;:?=|&!^~>%*/';\n\n    var beforeReWords = [\n      'case',\n      'default',\n      'do',\n      'else',\n      'in',\n      'instanceof',\n      'prefix',\n      'return',\n      'typeof',\n      'void',\n      'yield'\n    ];\n\n    var wordsLastChar = beforeReWords.reduce(function (s, w) {\n      return s + w.slice(-1)\n    }, '');\n\n    var RE_REGEX = /^\\/(?=[^*>/])[^[/\\\\]*(?:(?:\\\\.|\\[(?:\\\\.|[^\\]\\\\]*)*\\])[^[\\\\/]*)*?\\/[gimuy]*/;\n    var RE_VN_CHAR = /[$\\w]/;\n\n    function prev (code, pos) {\n      while (--pos >= 0 && /\\s/.test(code[pos])){ }\n      return pos\n    }\n\n    function _skipRegex (code, start) {\n\n      var re = /.*/g;\n      var pos = re.lastIndex = start++;\n      var match = re.exec(code)[0].match(RE_REGEX);\n\n      if (match) {\n        var next = pos + match[0].length;\n\n        pos = prev(code, pos);\n        var c = code[pos];\n\n        if (pos < 0 || ~beforeReChars.indexOf(c)) {\n          return next\n        }\n\n        if (c === '.') {\n\n          if (code[pos - 1] === '.') {\n            start = next;\n          }\n\n        } else if (c === '+' || c === '-') {\n\n          if (code[--pos] !== c ||\n              (pos = prev(code, pos)) < 0 ||\n              !RE_VN_CHAR.test(code[pos])) {\n            start = next;\n          }\n\n        } else if (~wordsLastChar.indexOf(c)) {\n\n          var end = pos + 1;\n\n          while (--pos >= 0 && RE_VN_CHAR.test(code[pos])){ }\n          if (~beforeReWords.indexOf(code.slice(pos + 1, end))) {\n            start = next;\n          }\n        }\n      }\n\n      return start\n    }\n\n    return _skipRegex\n\n  })();\n\n  /**\n   * riot.util.brackets\n   *\n   * - `brackets    ` - Returns a string or regex based on its parameter\n   * - `brackets.set` - Change the current riot brackets\n   *\n   * @module\n   */\n\n  /* global riot */\n\n  /* istanbul ignore next */\n  var brackets = (function (UNDEF) {\n\n    var\n      REGLOB = 'g',\n\n      R_MLCOMMS = /\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,\n\n      R_STRINGS = /\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'|`[^`\\\\]*(?:\\\\[\\S\\s][^`\\\\]*)*`/g,\n\n      S_QBLOCKS = R_STRINGS.source + '|' +\n        /(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source + '|' +\n        /\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?([^<]\\/)[gim]*/.source,\n\n      UNSUPPORTED = RegExp('[\\\\' + 'x00-\\\\x1F<>a-zA-Z0-9\\'\",;\\\\\\\\]'),\n\n      NEED_ESCAPE = /(?=[[\\]()*+?.^$|])/g,\n\n      S_QBLOCK2 = R_STRINGS.source + '|' + /(\\/)(?![*\\/])/.source,\n\n      FINDBRACES = {\n        '(': RegExp('([()])|'   + S_QBLOCK2, REGLOB),\n        '[': RegExp('([[\\\\]])|' + S_QBLOCK2, REGLOB),\n        '{': RegExp('([{}])|'   + S_QBLOCK2, REGLOB)\n      },\n\n      DEFAULT = '{ }';\n\n    var _pairs = [\n      '{', '}',\n      '{', '}',\n      /{[^}]*}/,\n      /\\\\([{}])/g,\n      /\\\\({)|{/g,\n      RegExp('\\\\\\\\(})|([[({])|(})|' + S_QBLOCK2, REGLOB),\n      DEFAULT,\n      /^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/,\n      /(^|[^\\\\]){=[\\S\\s]*?}/\n    ];\n\n    var\n      cachedBrackets = UNDEF,\n      _regex,\n      _cache = [],\n      _settings;\n\n    function _loopback (re) { return re }\n\n    function _rewrite (re, bp) {\n      if (!bp) { bp = _cache; }\n      return new RegExp(\n        re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : ''\n      )\n    }\n\n    function _create (pair) {\n      if (pair === DEFAULT) { return _pairs }\n\n      var arr = pair.split(' ');\n\n      if (arr.length !== 2 || UNSUPPORTED.test(pair)) {\n        throw new Error('Unsupported brackets \"' + pair + '\"')\n      }\n      arr = arr.concat(pair.replace(NEED_ESCAPE, '\\\\').split(' '));\n\n      arr[4] = _rewrite(arr[1].length > 1 ? /{[\\S\\s]*?}/ : _pairs[4], arr);\n      arr[5] = _rewrite(pair.length > 3 ? /\\\\({|})/g : _pairs[5], arr);\n      arr[6] = _rewrite(_pairs[6], arr);\n      arr[7] = RegExp('\\\\\\\\(' + arr[3] + ')|([[({])|(' + arr[3] + ')|' + S_QBLOCK2, REGLOB);\n      arr[8] = pair;\n      return arr\n    }\n\n    function _brackets (reOrIdx) {\n      return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx]\n    }\n\n    _brackets.split = function split (str, tmpl, _bp) {\n      // istanbul ignore next: _bp is for the compiler\n      if (!_bp) { _bp = _cache; }\n\n      var\n        parts = [],\n        match,\n        isexpr,\n        start,\n        pos,\n        re = _bp[6];\n\n      var qblocks = [];\n      var prevStr = '';\n      var mark, lastIndex;\n\n      isexpr = start = re.lastIndex = 0;\n\n      while ((match = re.exec(str))) {\n\n        lastIndex = re.lastIndex;\n        pos = match.index;\n\n        if (isexpr) {\n\n          if (match[2]) {\n\n            var ch = match[2];\n            var rech = FINDBRACES[ch];\n            var ix = 1;\n\n            rech.lastIndex = lastIndex;\n            while ((match = rech.exec(str))) {\n              if (match[1]) {\n                if (match[1] === ch) { ++ix; }\n                else if (!--ix) { break }\n              } else {\n                rech.lastIndex = pushQBlock(match.index, rech.lastIndex, match[2]);\n              }\n            }\n            re.lastIndex = ix ? str.length : rech.lastIndex;\n            continue\n          }\n\n          if (!match[3]) {\n            re.lastIndex = pushQBlock(pos, lastIndex, match[4]);\n            continue\n          }\n        }\n\n        if (!match[1]) {\n          unescapeStr(str.slice(start, pos));\n          start = re.lastIndex;\n          re = _bp[6 + (isexpr ^= 1)];\n          re.lastIndex = start;\n        }\n      }\n\n      if (str && start < str.length) {\n        unescapeStr(str.slice(start));\n      }\n\n      parts.qblocks = qblocks;\n\n      return parts\n\n      function unescapeStr (s) {\n        if (prevStr) {\n          s = prevStr + s;\n          prevStr = '';\n        }\n        if (tmpl || isexpr) {\n          parts.push(s && s.replace(_bp[5], '$1'));\n        } else {\n          parts.push(s);\n        }\n      }\n\n      function pushQBlock(_pos, _lastIndex, slash) { //eslint-disable-line\n        if (slash) {\n          _lastIndex = skipRegex(str, _pos);\n        }\n\n        if (tmpl && _lastIndex > _pos + 2) {\n          mark = '\\u2057' + qblocks.length + '~';\n          qblocks.push(str.slice(_pos, _lastIndex));\n          prevStr += str.slice(start, _pos) + mark;\n          start = _lastIndex;\n        }\n        return _lastIndex\n      }\n    };\n\n    _brackets.hasExpr = function hasExpr (str) {\n      return _cache[4].test(str)\n    };\n\n    _brackets.loopKeys = function loopKeys (expr) {\n      var m = expr.match(_cache[9]);\n\n      return m\n        ? { key: m[1], pos: m[2], val: _cache[0] + m[3].trim() + _cache[1] }\n        : { val: expr.trim() }\n    };\n\n    _brackets.array = function array (pair) {\n      return pair ? _create(pair) : _cache\n    };\n\n    function _reset (pair) {\n      if ((pair || (pair = DEFAULT)) !== _cache[8]) {\n        _cache = _create(pair);\n        _regex = pair === DEFAULT ? _loopback : _rewrite;\n        _cache[9] = _regex(_pairs[9]);\n      }\n      cachedBrackets = pair;\n    }\n\n    function _setSettings (o) {\n      var b;\n\n      o = o || {};\n      b = o.brackets;\n      Object.defineProperty(o, 'brackets', {\n        set: _reset,\n        get: function () { return cachedBrackets },\n        enumerable: true\n      });\n      _settings = o;\n      _reset(b);\n    }\n\n    Object.defineProperty(_brackets, 'settings', {\n      set: _setSettings,\n      get: function () { return _settings }\n    });\n\n    /* istanbul ignore next: in the browser riot is always in the scope */\n    _brackets.settings = typeof riot !== 'undefined' && riot.settings || {};\n    _brackets.set = _reset;\n    _brackets.skipRegex = skipRegex;\n\n    _brackets.R_STRINGS = R_STRINGS;\n    _brackets.R_MLCOMMS = R_MLCOMMS;\n    _brackets.S_QBLOCKS = S_QBLOCKS;\n    _brackets.S_QBLOCK2 = S_QBLOCK2;\n\n    return _brackets\n\n  })();\n\n  /**\n   * @module tmpl\n   *\n   * tmpl          - Root function, returns the template value, render with data\n   * tmpl.hasExpr  - Test the existence of a expression inside a string\n   * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)\n   */\n\n  /* istanbul ignore next */\n  var tmpl = (function () {\n\n    var _cache = {};\n\n    function _tmpl (str, data) {\n      if (!str) { return str }\n\n      return (_cache[str] || (_cache[str] = _create(str))).call(\n        data, _logErr.bind({\n          data: data,\n          tmpl: str\n        })\n      )\n    }\n\n    _tmpl.hasExpr = brackets.hasExpr;\n\n    _tmpl.loopKeys = brackets.loopKeys;\n\n    // istanbul ignore next\n    _tmpl.clearCache = function () { _cache = {}; };\n\n    _tmpl.errorHandler = null;\n\n    function _logErr (err, ctx) {\n\n      err.riotData = {\n        tagName: ctx && ctx.__ && ctx.__.tagName,\n        _riot_id: ctx && ctx._riot_id  //eslint-disable-line camelcase\n      };\n\n      if (_tmpl.errorHandler) { _tmpl.errorHandler(err); }\n      else if (\n        typeof console !== 'undefined' &&\n        typeof console.error === 'function'\n      ) {\n        console.error(err.message);\n        console.log('<%s> %s', err.riotData.tagName || 'Unknown tag', this.tmpl); // eslint-disable-line\n        console.log(this.data); // eslint-disable-line\n      }\n    }\n\n    function _create (str) {\n      var expr = _getTmpl(str);\n\n      if (expr.slice(0, 11) !== 'try{return ') { expr = 'return ' + expr; }\n\n      return new Function('E', expr + ';')    // eslint-disable-line no-new-func\n    }\n\n    var RE_DQUOTE = /\\u2057/g;\n    var RE_QBMARK = /\\u2057(\\d+)~/g;\n\n    function _getTmpl (str) {\n      var parts = brackets.split(str.replace(RE_DQUOTE, '\"'), 1);\n      var qstr = parts.qblocks;\n      var expr;\n\n      if (parts.length > 2 || parts[0]) {\n        var i, j, list = [];\n\n        for (i = j = 0; i < parts.length; ++i) {\n\n          expr = parts[i];\n\n          if (expr && (expr = i & 1\n\n              ? _parseExpr(expr, 1, qstr)\n\n              : '\"' + expr\n                  .replace(/\\\\/g, '\\\\\\\\')\n                  .replace(/\\r\\n?|\\n/g, '\\\\n')\n                  .replace(/\"/g, '\\\\\"') +\n                '\"'\n\n            )) { list[j++] = expr; }\n\n        }\n\n        expr = j < 2 ? list[0]\n             : '[' + list.join(',') + '].join(\"\")';\n\n      } else {\n\n        expr = _parseExpr(parts[1], 0, qstr);\n      }\n\n      if (qstr.length) {\n        expr = expr.replace(RE_QBMARK, function (_, pos) {\n          return qstr[pos]\n            .replace(/\\r/g, '\\\\r')\n            .replace(/\\n/g, '\\\\n')\n        });\n      }\n      return expr\n    }\n\n    var RE_CSNAME = /^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\u2057(\\d+)~):/;\n    var\n      RE_BREND = {\n        '(': /[()]/g,\n        '[': /[[\\]]/g,\n        '{': /[{}]/g\n      };\n\n    function _parseExpr (expr, asText, qstr) {\n\n      expr = expr\n        .replace(/\\s+/g, ' ').trim()\n        .replace(/\\ ?([[\\({},?\\.:])\\ ?/g, '$1');\n\n      if (expr) {\n        var\n          list = [],\n          cnt = 0,\n          match;\n\n        while (expr &&\n              (match = expr.match(RE_CSNAME)) &&\n              !match.index\n          ) {\n          var\n            key,\n            jsb,\n            re = /,|([[{(])|$/g;\n\n          expr = RegExp.rightContext;\n          key  = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\\s+/g, ' ') : match[1];\n\n          while (jsb = (match = re.exec(expr))[1]) { skipBraces(jsb, re); }\n\n          jsb  = expr.slice(0, match.index);\n          expr = RegExp.rightContext;\n\n          list[cnt++] = _wrapExpr(jsb, 1, key);\n        }\n\n        expr = !cnt ? _wrapExpr(expr, asText)\n             : cnt > 1 ? '[' + list.join(',') + '].join(\" \").trim()' : list[0];\n      }\n      return expr\n\n      function skipBraces (ch, re) {\n        var\n          mm,\n          lv = 1,\n          ir = RE_BREND[ch];\n\n        ir.lastIndex = re.lastIndex;\n        while (mm = ir.exec(expr)) {\n          if (mm[0] === ch) { ++lv; }\n          else if (!--lv) { break }\n        }\n        re.lastIndex = lv ? expr.length : ir.lastIndex;\n      }\n    }\n\n    // istanbul ignore next: not both\n    var // eslint-disable-next-line max-len\n      JS_CONTEXT = '\"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').',\n      JS_VARNAME = /[,{][\\$\\w]+(?=:)|(^ *|[^$\\w\\.{])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g,\n      JS_NOPROPS = /^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/;\n\n    function _wrapExpr (expr, asText, key) {\n      var tb;\n\n      expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {\n        if (mvar) {\n          pos = tb ? 0 : pos + match.length;\n\n          if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {\n            match = p + '(\"' + mvar + JS_CONTEXT + mvar;\n            if (pos) { tb = (s = s[pos]) === '.' || s === '(' || s === '['; }\n          } else if (pos) {\n            tb = !JS_NOPROPS.test(s.slice(pos));\n          }\n        }\n        return match\n      });\n\n      if (tb) {\n        expr = 'try{return ' + expr + '}catch(e){E(e,this)}';\n      }\n\n      if (key) {\n\n        expr = (tb\n            ? 'function(){' + expr + '}.call(this)' : '(' + expr + ')'\n          ) + '?\"' + key + '\":\"\"';\n\n      } else if (asText) {\n\n        expr = 'function(v){' + (tb\n            ? expr.replace('return ', 'v=') : 'v=(' + expr + ')'\n          ) + ';return v||v===0?v:\"\"}.call(this)';\n      }\n\n      return expr\n    }\n\n    _tmpl.version = brackets.version = 'v3.0.8';\n\n    return _tmpl\n\n  })();\n\n  /* istanbul ignore next */\n  var observable = function(el) {\n\n    /**\n     * Extend the original object or create a new empty one\n     * @type { Object }\n     */\n\n    el = el || {};\n\n    /**\n     * Private variables\n     */\n    var callbacks = {},\n      slice = Array.prototype.slice;\n\n    /**\n     * Public Api\n     */\n\n    // extend the el object adding the observable methods\n    Object.defineProperties(el, {\n      /**\n       * Listen to the given `event` ands\n       * execute the `callback` each time an event is triggered.\n       * @param  { String } event - event id\n       * @param  { Function } fn - callback function\n       * @returns { Object } el\n       */\n      on: {\n        value: function(event, fn) {\n          if (typeof fn == 'function')\n            { (callbacks[event] = callbacks[event] || []).push(fn); }\n          return el\n        },\n        enumerable: false,\n        writable: false,\n        configurable: false\n      },\n\n      /**\n       * Removes the given `event` listeners\n       * @param   { String } event - event id\n       * @param   { Function } fn - callback function\n       * @returns { Object } el\n       */\n      off: {\n        value: function(event, fn) {\n          if (event == '*' && !fn) { callbacks = {}; }\n          else {\n            if (fn) {\n              var arr = callbacks[event];\n              for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n                if (cb == fn) { arr.splice(i--, 1); }\n              }\n            } else { delete callbacks[event]; }\n          }\n          return el\n        },\n        enumerable: false,\n        writable: false,\n        configurable: false\n      },\n\n      /**\n       * Listen to the given `event` and\n       * execute the `callback` at most once\n       * @param   { String } event - event id\n       * @param   { Function } fn - callback function\n       * @returns { Object } el\n       */\n      one: {\n        value: function(event, fn) {\n          function on() {\n            el.off(event, on);\n            fn.apply(el, arguments);\n          }\n          return el.on(event, on)\n        },\n        enumerable: false,\n        writable: false,\n        configurable: false\n      },\n\n      /**\n       * Execute all callback functions that listen to\n       * the given `event`\n       * @param   { String } event - event id\n       * @returns { Object } el\n       */\n      trigger: {\n        value: function(event) {\n          var arguments$1 = arguments;\n\n\n          // getting the arguments\n          var arglen = arguments.length - 1,\n            args = new Array(arglen),\n            fns,\n            fn,\n            i;\n\n          for (i = 0; i < arglen; i++) {\n            args[i] = arguments$1[i + 1]; // skip first argument\n          }\n\n          fns = slice.call(callbacks[event] || [], 0);\n\n          for (i = 0; fn = fns[i]; ++i) {\n            fn.apply(el, args);\n          }\n\n          if (callbacks['*'] && event != '*')\n            { el.trigger.apply(el, ['*', event].concat(args)); }\n\n          return el\n        },\n        enumerable: false,\n        writable: false,\n        configurable: false\n      }\n    });\n\n    return el\n\n  };\n\n  /**\n   * Short alias for Object.getOwnPropertyDescriptor\n   */\n  function getPropDescriptor (o, k) {\n    return Object.getOwnPropertyDescriptor(o, k)\n  }\n\n  /**\n   * Check if passed argument is undefined\n   * @param   { * } value -\n   * @returns { Boolean } -\n   */\n  function isUndefined(value) {\n    return typeof value === T_UNDEF\n  }\n\n  /**\n   * Check whether object's property could be overridden\n   * @param   { Object }  obj - source object\n   * @param   { String }  key - object property\n   * @returns { Boolean } true if writable\n   */\n  function isWritable(obj, key) {\n    var descriptor = getPropDescriptor(obj, key);\n    return isUndefined(obj[key]) || descriptor && descriptor.writable\n  }\n\n  /**\n   * Extend any object with other properties\n   * @param   { Object } src - source object\n   * @returns { Object } the resulting extended object\n   *\n   * var obj = { foo: 'baz' }\n   * extend(obj, {bar: 'bar', foo: 'bar'})\n   * console.log(obj) => {bar: 'bar', foo: 'bar'}\n   *\n   */\n  function extend(src) {\n    var obj;\n    var i = 1;\n    var args = arguments;\n    var l = args.length;\n\n    for (; i < l; i++) {\n      if (obj = args[i]) {\n        for (var key in obj) {\n          // check if this property of the source object could be overridden\n          if (isWritable(src, key))\n            { src[key] = obj[key]; }\n        }\n      }\n    }\n    return src\n  }\n\n  /**\n   * Alias for Object.create\n   */\n  function create(src) {\n    return Object.create(src)\n  }\n\n  var settings = extend(create(brackets.settings), {\n    skipAnonymousTags: true,\n    // handle the auto updates on any DOM event\n    autoUpdate: true\n  })\n\n  /**\n   * Shorter and fast way to select multiple nodes in the DOM\n   * @param   { String } selector - DOM selector\n   * @param   { Object } ctx - DOM node where the targets of our search will is located\n   * @returns { Object } dom nodes found\n   */\n  function $$(selector, ctx) {\n    return [].slice.call((ctx || document).querySelectorAll(selector))\n  }\n\n  /**\n   * Create a document text node\n   * @returns { Object } create a text node to use as placeholder\n   */\n  function createDOMPlaceholder() {\n    return document.createTextNode('')\n  }\n\n  /**\n   * Toggle the visibility of any DOM node\n   * @param   { Object }  dom - DOM node we want to hide\n   * @param   { Boolean } show - do we want to show it?\n   */\n\n  function toggleVisibility(dom, show) {\n    dom.style.display = show ? '' : 'none';\n    dom.hidden = show ? false : true;\n  }\n\n  /**\n   * Get the value of any DOM attribute on a node\n   * @param   { Object } dom - DOM node we want to parse\n   * @param   { String } name - name of the attribute we want to get\n   * @returns { String | undefined } name of the node attribute whether it exists\n   */\n  function getAttribute(dom, name) {\n    return dom.getAttribute(name)\n  }\n\n  /**\n   * Remove any DOM attribute from a node\n   * @param   { Object } dom - DOM node we want to update\n   * @param   { String } name - name of the property we want to remove\n   */\n  function removeAttribute(dom, name) {\n    dom.removeAttribute(name);\n  }\n\n  /**\n   * Set the inner html of any DOM node SVGs included\n   * @param { Object } container - DOM node where we'll inject new html\n   * @param { String } html - html to inject\n   * @param { Boolean } isSvg - svg tags should be treated a bit differently\n   */\n  /* istanbul ignore next */\n  function setInnerHTML(container, html, isSvg) {\n    // innerHTML is not supported on svg tags so we neet to treat them differently\n    if (isSvg) {\n      var node = container.ownerDocument.importNode(\n        new DOMParser()\n          .parseFromString((\"<svg xmlns=\\\"\" + SVG_NS + \"\\\">\" + html + \"</svg>\"), 'application/xml')\n          .documentElement,\n        true\n      );\n\n      container.appendChild(node);\n    } else {\n      container.innerHTML = html;\n    }\n  }\n\n  /**\n   * Minimize risk: only zero or one _space_ between attr & value\n   * @param   { String }   html - html string we want to parse\n   * @param   { Function } fn - callback function to apply on any attribute found\n   */\n  function walkAttributes(html, fn) {\n    if (!html) { return }\n    var m;\n    while (m = RE_HTML_ATTRS.exec(html))\n      { fn(m[1].toLowerCase(), m[2] || m[3] || m[4]); }\n  }\n\n  /**\n   * Create a document fragment\n   * @returns { Object } document fragment\n   */\n  function createFragment() {\n    return document.createDocumentFragment()\n  }\n\n  /**\n   * Insert safely a tag to fix #1962 #1649\n   * @param   { HTMLElement } root - children container\n   * @param   { HTMLElement } curr - node to insert\n   * @param   { HTMLElement } next - node that should preceed the current node inserted\n   */\n  function safeInsert(root, curr, next) {\n    root.insertBefore(curr, next.parentNode && next);\n  }\n\n  /**\n   * Convert a style object to a string\n   * @param   { Object } style - style object we need to parse\n   * @returns { String } resulting css string\n   * @example\n   * styleObjectToString({ color: 'red', height: '10px'}) // => 'color: red; height: 10px'\n   */\n  function styleObjectToString(style) {\n    return Object.keys(style).reduce(function (acc, prop) {\n      return (acc + \" \" + prop + \": \" + (style[prop]) + \";\")\n    }, '')\n  }\n\n  /**\n   * Walk down recursively all the children tags starting dom node\n   * @param   { Object }   dom - starting node where we will start the recursion\n   * @param   { Function } fn - callback to transform the child node just found\n   * @param   { Object }   context - fn can optionally return an object, which is passed to children\n   */\n  function walkNodes(dom, fn, context) {\n    if (dom) {\n      var res = fn(dom, context);\n      var next;\n      // stop the recursion\n      if (res === false) { return }\n\n      dom = dom.firstChild;\n\n      while (dom) {\n        next = dom.nextSibling;\n        walkNodes(dom, fn, res);\n        dom = next;\n      }\n    }\n  }\n\n\n\n  var dom = /*#__PURE__*/Object.freeze({\n    $$: $$,\n    $: $,\n    createDOMPlaceholder: createDOMPlaceholder,\n    mkEl: makeElement,\n    setAttr: setAttribute,\n    toggleVisibility: toggleVisibility,\n    getAttr: getAttribute,\n    remAttr: removeAttribute,\n    setInnerHTML: setInnerHTML,\n    walkAttrs: walkAttributes,\n    createFrag: createFragment,\n    safeInsert: safeInsert,\n    styleObjectToString: styleObjectToString,\n    walkNodes: walkNodes\n  });\n\n  /**\n   * Check against the null and undefined values\n   * @param   { * }  value -\n   * @returns {Boolean} -\n   */\n  function isNil(value) {\n    return isUndefined(value) || value === null\n  }\n\n  /**\n   * Check if passed argument is empty. Different from falsy, because we dont consider 0 or false to be blank\n   * @param { * } value -\n   * @returns { Boolean } -\n   */\n  function isBlank(value) {\n    return isNil(value) || value === ''\n  }\n\n  /**\n   * Check if passed argument is a function\n   * @param   { * } value -\n   * @returns { Boolean } -\n   */\n  function isFunction(value) {\n    return typeof value === T_FUNCTION\n  }\n\n  /**\n   * Check if passed argument is an object, exclude null\n   * NOTE: use isObject(x) && !isArray(x) to excludes arrays.\n   * @param   { * } value -\n   * @returns { Boolean } -\n   */\n  function isObject(value) {\n    return value && typeof value === T_OBJECT // typeof null is 'object'\n  }\n\n  /**\n   * Check if a DOM node is an svg tag or part of an svg\n   * @param   { HTMLElement }  el - node we want to test\n   * @returns {Boolean} true if it's an svg node\n   */\n  function isSvg(el) {\n    var owner = el.ownerSVGElement;\n    return !!owner || owner === null\n  }\n\n  /**\n   * Check if passed argument is a kind of array\n   * @param   { * } value -\n   * @returns { Boolean } -\n   */\n  function isArray(value) {\n    return Array.isArray(value) || value instanceof Array\n  }\n\n  /**\n   * Check if the passed argument is a boolean attribute\n   * @param   { String } value -\n   * @returns { Boolean } -\n   */\n  function isBoolAttr(value) {\n    return RE_BOOL_ATTRS.test(value)\n  }\n\n  /**\n   * Check if passed argument is a string\n   * @param   { * } value -\n   * @returns { Boolean } -\n   */\n  function isString(value) {\n    return typeof value === T_STRING\n  }\n\n\n\n  var check = /*#__PURE__*/Object.freeze({\n    isBlank: isBlank,\n    isFunction: isFunction,\n    isObject: isObject,\n    isSvg: isSvg,\n    isWritable: isWritable,\n    isArray: isArray,\n    isBoolAttr: isBoolAttr,\n    isNil: isNil,\n    isString: isString,\n    isUndefined: isUndefined\n  });\n\n  /**\n   * Check whether an array contains an item\n   * @param   { Array } array - target array\n   * @param   { * } item - item to test\n   * @returns { Boolean } -\n   */\n  function contains(array, item) {\n    return array.indexOf(item) !== -1\n  }\n\n  /**\n   * Specialized function for looping an array-like collection with `each={}`\n   * @param   { Array } list - collection of items\n   * @param   {Function} fn - callback function\n   * @returns { Array } the array looped\n   */\n  function each(list, fn) {\n    var len = list ? list.length : 0;\n    var i = 0;\n    for (; i < len; i++) { fn(list[i], i); }\n    return list\n  }\n\n  /**\n   * Faster String startsWith alternative\n   * @param   { String } str - source string\n   * @param   { String } value - test string\n   * @returns { Boolean } -\n   */\n  function startsWith(str, value) {\n    return str.slice(0, value.length) === value\n  }\n\n  /**\n   * Function returning always a unique identifier\n   * @returns { Number } - number from 0...n\n   */\n  var uid = (function uid() {\n    var i = -1;\n    return function () { return ++i; }\n  })()\n\n  /**\n   * Helper function to set an immutable property\n   * @param   { Object } el - object where the new property will be set\n   * @param   { String } key - object key where the new property will be stored\n   * @param   { * } value - value of the new property\n   * @param   { Object } options - set the propery overriding the default options\n   * @returns { Object } - the initial object\n   */\n  function define(el, key, value, options) {\n    Object.defineProperty(el, key, extend({\n      value: value,\n      enumerable: false,\n      writable: false,\n      configurable: true\n    }, options));\n    return el\n  }\n\n  /**\n   * Convert a string containing dashes to camel case\n   * @param   { String } str - input string\n   * @returns { String } my-string -> myString\n   */\n  function toCamel(str) {\n    return str.replace(/-(\\w)/g, function (_, c) { return c.toUpperCase(); })\n  }\n\n  /**\n   * Warn a message via console\n   * @param   {String} message - warning message\n   */\n  function warn(message) {\n    if (console && console.warn) { console.warn(message); }\n  }\n\n\n\n  var misc = /*#__PURE__*/Object.freeze({\n    contains: contains,\n    each: each,\n    getPropDescriptor: getPropDescriptor,\n    startsWith: startsWith,\n    uid: uid,\n    defineProperty: define,\n    objectCreate: create,\n    extend: extend,\n    toCamel: toCamel,\n    warn: warn\n  });\n\n  /**\n   * Set the property of an object for a given key. If something already\n   * exists there, then it becomes an array containing both the old and new value.\n   * @param { Object } obj - object on which to set the property\n   * @param { String } key - property name\n   * @param { Object } value - the value of the property to be set\n   * @param { Boolean } ensureArray - ensure that the property remains an array\n   * @param { Number } index - add the new item in a certain array position\n   */\n  function arrayishAdd(obj, key, value, ensureArray, index) {\n    var dest = obj[key];\n    var isArr = isArray(dest);\n    var hasIndex = !isUndefined(index);\n\n    if (dest && dest === value) { return }\n\n    // if the key was never set, set it once\n    if (!dest && ensureArray) { obj[key] = [value]; }\n    else if (!dest) { obj[key] = value; }\n    // if it was an array and not yet set\n    else {\n      if (isArr) {\n        var oldIndex = dest.indexOf(value);\n        // this item never changed its position\n        if (oldIndex === index) { return }\n        // remove the item from its old position\n        if (oldIndex !== -1) { dest.splice(oldIndex, 1); }\n        // move or add the item\n        if (hasIndex) {\n          dest.splice(index, 0, value);\n        } else {\n          dest.push(value);\n        }\n      } else { obj[key] = [dest, value]; }\n    }\n  }\n\n  /**\n   * Detect the tag implementation by a DOM node\n   * @param   { Object } dom - DOM node we need to parse to get its tag implementation\n   * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)\n   */\n  function get(dom) {\n    return dom.tagName && __TAG_IMPL[getAttribute(dom, IS_DIRECTIVE) ||\n      getAttribute(dom, IS_DIRECTIVE) || dom.tagName.toLowerCase()]\n  }\n\n  /**\n   * Get the tag name of any DOM node\n   * @param   { Object } dom - DOM node we want to parse\n   * @param   { Boolean } skipDataIs - hack to ignore the data-is attribute when attaching to parent\n   * @returns { String } name to identify this dom node in riot\n   */\n  function getName(dom, skipDataIs) {\n    var child = get(dom);\n    var namedTag = !skipDataIs && getAttribute(dom, IS_DIRECTIVE);\n    return namedTag && !tmpl.hasExpr(namedTag) ?\n      namedTag : child ? child.name : dom.tagName.toLowerCase()\n  }\n\n  /**\n   * Return a temporary context containing also the parent properties\n   * @this Tag\n   * @param { Tag } - temporary tag context containing all the parent properties\n   */\n  function inheritParentProps() {\n    if (this.parent) { return extend(create(this), this.parent) }\n    return this\n  }\n\n  /*\n    Includes hacks needed for the Internet Explorer version 9 and below\n    See: http://kangax.github.io/compat-table/es5/#ie8\n         http://codeplanet.io/dropping-ie8/\n  */\n\n  var\n    reHasYield  = /<yield\\b/i,\n    reYieldAll  = /<yield\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>|>)/ig,\n    reYieldSrc  = /<yield\\s+to=['\"]([^'\">]*)['\"]\\s*>([\\S\\s]*?)<\\/yield\\s*>/ig,\n    reYieldDest = /<yield\\s+from=['\"]?([-\\w]+)['\"]?\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>)/ig,\n    rootEls = { tr: 'tbody', th: 'tr', td: 'tr', col: 'colgroup' },\n    tblTags = IE_VERSION && IE_VERSION < 10 ? RE_SPECIAL_TAGS : RE_SPECIAL_TAGS_NO_OPTION,\n    GENERIC = 'div',\n    SVG = 'svg';\n\n\n  /*\n    Creates the root element for table or select child elements:\n    tr/th/td/thead/tfoot/tbody/caption/col/colgroup/option/optgroup\n  */\n  function specialTags(el, tmpl, tagName) {\n\n    var\n      select = tagName[0] === 'o',\n      parent = select ? 'select>' : 'table>';\n\n    // trim() is important here, this ensures we don't have artifacts,\n    // so we can check if we have only one element inside the parent\n    el.innerHTML = '<' + parent + tmpl.trim() + '</' + parent;\n    parent = el.firstChild;\n\n    // returns the immediate parent if tr/th/td/col is the only element, if not\n    // returns the whole tree, as this can include additional elements\n    /* istanbul ignore next */\n    if (select) {\n      parent.selectedIndex = -1;  // for IE9, compatible w/current riot behavior\n    } else {\n      // avoids insertion of cointainer inside container (ex: tbody inside tbody)\n      var tname = rootEls[tagName];\n      if (tname && parent.childElementCount === 1) { parent = $(tname, parent); }\n    }\n    return parent\n  }\n\n  /*\n    Replace the yield tag from any tag template with the innerHTML of the\n    original tag in the page\n  */\n  function replaceYield(tmpl, html) {\n    // do nothing if no yield\n    if (!reHasYield.test(tmpl)) { return tmpl }\n\n    // be careful with #1343 - string on the source having `$1`\n    var src = {};\n\n    html = html && html.replace(reYieldSrc, function (_, ref, text) {\n      src[ref] = src[ref] || text;   // preserve first definition\n      return ''\n    }).trim();\n\n    return tmpl\n      .replace(reYieldDest, function (_, ref, def) {  // yield with from - to attrs\n        return src[ref] || def || ''\n      })\n      .replace(reYieldAll, function (_, def) {        // yield without any \"from\"\n        return html || def || ''\n      })\n  }\n\n  /**\n   * Creates a DOM element to wrap the given content. Normally an `DIV`, but can be\n   * also a `TABLE`, `SELECT`, `TBODY`, `TR`, or `COLGROUP` element.\n   *\n   * @param   { String } tmpl  - The template coming from the custom tag definition\n   * @param   { String } html - HTML content that comes from the DOM element where you\n   *           will mount the tag, mostly the original tag in the page\n   * @param   { Boolean } isSvg - true if the root node is an svg\n   * @returns { HTMLElement } DOM element with _tmpl_ merged through `YIELD` with the _html_.\n   */\n  function mkdom(tmpl, html, isSvg) {\n    var match   = tmpl && tmpl.match(/^\\s*<([-\\w]+)/);\n    var  tagName = match && match[1].toLowerCase();\n    var el = makeElement(isSvg ? SVG : GENERIC);\n\n    // replace all the yield tags with the tag inner html\n    tmpl = replaceYield(tmpl, html);\n\n    /* istanbul ignore next */\n    if (tblTags.test(tagName))\n      { el = specialTags(el, tmpl, tagName); }\n    else\n      { setInnerHTML(el, tmpl, isSvg); }\n\n    return el\n  }\n\n  /**\n   * Loop backward all the parents tree to detect the first custom parent tag\n   * @param   { Object } tag - a Tag instance\n   * @returns { Object } the instance of the first custom parent tag found\n   */\n  function getImmediateCustomParent(tag) {\n    var ptag = tag;\n    while (ptag.__.isAnonymous) {\n      if (!ptag.parent) { break }\n      ptag = ptag.parent;\n    }\n    return ptag\n  }\n\n  /**\n   * Trigger DOM events\n   * @param   { HTMLElement } dom - dom element target of the event\n   * @param   { Function } handler - user function\n   * @param   { Object } e - event object\n   */\n  function handleEvent(dom, handler, e) {\n    var ptag = this.__.parent;\n    var item = this.__.item;\n\n    if (!item)\n      { while (ptag && !item) {\n        item = ptag.__.item;\n        ptag = ptag.__.parent;\n      } }\n\n    // override the event properties\n    /* istanbul ignore next */\n    if (isWritable(e, 'currentTarget')) { e.currentTarget = dom; }\n    /* istanbul ignore next */\n    if (isWritable(e, 'target')) { e.target = e.srcElement; }\n    /* istanbul ignore next */\n    if (isWritable(e, 'which')) { e.which = e.charCode || e.keyCode; }\n\n    e.item = item;\n\n    handler.call(this, e);\n\n    // avoid auto updates\n    if (!settings.autoUpdate) { return }\n\n    if (!e.preventUpdate) {\n      var p = getImmediateCustomParent(this);\n      // fixes #2083\n      if (p.isMounted) { p.update(); }\n    }\n  }\n\n  /**\n   * Attach an event to a DOM node\n   * @param { String } name - event name\n   * @param { Function } handler - event callback\n   * @param { Object } dom - dom node\n   * @param { Tag } tag - tag instance\n   */\n  function setEventHandler(name, handler, dom, tag) {\n    var eventName;\n    var cb = handleEvent.bind(tag, dom, handler);\n\n    // avoid to bind twice the same event\n    // possible fix for #2332\n    dom[name] = null;\n\n    // normalize event name\n    eventName = name.replace(RE_EVENTS_PREFIX, '');\n\n    // cache the listener into the listeners array\n    if (!contains(tag.__.listeners, dom)) { tag.__.listeners.push(dom); }\n    if (!dom[RIOT_EVENTS_KEY]) { dom[RIOT_EVENTS_KEY] = {}; }\n    if (dom[RIOT_EVENTS_KEY][name]) { dom.removeEventListener(eventName, dom[RIOT_EVENTS_KEY][name]); }\n\n    dom[RIOT_EVENTS_KEY][name] = cb;\n    dom.addEventListener(eventName, cb, false);\n  }\n\n  /**\n   * Create a new child tag including it correctly into its parent\n   * @param   { Object } child - child tag implementation\n   * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted\n   * @param   { String } innerHTML - inner html of the child node\n   * @param   { Object } parent - instance of the parent tag including the child custom tag\n   * @returns { Object } instance of the new child tag just created\n   */\n  function initChild(child, opts, innerHTML, parent) {\n    var tag = createTag(child, opts, innerHTML);\n    var tagName = opts.tagName || getName(opts.root, true);\n    var ptag = getImmediateCustomParent(parent);\n    // fix for the parent attribute in the looped elements\n    define(tag, 'parent', ptag);\n    // store the real parent tag\n    // in some cases this could be different from the custom parent tag\n    // for example in nested loops\n    tag.__.parent = parent;\n\n    // add this tag to the custom parent tag\n    arrayishAdd(ptag.tags, tagName, tag);\n\n    // and also to the real parent tag\n    if (ptag !== parent)\n      { arrayishAdd(parent.tags, tagName, tag); }\n\n    return tag\n  }\n\n  /**\n   * Removes an item from an object at a given key. If the key points to an array,\n   * then the item is just removed from the array.\n   * @param { Object } obj - object on which to remove the property\n   * @param { String } key - property name\n   * @param { Object } value - the value of the property to be removed\n   * @param { Boolean } ensureArray - ensure that the property remains an array\n  */\n  function arrayishRemove(obj, key, value, ensureArray) {\n    if (isArray(obj[key])) {\n      var index = obj[key].indexOf(value);\n      if (index !== -1) { obj[key].splice(index, 1); }\n      if (!obj[key].length) { delete obj[key]; }\n      else if (obj[key].length === 1 && !ensureArray) { obj[key] = obj[key][0]; }\n    } else if (obj[key] === value)\n      { delete obj[key]; } // otherwise just delete the key\n  }\n\n  /**\n   * Adds the elements for a virtual tag\n   * @this Tag\n   * @param { Node } src - the node that will do the inserting or appending\n   * @param { Tag } target - only if inserting, insert before this tag's first child\n   */\n  function makeVirtual(src, target) {\n    var this$1 = this;\n\n    var head = createDOMPlaceholder();\n    var tail = createDOMPlaceholder();\n    var frag = createFragment();\n    var sib;\n    var el;\n\n    this.root.insertBefore(head, this.root.firstChild);\n    this.root.appendChild(tail);\n\n    this.__.head = el = head;\n    this.__.tail = tail;\n\n    while (el) {\n      sib = el.nextSibling;\n      frag.appendChild(el);\n      this$1.__.virts.push(el); // hold for unmounting\n      el = sib;\n    }\n\n    if (target)\n      { src.insertBefore(frag, target.__.head); }\n    else\n      { src.appendChild(frag); }\n  }\n\n  /**\n   * makes a tag virtual and replaces a reference in the dom\n   * @this Tag\n   * @param { tag } the tag to make virtual\n   * @param { ref } the dom reference location\n   */\n  function makeReplaceVirtual(tag, ref) {\n    var frag = createFragment();\n    makeVirtual.call(tag, frag);\n    ref.parentNode.replaceChild(frag, ref);\n  }\n\n  /**\n   * Update dynamically created data-is tags with changing expressions\n   * @param { Object } expr - expression tag and expression info\n   * @param { Tag }    parent - parent for tag creation\n   * @param { String } tagName - tag implementation we want to use\n   */\n  function updateDataIs(expr, parent, tagName) {\n    var tag = expr.tag || expr.dom._tag;\n    var ref;\n\n    var ref$1 = tag ? tag.__ : {};\n    var head = ref$1.head;\n    var isVirtual = expr.dom.tagName === 'VIRTUAL';\n\n    if (tag && expr.tagName === tagName) {\n      tag.update();\n      return\n    }\n\n    // sync _parent to accommodate changing tagnames\n    if (tag) {\n      // need placeholder before unmount\n      if(isVirtual) {\n        ref = createDOMPlaceholder();\n        head.parentNode.insertBefore(ref, head);\n      }\n\n      tag.unmount(true);\n    }\n\n    // unable to get the tag name\n    if (!isString(tagName)) { return }\n\n    expr.impl = __TAG_IMPL[tagName];\n\n    // unknown implementation\n    if (!expr.impl) { return }\n\n    expr.tag = tag = initChild(\n      expr.impl, {\n        root: expr.dom,\n        parent: parent,\n        tagName: tagName\n      },\n      expr.dom.innerHTML,\n      parent\n    );\n\n    each(expr.attrs, function (a) { return setAttribute(tag.root, a.name, a.value); });\n    expr.tagName = tagName;\n    tag.mount();\n\n    // root exist first time, after use placeholder\n    if (isVirtual) { makeReplaceVirtual(tag, ref || tag.root); }\n\n    // parent is the placeholder tag, not the dynamic tag so clean up\n    parent.__.onUnmount = function () {\n      var delName = tag.opts.dataIs;\n      arrayishRemove(tag.parent.tags, delName, tag);\n      arrayishRemove(tag.__.parent.tags, delName, tag);\n      tag.unmount();\n    };\n  }\n\n  /**\n   * Nomalize any attribute removing the \"riot-\" prefix\n   * @param   { String } attrName - original attribute name\n   * @returns { String } valid html attribute name\n   */\n  function normalizeAttrName(attrName) {\n    if (!attrName) { return null }\n    attrName = attrName.replace(ATTRS_PREFIX, '');\n    if (CASE_SENSITIVE_ATTRIBUTES[attrName]) { attrName = CASE_SENSITIVE_ATTRIBUTES[attrName]; }\n    return attrName\n  }\n\n  /**\n   * Update on single tag expression\n   * @this Tag\n   * @param { Object } expr - expression logic\n   * @returns { undefined }\n   */\n  function updateExpression(expr) {\n    if (this.root && getAttribute(this.root,'virtualized')) { return }\n\n    var dom = expr.dom;\n    // remove the riot- prefix\n    var attrName = normalizeAttrName(expr.attr);\n    var isToggle = contains([SHOW_DIRECTIVE, HIDE_DIRECTIVE], attrName);\n    var isVirtual = expr.root && expr.root.tagName === 'VIRTUAL';\n    var ref = this.__;\n    var isAnonymous = ref.isAnonymous;\n    var parent = dom && (expr.parent || dom.parentNode);\n    // detect the style attributes\n    var isStyleAttr = attrName === 'style';\n    var isClassAttr = attrName === 'class';\n\n    var value;\n\n    // if it's a tag we could totally skip the rest\n    if (expr._riot_id) {\n      if (expr.__.wasCreated) {\n        expr.update();\n      // if it hasn't been mounted yet, do that now.\n      } else {\n        expr.mount();\n        if (isVirtual) {\n          makeReplaceVirtual(expr, expr.root);\n        }\n      }\n      return\n    }\n\n    // if this expression has the update method it means it can handle the DOM changes by itself\n    if (expr.update) { return expr.update() }\n\n    var context = isToggle && !isAnonymous ? inheritParentProps.call(this) : this;\n\n    // ...it seems to be a simple expression so we try to calculate its value\n    value = tmpl(expr.expr, context);\n\n    var hasValue = !isBlank(value);\n    var isObj = isObject(value);\n\n    // convert the style/class objects to strings\n    if (isObj) {\n      if (isClassAttr) {\n        value = tmpl(JSON.stringify(value), this);\n      } else if (isStyleAttr) {\n        value = styleObjectToString(value);\n      }\n    }\n\n    // remove original attribute\n    if (expr.attr && (!expr.wasParsedOnce || !hasValue || value === false)) {\n      // remove either riot-* attributes or just the attribute name\n      removeAttribute(dom, getAttribute(dom, expr.attr) ? expr.attr : attrName);\n    }\n\n    // for the boolean attributes we don't need the value\n    // we can convert it to checked=true to checked=checked\n    if (expr.bool) { value = value ? attrName : false; }\n    if (expr.isRtag) { return updateDataIs(expr, this, value) }\n    if (expr.wasParsedOnce && expr.value === value) { return }\n\n    // update the expression value\n    expr.value = value;\n    expr.wasParsedOnce = true;\n\n    // if the value is an object (and it's not a style or class attribute) we can not do much more with it\n    if (isObj && !isClassAttr && !isStyleAttr && !isToggle) { return }\n    // avoid to render undefined/null values\n    if (!hasValue) { value = ''; }\n\n    // textarea and text nodes have no attribute name\n    if (!attrName) {\n      // about #815 w/o replace: the browser converts the value to a string,\n      // the comparison by \"==\" does too, but not in the server\n      value += '';\n      // test for parent avoids error with invalid assignment to nodeValue\n      if (parent) {\n        // cache the parent node because somehow it will become null on IE\n        // on the next iteration\n        expr.parent = parent;\n        if (parent.tagName === 'TEXTAREA') {\n          parent.value = value;                    // #1113\n          if (!IE_VERSION) { dom.nodeValue = value; }  // #1625 IE throws here, nodeValue\n        }                                         // will be available on 'updated'\n        else { dom.nodeValue = value; }\n      }\n      return\n    }\n\n\n    // event handler\n    if (isFunction(value)) {\n      setEventHandler(attrName, value, dom, this);\n    // show / hide\n    } else if (isToggle) {\n      toggleVisibility(dom, attrName === HIDE_DIRECTIVE ? !value : value);\n    // handle attributes\n    } else {\n      if (expr.bool) {\n        dom[attrName] = value;\n      }\n\n      if (attrName === 'value' && dom.value !== value) {\n        dom.value = value;\n      } else if (hasValue && value !== false) {\n        setAttribute(dom, attrName, value);\n      }\n\n      // make sure that in case of style changes\n      // the element stays hidden\n      if (isStyleAttr && dom.hidden) { toggleVisibility(dom, false); }\n    }\n  }\n\n  /**\n   * Update all the expressions in a Tag instance\n   * @this Tag\n   * @param { Array } expressions - expression that must be re evaluated\n   */\n  function update(expressions) {\n    each(expressions, updateExpression.bind(this));\n  }\n\n  /**\n   * We need to update opts for this tag. That requires updating the expressions\n   * in any attributes on the tag, and then copying the result onto opts.\n   * @this Tag\n   * @param   {Boolean} isLoop - is it a loop tag?\n   * @param   { Tag }  parent - parent tag node\n   * @param   { Boolean }  isAnonymous - is it a tag without any impl? (a tag not registered)\n   * @param   { Object }  opts - tag options\n   * @param   { Array }  instAttrs - tag attributes array\n   */\n  function updateOpts(isLoop, parent, isAnonymous, opts, instAttrs) {\n    // isAnonymous `each` tags treat `dom` and `root` differently. In this case\n    // (and only this case) we don't need to do updateOpts, because the regular parse\n    // will update those attrs. Plus, isAnonymous tags don't need opts anyway\n    if (isLoop && isAnonymous) { return }\n    var ctx = isLoop ? inheritParentProps.call(this) : parent || this;\n\n    each(instAttrs, function (attr) {\n      if (attr.expr) { updateExpression.call(ctx, attr.expr); }\n      // normalize the attribute names\n      opts[toCamel(attr.name).replace(ATTRS_PREFIX, '')] = attr.expr ? attr.expr.value : attr.value;\n    });\n  }\n\n  /**\n   * Update the tag expressions and options\n   * @param { Tag } tag - tag object\n   * @param { * } data - data we want to use to extend the tag properties\n   * @param { Array } expressions - component expressions array\n   * @returns { Tag } the current tag instance\n   */\n  function componentUpdate(tag, data, expressions) {\n    var __ = tag.__;\n    var nextOpts = {};\n    var canTrigger = tag.isMounted && !__.skipAnonymous;\n\n    // inherit properties from the parent tag\n    if (__.isAnonymous && __.parent) { extend(tag, __.parent); }\n    extend(tag, data);\n\n    updateOpts.apply(tag, [__.isLoop, __.parent, __.isAnonymous, nextOpts, __.instAttrs]);\n\n    if (\n      canTrigger &&\n      tag.isMounted &&\n      isFunction(tag.shouldUpdate) && !tag.shouldUpdate(data, nextOpts)\n    ) {\n      return tag\n    }\n\n    extend(tag.opts, nextOpts);\n\n    if (canTrigger) { tag.trigger('update', data); }\n    update.call(tag, expressions);\n    if (canTrigger) { tag.trigger('updated'); }\n\n    return tag\n  }\n\n  /**\n   * Get selectors for tags\n   * @param   { Array } tags - tag names to select\n   * @returns { String } selector\n   */\n  function query(tags) {\n    // select all tags\n    if (!tags) {\n      var keys = Object.keys(__TAG_IMPL);\n      return keys + query(keys)\n    }\n\n    return tags\n      .filter(function (t) { return !/[^-\\w]/.test(t); })\n      .reduce(function (list, t) {\n        var name = t.trim().toLowerCase();\n        return list + \",[\" + IS_DIRECTIVE + \"=\\\"\" + name + \"\\\"]\"\n      }, '')\n  }\n\n  /**\n   * Another way to create a riot tag a bit more es6 friendly\n   * @param { HTMLElement } el - tag DOM selector or DOM node/s\n   * @param { Object } opts - tag logic\n   * @returns { Tag } new riot tag instance\n   */\n  function Tag(el, opts) {\n    // get the tag properties from the class constructor\n    var ref = this;\n    var name = ref.name;\n    var tmpl = ref.tmpl;\n    var css = ref.css;\n    var attrs = ref.attrs;\n    var onCreate = ref.onCreate;\n    // register a new tag and cache the class prototype\n    if (!__TAG_IMPL[name]) {\n      tag(name, tmpl, css, attrs, onCreate);\n      // cache the class constructor\n      __TAG_IMPL[name].class = this.constructor;\n    }\n\n    // mount the tag using the class instance\n    mount$1(el, name, opts, this);\n    // inject the component css\n    if (css) { styleManager.inject(); }\n\n    return this\n  }\n\n  /**\n   * Create a new riot tag implementation\n   * @param   { String }   name - name/id of the new riot tag\n   * @param   { String }   tmpl - tag template\n   * @param   { String }   css - custom tag css\n   * @param   { String }   attrs - root tag attributes\n   * @param   { Function } fn - user function\n   * @returns { String } name/id of the tag just created\n   */\n  function tag(name, tmpl, css, attrs, fn) {\n    if (isFunction(attrs)) {\n      fn = attrs;\n\n      if (/^[\\w-]+\\s?=/.test(css)) {\n        attrs = css;\n        css = '';\n      } else\n        { attrs = ''; }\n    }\n\n    if (css) {\n      if (isFunction(css))\n        { fn = css; }\n      else\n        { styleManager.add(css, name); }\n    }\n\n    name = name.toLowerCase();\n    __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\n    return name\n  }\n\n  /**\n   * Create a new riot tag implementation (for use by the compiler)\n   * @param   { String }   name - name/id of the new riot tag\n   * @param   { String }   tmpl - tag template\n   * @param   { String }   css - custom tag css\n   * @param   { String }   attrs - root tag attributes\n   * @param   { Function } fn - user function\n   * @returns { String } name/id of the tag just created\n   */\n  function tag2(name, tmpl, css, attrs, fn) {\n    if (css) { styleManager.add(css, name); }\n\n    __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\n    return name\n  }\n\n  /**\n   * Mount a tag using a specific tag implementation\n   * @param   { * } selector - tag DOM selector or DOM node/s\n   * @param   { String } tagName - tag implementation name\n   * @param   { Object } opts - tag logic\n   * @returns { Array } new tags instances\n   */\n  function mount(selector, tagName, opts) {\n    var tags = [];\n    var elem, allTags;\n\n    function pushTagsTo(root) {\n      if (root.tagName) {\n        var riotTag = getAttribute(root, IS_DIRECTIVE), tag;\n\n        // have tagName? force riot-tag to be the same\n        if (tagName && riotTag !== tagName) {\n          riotTag = tagName;\n          setAttribute(root, IS_DIRECTIVE, tagName);\n        }\n\n        tag = mount$1(root, riotTag || root.tagName.toLowerCase(), opts);\n\n        if (tag)\n          { tags.push(tag); }\n      } else if (root.length)\n        { each(root, pushTagsTo); } // assume nodeList\n    }\n\n    // inject styles into DOM\n    styleManager.inject();\n\n    if (isObject(tagName)) {\n      opts = tagName;\n      tagName = 0;\n    }\n\n    // crawl the DOM to find the tag\n    if (isString(selector)) {\n      selector = selector === '*' ?\n        // select all registered tags\n        // & tags found with the riot-tag attribute set\n        allTags = query() :\n        // or just the ones named like the selector\n        selector + query(selector.split(/, */));\n\n      // make sure to pass always a selector\n      // to the querySelectorAll function\n      elem = selector ? $$(selector) : [];\n    }\n    else\n      // probably you have passed already a tag or a NodeList\n      { elem = selector; }\n\n    // select all the registered and mount them inside their root elements\n    if (tagName === '*') {\n      // get all custom tags\n      tagName = allTags || query();\n      // if the root els it's just a single tag\n      if (elem.tagName)\n        { elem = $$(tagName, elem); }\n      else {\n        // select all the children for all the different root elements\n        var nodeList = [];\n\n        each(elem, function (_el) { return nodeList.push($$(tagName, _el)); });\n\n        elem = nodeList;\n      }\n      // get rid of the tagName\n      tagName = 0;\n    }\n\n    pushTagsTo(elem);\n\n    return tags\n  }\n\n  // Create a mixin that could be globally shared across all the tags\n  var mixins = {};\n  var globals = mixins[GLOBAL_MIXIN] = {};\n  var mixins_id = 0;\n\n  /**\n   * Create/Return a mixin by its name\n   * @param   { String }  name - mixin name (global mixin if object)\n   * @param   { Object }  mix - mixin logic\n   * @param   { Boolean } g - is global?\n   * @returns { Object }  the mixin logic\n   */\n  function mixin(name, mix, g) {\n    // Unnamed global\n    if (isObject(name)) {\n      mixin((\"__\" + (mixins_id++) + \"__\"), name, true);\n      return\n    }\n\n    var store = g ? globals : mixins;\n\n    // Getter\n    if (!mix) {\n      if (isUndefined(store[name]))\n        { throw new Error((\"Unregistered mixin: \" + name)) }\n\n      return store[name]\n    }\n\n    // Setter\n    store[name] = isFunction(mix) ?\n      extend(mix.prototype, store[name] || {}) && mix :\n      extend(store[name] || {}, mix);\n  }\n\n  /**\n   * Update all the tags instances created\n   * @returns { Array } all the tags instances\n   */\n  function update$1() {\n    return each(__TAGS_CACHE, function (tag) { return tag.update(); })\n  }\n\n  function unregister(name) {\n    styleManager.remove(name);\n    return delete __TAG_IMPL[name]\n  }\n\n  var version = 'v3.9.4';\n\n  var core = /*#__PURE__*/Object.freeze({\n    Tag: Tag,\n    tag: tag,\n    tag2: tag2,\n    mount: mount,\n    mixin: mixin,\n    update: update$1,\n    unregister: unregister,\n    version: version\n  });\n\n  /**\n   * Add a mixin to this tag\n   * @returns { Tag } the current tag instance\n   */\n  function componentMixin(tag$$1) {\n    var mixins = [], len = arguments.length - 1;\n    while ( len-- > 0 ) mixins[ len ] = arguments[ len + 1 ];\n\n    each(mixins, function (mix) {\n      var instance;\n      var obj;\n      var props = [];\n\n      // properties blacklisted and will not be bound to the tag instance\n      var propsBlacklist = ['init', '__proto__'];\n\n      mix = isString(mix) ? mixin(mix) : mix;\n\n      // check if the mixin is a function\n      if (isFunction(mix)) {\n        // create the new mixin instance\n        instance = new mix();\n      } else { instance = mix; }\n\n      var proto = Object.getPrototypeOf(instance);\n\n      // build multilevel prototype inheritance chain property list\n      do { props = props.concat(Object.getOwnPropertyNames(obj || instance)); }\n      while (obj = Object.getPrototypeOf(obj || instance))\n\n      // loop the keys in the function prototype or the all object keys\n      each(props, function (key) {\n        // bind methods to tag\n        // allow mixins to override other properties/parent mixins\n        if (!contains(propsBlacklist, key)) {\n          // check for getters/setters\n          var descriptor = getPropDescriptor(instance, key) || getPropDescriptor(proto, key);\n          var hasGetterSetter = descriptor && (descriptor.get || descriptor.set);\n\n          // apply method only if it does not already exist on the instance\n          if (!tag$$1.hasOwnProperty(key) && hasGetterSetter) {\n            Object.defineProperty(tag$$1, key, descriptor);\n          } else {\n            tag$$1[key] = isFunction(instance[key]) ?\n              instance[key].bind(tag$$1) :\n              instance[key];\n          }\n        }\n      });\n\n      // init method will be called automatically\n      if (instance.init)\n        { instance.init.bind(tag$$1)(tag$$1.opts); }\n    });\n\n    return tag$$1\n  }\n\n  /**\n   * Move the position of a custom tag in its parent tag\n   * @this Tag\n   * @param   { String } tagName - key where the tag was stored\n   * @param   { Number } newPos - index where the new tag will be stored\n   */\n  function moveChild(tagName, newPos) {\n    var parent = this.parent;\n    var tags;\n    // no parent no move\n    if (!parent) { return }\n\n    tags = parent.tags[tagName];\n\n    if (isArray(tags))\n      { tags.splice(newPos, 0, tags.splice(tags.indexOf(this), 1)[0]); }\n    else { arrayishAdd(parent.tags, tagName, this); }\n  }\n\n  /**\n   * Move virtual tag and all child nodes\n   * @this Tag\n   * @param { Node } src  - the node that will do the inserting\n   * @param { Tag } target - insert before this tag's first child\n   */\n  function moveVirtual(src, target) {\n    var this$1 = this;\n\n    var el = this.__.head;\n    var sib;\n    var frag = createFragment();\n\n    while (el) {\n      sib = el.nextSibling;\n      frag.appendChild(el);\n      el = sib;\n      if (el === this$1.__.tail) {\n        frag.appendChild(el);\n        src.insertBefore(frag, target.__.head);\n        break\n      }\n    }\n  }\n\n  /**\n   * Convert the item looped into an object used to extend the child tag properties\n   * @param   { Object } expr - object containing the keys used to extend the children tags\n   * @param   { * } key - value to assign to the new object returned\n   * @param   { * } val - value containing the position of the item in the array\n   * @returns { Object } - new object containing the values of the original item\n   *\n   * The variables 'key' and 'val' are arbitrary.\n   * They depend on the collection type looped (Array, Object)\n   * and on the expression used on the each tag\n   *\n   */\n  function mkitem(expr, key, val) {\n    var item = {};\n    item[expr.key] = key;\n    if (expr.pos) { item[expr.pos] = val; }\n    return item\n  }\n\n  /**\n   * Unmount the redundant tags\n   * @param   { Array } items - array containing the current items to loop\n   * @param   { Array } tags - array containing all the children tags\n   */\n  function unmountRedundant(items, tags, filteredItemsCount) {\n    var i = tags.length;\n    var j = items.length - filteredItemsCount;\n\n    while (i > j) {\n      i--;\n      remove.apply(tags[i], [tags, i]);\n    }\n  }\n\n\n  /**\n   * Remove a child tag\n   * @this Tag\n   * @param   { Array } tags - tags collection\n   * @param   { Number } i - index of the tag to remove\n   */\n  function remove(tags, i) {\n    tags.splice(i, 1);\n    this.unmount();\n    arrayishRemove(this.parent, this, this.__.tagName, true);\n  }\n\n  /**\n   * Move the nested custom tags in non custom loop tags\n   * @this Tag\n   * @param   { Number } i - current position of the loop tag\n   */\n  function moveNestedTags(i) {\n    var this$1 = this;\n\n    each(Object.keys(this.tags), function (tagName) {\n      moveChild.apply(this$1.tags[tagName], [tagName, i]);\n    });\n  }\n\n  /**\n   * Move a child tag\n   * @this Tag\n   * @param   { HTMLElement } root - dom node containing all the loop children\n   * @param   { Tag } nextTag - instance of the next tag preceding the one we want to move\n   * @param   { Boolean } isVirtual - is it a virtual tag?\n   */\n  function move(root, nextTag, isVirtual) {\n    if (isVirtual)\n      { moveVirtual.apply(this, [root, nextTag]); }\n    else\n      { safeInsert(root, this.root, nextTag.root); }\n  }\n\n  /**\n   * Insert and mount a child tag\n   * @this Tag\n   * @param   { HTMLElement } root - dom node containing all the loop children\n   * @param   { Tag } nextTag - instance of the next tag preceding the one we want to insert\n   * @param   { Boolean } isVirtual - is it a virtual tag?\n   */\n  function insert(root, nextTag, isVirtual) {\n    if (isVirtual)\n      { makeVirtual.apply(this, [root, nextTag]); }\n    else\n      { safeInsert(root, this.root, nextTag.root); }\n  }\n\n  /**\n   * Append a new tag into the DOM\n   * @this Tag\n   * @param   { HTMLElement } root - dom node containing all the loop children\n   * @param   { Boolean } isVirtual - is it a virtual tag?\n   */\n  function append(root, isVirtual) {\n    if (isVirtual)\n      { makeVirtual.call(this, root); }\n    else\n      { root.appendChild(this.root); }\n  }\n\n  /**\n   * Return the value we want to use to lookup the postion of our items in the collection\n   * @param   { String }  keyAttr         - lookup string or expression\n   * @param   { * }       originalItem    - original item from the collection\n   * @param   { Object }  keyedItem       - object created by riot via { item, i in collection }\n   * @param   { Boolean } hasKeyAttrExpr  - flag to check whether the key is an expression\n   * @returns { * } value that we will use to figure out the item position via collection.indexOf\n   */\n  function getItemId(keyAttr, originalItem, keyedItem, hasKeyAttrExpr) {\n    if (keyAttr) {\n      return hasKeyAttrExpr ?  tmpl(keyAttr, keyedItem) :  originalItem[keyAttr]\n    }\n\n    return originalItem\n  }\n\n  /**\n   * Manage tags having the 'each'\n   * @param   { HTMLElement } dom - DOM node we need to loop\n   * @param   { Tag } parent - parent tag instance where the dom node is contained\n   * @param   { String } expr - string contained in the 'each' attribute\n   * @returns { Object } expression object for this each loop\n   */\n  function _each(dom, parent, expr) {\n    var mustReorder = typeof getAttribute(dom, LOOP_NO_REORDER_DIRECTIVE) !== T_STRING || removeAttribute(dom, LOOP_NO_REORDER_DIRECTIVE);\n    var keyAttr = getAttribute(dom, KEY_DIRECTIVE);\n    var hasKeyAttrExpr = keyAttr ? tmpl.hasExpr(keyAttr) : false;\n    var tagName = getName(dom);\n    var impl = __TAG_IMPL[tagName];\n    var parentNode = dom.parentNode;\n    var placeholder = createDOMPlaceholder();\n    var child = get(dom);\n    var ifExpr = getAttribute(dom, CONDITIONAL_DIRECTIVE);\n    var tags = [];\n    var isLoop = true;\n    var innerHTML = dom.innerHTML;\n    var isAnonymous = !__TAG_IMPL[tagName];\n    var isVirtual = dom.tagName === 'VIRTUAL';\n    var oldItems = [];\n    var hasKeys;\n\n    // remove the each property from the original tag\n    removeAttribute(dom, LOOP_DIRECTIVE);\n    removeAttribute(dom, KEY_DIRECTIVE);\n\n    // parse the each expression\n    expr = tmpl.loopKeys(expr);\n    expr.isLoop = true;\n\n    if (ifExpr) { removeAttribute(dom, CONDITIONAL_DIRECTIVE); }\n\n    // insert a marked where the loop tags will be injected\n    parentNode.insertBefore(placeholder, dom);\n    parentNode.removeChild(dom);\n\n    expr.update = function updateEach() {\n      // get the new items collection\n      expr.value = tmpl(expr.val, parent);\n\n      var items = expr.value;\n      var frag = createFragment();\n      var isObject = !isArray(items) && !isString(items);\n      var root = placeholder.parentNode;\n      var tmpItems = [];\n\n      // if this DOM was removed the update here is useless\n      // this condition fixes also a weird async issue on IE in our unit test\n      if (!root) { return }\n\n      // object loop. any changes cause full redraw\n      if (isObject) {\n        hasKeys = items || false;\n        items = hasKeys ?\n          Object.keys(items).map(function (key) { return mkitem(expr, items[key], key); }) : [];\n      } else {\n        hasKeys = false;\n      }\n\n      // store the amount of filtered items\n      var filteredItemsCount = 0;\n\n      // loop all the new items\n      each(items, function (_item, i) {\n        i -= filteredItemsCount;\n\n        var item = !hasKeys && expr.key ? mkitem(expr, _item, i) : _item;\n\n        // skip this item because it must be filtered\n        if (ifExpr && !tmpl(ifExpr, extend(create(parent), item))) {\n          filteredItemsCount ++;\n          return\n        }\n\n        var itemId = getItemId(keyAttr, _item, item, hasKeyAttrExpr);\n        // reorder only if the items are objects\n        var doReorder = mustReorder && typeof _item === T_OBJECT && !hasKeys;\n        var oldPos = oldItems.indexOf(itemId);\n        var isNew = oldPos === -1;\n        var pos = !isNew && doReorder ? oldPos : i;\n        // does a tag exist in this position?\n        var tag = tags[pos];\n        var mustAppend = i >= oldItems.length;\n        var mustCreate =  doReorder && isNew || !doReorder && !tag;\n\n        // new tag\n        if (mustCreate) {\n          tag = createTag(impl, {\n            parent: parent,\n            isLoop: isLoop,\n            isAnonymous: isAnonymous,\n            tagName: tagName,\n            root: dom.cloneNode(isAnonymous),\n            item: item,\n            index: i,\n          }, innerHTML);\n\n          // mount the tag\n          tag.mount();\n\n          if (mustAppend)\n            { append.apply(tag, [frag || root, isVirtual]); }\n          else\n            { insert.apply(tag, [root, tags[i], isVirtual]); }\n\n          if (!mustAppend) { oldItems.splice(i, 0, item); }\n          tags.splice(i, 0, tag);\n          if (child) { arrayishAdd(parent.tags, tagName, tag, true); }\n        } else if (pos !== i && doReorder) {\n          // move\n          if (keyAttr || contains(items, oldItems[pos])) {\n            move.apply(tag, [root, tags[i], isVirtual]);\n            // move the old tag instance\n            tags.splice(i, 0, tags.splice(pos, 1)[0]);\n            // move the old item\n            oldItems.splice(i, 0, oldItems.splice(pos, 1)[0]);\n          }\n\n          // update the position attribute if it exists\n          if (expr.pos) { tag[expr.pos] = i; }\n\n          // if the loop tags are not custom\n          // we need to move all their custom tags into the right position\n          if (!child && tag.tags) { moveNestedTags.call(tag, i); }\n        }\n\n        // cache the original item to use it in the events bound to this node\n        // and its children\n        extend(tag.__, {\n          item: item,\n          index: i,\n          parent: parent\n        });\n\n        tmpItems[i] = itemId;\n\n        if (!mustCreate) { tag.update(item); }\n      });\n\n      // remove the redundant tags\n      unmountRedundant(items, tags, filteredItemsCount);\n\n      // clone the items array\n      oldItems = tmpItems.slice();\n\n      root.insertBefore(frag, placeholder);\n    };\n\n    expr.unmount = function () {\n      each(tags, function (t) { t.unmount(); });\n    };\n\n    return expr\n  }\n\n  var RefExpr = {\n    init: function init(dom, parent, attrName, attrValue) {\n      this.dom = dom;\n      this.attr = attrName;\n      this.rawValue = attrValue;\n      this.parent = parent;\n      this.hasExp = tmpl.hasExpr(attrValue);\n      return this\n    },\n    update: function update() {\n      var old = this.value;\n      var customParent = this.parent && getImmediateCustomParent(this.parent);\n      // if the referenced element is a custom tag, then we set the tag itself, rather than DOM\n      var tagOrDom = this.dom.__ref || this.tag || this.dom;\n\n      this.value = this.hasExp ? tmpl(this.rawValue, this.parent) : this.rawValue;\n\n      // the name changed, so we need to remove it from the old key (if present)\n      if (!isBlank(old) && customParent) { arrayishRemove(customParent.refs, old, tagOrDom); }\n      if (!isBlank(this.value) && isString(this.value)) {\n        // add it to the refs of parent tag (this behavior was changed >=3.0)\n        if (customParent) { arrayishAdd(\n          customParent.refs,\n          this.value,\n          tagOrDom,\n          // use an array if it's a looped node and the ref is not an expression\n          null,\n          this.parent.__.index\n        ); }\n\n        if (this.value !== old) {\n          setAttribute(this.dom, this.attr, this.value);\n        }\n      } else {\n        removeAttribute(this.dom, this.attr);\n      }\n\n      // cache the ref bound to this dom node\n      // to reuse it in future (see also #2329)\n      if (!this.dom.__ref) { this.dom.__ref = tagOrDom; }\n    },\n    unmount: function unmount() {\n      var tagOrDom = this.tag || this.dom;\n      var customParent = this.parent && getImmediateCustomParent(this.parent);\n      if (!isBlank(this.value) && customParent)\n        { arrayishRemove(customParent.refs, this.value, tagOrDom); }\n    }\n  }\n\n  /**\n   * Create a new ref directive\n   * @param   { HTMLElement } dom - dom node having the ref attribute\n   * @param   { Tag } context - tag instance where the DOM node is located\n   * @param   { String } attrName - either 'ref' or 'data-ref'\n   * @param   { String } attrValue - value of the ref attribute\n   * @returns { RefExpr } a new RefExpr object\n   */\n  function createRefDirective(dom, tag, attrName, attrValue) {\n    return create(RefExpr).init(dom, tag, attrName, attrValue)\n  }\n\n  /**\n   * Trigger the unmount method on all the expressions\n   * @param   { Array } expressions - DOM expressions\n   */\n  function unmountAll(expressions) {\n    each(expressions, function (expr) {\n      if (expr.unmount) { expr.unmount(true); }\n      else if (expr.tagName) { expr.tag.unmount(true); }\n      else if (expr.unmount) { expr.unmount(); }\n    });\n  }\n\n  var IfExpr = {\n    init: function init(dom, tag, expr) {\n      removeAttribute(dom, CONDITIONAL_DIRECTIVE);\n      extend(this, { tag: tag, expr: expr, stub: createDOMPlaceholder(), pristine: dom });\n      var p = dom.parentNode;\n      p.insertBefore(this.stub, dom);\n      p.removeChild(dom);\n\n      return this\n    },\n    update: function update$$1() {\n      this.value = tmpl(this.expr, this.tag);\n\n      if (this.value && !this.current) { // insert\n        this.current = this.pristine.cloneNode(true);\n        this.stub.parentNode.insertBefore(this.current, this.stub);\n        this.expressions = parseExpressions.apply(this.tag, [this.current, true]);\n      } else if (!this.value && this.current) { // remove\n        unmountAll(this.expressions);\n        if (this.current._tag) {\n          this.current._tag.unmount();\n        } else if (this.current.parentNode) {\n          this.current.parentNode.removeChild(this.current);\n        }\n        this.current = null;\n        this.expressions = [];\n      }\n\n      if (this.value) { update.call(this.tag, this.expressions); }\n    },\n    unmount: function unmount() {\n      unmountAll(this.expressions || []);\n    }\n  }\n\n  /**\n   * Create a new if directive\n   * @param   { HTMLElement } dom - if root dom node\n   * @param   { Tag } context - tag instance where the DOM node is located\n   * @param   { String } attr - if expression\n   * @returns { IFExpr } a new IfExpr object\n   */\n  function createIfDirective(dom, tag, attr) {\n    return create(IfExpr).init(dom, tag, attr)\n  }\n\n  /**\n   * Walk the tag DOM to detect the expressions to evaluate\n   * @this Tag\n   * @param   { HTMLElement } root - root tag where we will start digging the expressions\n   * @param   { Boolean } mustIncludeRoot - flag to decide whether the root must be parsed as well\n   * @returns { Array } all the expressions found\n   */\n  function parseExpressions(root, mustIncludeRoot) {\n    var this$1 = this;\n\n    var expressions = [];\n\n    walkNodes(root, function (dom) {\n      var type = dom.nodeType;\n      var attr;\n      var tagImpl;\n\n      if (!mustIncludeRoot && dom === root) { return }\n\n      // text node\n      if (type === 3 && dom.parentNode.tagName !== 'STYLE' && tmpl.hasExpr(dom.nodeValue))\n        { expressions.push({dom: dom, expr: dom.nodeValue}); }\n\n      if (type !== 1) { return }\n\n      var isVirtual = dom.tagName === 'VIRTUAL';\n\n      // loop. each does it's own thing (for now)\n      if (attr = getAttribute(dom, LOOP_DIRECTIVE)) {\n        if(isVirtual) { setAttribute(dom, 'loopVirtual', true); } // ignore here, handled in _each\n        expressions.push(_each(dom, this$1, attr));\n        return false\n      }\n\n      // if-attrs become the new parent. Any following expressions (either on the current\n      // element, or below it) become children of this expression.\n      if (attr = getAttribute(dom, CONDITIONAL_DIRECTIVE)) {\n        expressions.push(createIfDirective(dom, this$1, attr));\n        return false\n      }\n\n      if (attr = getAttribute(dom, IS_DIRECTIVE)) {\n        if (tmpl.hasExpr(attr)) {\n          expressions.push({\n            isRtag: true,\n            expr: attr,\n            dom: dom,\n            attrs: [].slice.call(dom.attributes)\n          });\n\n          return false\n        }\n      }\n\n      // if this is a tag, stop traversing here.\n      // we ignore the root, since parseExpressions is called while we're mounting that root\n      tagImpl = get(dom);\n\n      if(isVirtual) {\n        if(getAttribute(dom, 'virtualized')) {dom.parentElement.removeChild(dom); } // tag created, remove from dom\n        if(!tagImpl && !getAttribute(dom, 'virtualized') && !getAttribute(dom, 'loopVirtual'))  // ok to create virtual tag\n          { tagImpl = { tmpl: dom.outerHTML }; }\n      }\n\n      if (tagImpl && (dom !== root || mustIncludeRoot)) {\n        var hasIsDirective = getAttribute(dom, IS_DIRECTIVE);\n        if(isVirtual && !hasIsDirective) { // handled in update\n          // can not remove attribute like directives\n          // so flag for removal after creation to prevent maximum stack error\n          setAttribute(dom, 'virtualized', true);\n          var tag = createTag(\n            {tmpl: dom.outerHTML},\n            {root: dom, parent: this$1},\n            dom.innerHTML\n          );\n\n          expressions.push(tag); // no return, anonymous tag, keep parsing\n        } else {\n          if (hasIsDirective && isVirtual)\n            { warn((\"Virtual tags shouldn't be used together with the \\\"\" + IS_DIRECTIVE + \"\\\" attribute - https://github.com/riot/riot/issues/2511\")); }\n\n          expressions.push(\n            initChild(\n              tagImpl,\n              {\n                root: dom,\n                parent: this$1\n              },\n              dom.innerHTML,\n              this$1\n            )\n          );\n          return false\n        }\n      }\n\n      // attribute expressions\n      parseAttributes.apply(this$1, [dom, dom.attributes, function (attr, expr) {\n        if (!expr) { return }\n        expressions.push(expr);\n      }]);\n    });\n\n    return expressions\n  }\n\n  /**\n   * Calls `fn` for every attribute on an element. If that attr has an expression,\n   * it is also passed to fn.\n   * @this Tag\n   * @param   { HTMLElement } dom - dom node to parse\n   * @param   { Array } attrs - array of attributes\n   * @param   { Function } fn - callback to exec on any iteration\n   */\n  function parseAttributes(dom, attrs, fn) {\n    var this$1 = this;\n\n    each(attrs, function (attr) {\n      if (!attr) { return false }\n\n      var name = attr.name;\n      var bool = isBoolAttr(name);\n      var expr;\n\n      if (contains(REF_DIRECTIVES, name) && dom.tagName.toLowerCase() !== YIELD_TAG) {\n        expr =  createRefDirective(dom, this$1, name, attr.value);\n      } else if (tmpl.hasExpr(attr.value)) {\n        expr = {dom: dom, expr: attr.value, attr: name, bool: bool};\n      }\n\n      fn(attr, expr);\n    });\n  }\n\n  /**\n   * Manage the mount state of a tag triggering also the observable events\n   * @this Tag\n   * @param { Boolean } value - ..of the isMounted flag\n   */\n  function setMountState(value) {\n    var ref = this.__;\n    var isAnonymous = ref.isAnonymous;\n\n    define(this, 'isMounted', value);\n\n    if (!isAnonymous) {\n      if (value) { this.trigger('mount'); }\n      else {\n        this.trigger('unmount');\n        this.off('*');\n        this.__.wasCreated = false;\n      }\n    }\n  }\n\n  /**\n   * Mount the current tag instance\n   * @returns { Tag } the current tag instance\n   */\n  function componentMount(tag$$1, dom, expressions, opts) {\n    var __ = tag$$1.__;\n    var root = __.root;\n    root._tag = tag$$1; // keep a reference to the tag just created\n\n    // Read all the attrs on this instance. This give us the info we need for updateOpts\n    parseAttributes.apply(__.parent, [root, root.attributes, function (attr, expr) {\n      if (!__.isAnonymous && RefExpr.isPrototypeOf(expr)) { expr.tag = tag$$1; }\n      attr.expr = expr;\n      __.instAttrs.push(attr);\n    }]);\n\n    // update the root adding custom attributes coming from the compiler\n    walkAttributes(__.impl.attrs, function (k, v) { __.implAttrs.push({name: k, value: v}); });\n    parseAttributes.apply(tag$$1, [root, __.implAttrs, function (attr, expr) {\n      if (expr) { expressions.push(expr); }\n      else { setAttribute(root, attr.name, attr.value); }\n    }]);\n\n    // initialiation\n    updateOpts.apply(tag$$1, [__.isLoop, __.parent, __.isAnonymous, opts, __.instAttrs]);\n\n    // add global mixins\n    var globalMixin = mixin(GLOBAL_MIXIN);\n\n    if (globalMixin && !__.skipAnonymous) {\n      for (var i in globalMixin) {\n        if (globalMixin.hasOwnProperty(i)) {\n          tag$$1.mixin(globalMixin[i]);\n        }\n      }\n    }\n\n    if (__.impl.fn) { __.impl.fn.call(tag$$1, opts); }\n\n    if (!__.skipAnonymous) { tag$$1.trigger('before-mount'); }\n\n    // parse layout after init. fn may calculate args for nested custom tags\n    each(parseExpressions.apply(tag$$1, [dom, __.isAnonymous]), function (e) { return expressions.push(e); });\n\n    tag$$1.update(__.item);\n\n    if (!__.isAnonymous && !__.isInline) {\n      while (dom.firstChild) { root.appendChild(dom.firstChild); }\n    }\n\n    define(tag$$1, 'root', root);\n\n    // if we need to wait that the parent \"mount\" or \"updated\" event gets triggered\n    if (!__.skipAnonymous && tag$$1.parent) {\n      var p = getImmediateCustomParent(tag$$1.parent);\n      p.one(!p.isMounted ? 'mount' : 'updated', function () {\n        setMountState.call(tag$$1, true);\n      });\n    } else {\n      // otherwise it's not a child tag we can trigger its mount event\n      setMountState.call(tag$$1, true);\n    }\n\n    tag$$1.__.wasCreated = true;\n\n    return tag$$1\n  }\n\n  /**\n   * Unmount the tag instance\n   * @param { Boolean } mustKeepRoot - if it's true the root node will not be removed\n   * @returns { Tag } the current tag instance\n   */\n  function tagUnmount(tag, mustKeepRoot, expressions) {\n    var __ = tag.__;\n    var root = __.root;\n    var tagIndex = __TAGS_CACHE.indexOf(tag);\n    var p = root.parentNode;\n\n    if (!__.skipAnonymous) { tag.trigger('before-unmount'); }\n\n    // clear all attributes coming from the mounted tag\n    walkAttributes(__.impl.attrs, function (name) {\n      if (startsWith(name, ATTRS_PREFIX))\n        { name = name.slice(ATTRS_PREFIX.length); }\n\n      removeAttribute(root, name);\n    });\n\n    // remove all the event listeners\n    tag.__.listeners.forEach(function (dom) {\n      Object.keys(dom[RIOT_EVENTS_KEY]).forEach(function (eventName) {\n        dom.removeEventListener(eventName, dom[RIOT_EVENTS_KEY][eventName]);\n      });\n    });\n\n    // remove tag instance from the global tags cache collection\n    if (tagIndex !== -1) { __TAGS_CACHE.splice(tagIndex, 1); }\n\n    // clean up the parent tags object\n    if (__.parent && !__.isAnonymous) {\n      var ptag = getImmediateCustomParent(__.parent);\n\n      if (__.isVirtual) {\n        Object\n          .keys(tag.tags)\n          .forEach(function (tagName) { return arrayishRemove(ptag.tags, tagName, tag.tags[tagName]); });\n      } else {\n        arrayishRemove(ptag.tags, __.tagName, tag);\n      }\n    }\n\n    // unmount all the virtual directives\n    if (tag.__.virts) {\n      each(tag.__.virts, function (v) {\n        if (v.parentNode) { v.parentNode.removeChild(v); }\n      });\n    }\n\n    // allow expressions to unmount themselves\n    unmountAll(expressions);\n    each(__.instAttrs, function (a) { return a.expr && a.expr.unmount && a.expr.unmount(); });\n\n    // clear the tag html if it's necessary\n    if (mustKeepRoot) { setInnerHTML(root, ''); }\n    // otherwise detach the root tag from the DOM\n    else if (p) { p.removeChild(root); }\n\n    // custom internal unmount function to avoid relying on the observable\n    if (__.onUnmount) { __.onUnmount(); }\n\n    // weird fix for a weird edge case #2409 and #2436\n    // some users might use your software not as you've expected\n    // so I need to add these dirty hacks to mitigate unexpected issues\n    if (!tag.isMounted) { setMountState.call(tag, true); }\n\n    setMountState.call(tag, false);\n\n    delete root._tag;\n\n    return tag\n  }\n\n  /**\n   * Tag creation factory function\n   * @constructor\n   * @param { Object } impl - it contains the tag template, and logic\n   * @param { Object } conf - tag options\n   * @param { String } innerHTML - html that eventually we need to inject in the tag\n   */\n  function createTag(impl, conf, innerHTML) {\n    if ( impl === void 0 ) impl = {};\n    if ( conf === void 0 ) conf = {};\n\n    var tag = conf.context || {};\n    var opts = extend({}, conf.opts);\n    var parent = conf.parent;\n    var isLoop = conf.isLoop;\n    var isAnonymous = !!conf.isAnonymous;\n    var skipAnonymous = settings.skipAnonymousTags && isAnonymous;\n    var item = conf.item;\n    // available only for the looped nodes\n    var index = conf.index;\n    // All attributes on the Tag when it's first parsed\n    var instAttrs = [];\n    // expressions on this type of Tag\n    var implAttrs = [];\n    var expressions = [];\n    var root = conf.root;\n    var tagName = conf.tagName || getName(root);\n    var isVirtual = tagName === 'virtual';\n    var isInline = !isVirtual && !impl.tmpl;\n    var dom;\n\n    // make this tag observable\n    if (!skipAnonymous) { observable(tag); }\n    // only call unmount if we have a valid __TAG_IMPL (has name property)\n    if (impl.name && root._tag) { root._tag.unmount(true); }\n\n    // not yet mounted\n    define(tag, 'isMounted', false);\n\n    define(tag, '__', {\n      impl: impl,\n      root: root,\n      skipAnonymous: skipAnonymous,\n      implAttrs: implAttrs,\n      isAnonymous: isAnonymous,\n      instAttrs: instAttrs,\n      innerHTML: innerHTML,\n      tagName: tagName,\n      index: index,\n      isLoop: isLoop,\n      isInline: isInline,\n      item: item,\n      parent: parent,\n      // tags having event listeners\n      // it would be better to use weak maps here but we can not introduce breaking changes now\n      listeners: [],\n      // these vars will be needed only for the virtual tags\n      virts: [],\n      wasCreated: false,\n      tail: null,\n      head: null\n    });\n\n    // create a unique id to this tag\n    // it could be handy to use it also to improve the virtual dom rendering speed\n    define(tag, '_riot_id', uid()); // base 1 allows test !t._riot_id\n    define(tag, 'root', root);\n    extend(tag, { opts: opts }, item);\n    // protect the \"tags\" and \"refs\" property from being overridden\n    define(tag, 'parent', parent || null);\n    define(tag, 'tags', {});\n    define(tag, 'refs', {});\n\n    if (isInline || isLoop && isAnonymous) {\n      dom = root;\n    } else {\n      if (!isVirtual) { root.innerHTML = ''; }\n      dom = mkdom(impl.tmpl, innerHTML, isSvg(root));\n    }\n\n    define(tag, 'update', function (data) { return componentUpdate(tag, data, expressions); });\n    define(tag, 'mixin', function () {\n      var mixins = [], len = arguments.length;\n      while ( len-- ) mixins[ len ] = arguments[ len ];\n\n      return componentMixin.apply(void 0, [ tag ].concat( mixins ));\n    });\n    define(tag, 'mount', function () { return componentMount(tag, dom, expressions, opts); });\n    define(tag, 'unmount', function (mustKeepRoot) { return tagUnmount(tag, mustKeepRoot, expressions); });\n\n    return tag\n  }\n\n  /**\n   * Mount a tag creating new Tag instance\n   * @param   { Object } root - dom node where the tag will be mounted\n   * @param   { String } tagName - name of the riot tag we want to mount\n   * @param   { Object } opts - options to pass to the Tag instance\n   * @param   { Object } ctx - optional context that will be used to extend an existing class ( used in riot.Tag )\n   * @returns { Tag } a new Tag instance\n   */\n  function mount$1(root, tagName, opts, ctx) {\n    var impl = __TAG_IMPL[tagName];\n    var implClass = __TAG_IMPL[tagName].class;\n    var context = ctx || (implClass ? create(implClass.prototype) : {});\n    // cache the inner HTML to fix #855\n    var innerHTML = root._innerHTML = root._innerHTML || root.innerHTML;\n    var conf = extend({ root: root, opts: opts, context: context }, { parent: opts ? opts.parent : null });\n    var tag;\n\n    if (impl && root) { tag = createTag(impl, conf, innerHTML); }\n\n    if (tag && tag.mount) {\n      tag.mount(true);\n      // add this tag to the virtualDom variable\n      if (!contains(__TAGS_CACHE, tag)) { __TAGS_CACHE.push(tag); }\n    }\n\n    return tag\n  }\n\n\n\n  var tags = /*#__PURE__*/Object.freeze({\n    arrayishAdd: arrayishAdd,\n    getTagName: getName,\n    inheritParentProps: inheritParentProps,\n    mountTo: mount$1,\n    selectTags: query,\n    arrayishRemove: arrayishRemove,\n    getTag: get,\n    initChildTag: initChild,\n    moveChildTag: moveChild,\n    makeReplaceVirtual: makeReplaceVirtual,\n    getImmediateCustomParentTag: getImmediateCustomParent,\n    makeVirtual: makeVirtual,\n    moveVirtual: moveVirtual,\n    unmountAll: unmountAll,\n    createIfDirective: createIfDirective,\n    createRefDirective: createRefDirective\n  });\n\n  /**\n   * Riot public api\n   */\n  var settings$1 = settings;\n  var util = {\n    tmpl: tmpl,\n    brackets: brackets,\n    styleManager: styleManager,\n    vdom: __TAGS_CACHE,\n    styleNode: styleManager.styleNode,\n    // export the riot internal utils as well\n    dom: dom,\n    check: check,\n    misc: misc,\n    tags: tags\n  };\n\n  // export the core props/methods\n  var Tag$1 = Tag;\n  var tag$1 = tag;\n  var tag2$1 = tag2;\n  var mount$2 = mount;\n  var mixin$1 = mixin;\n  var update$2 = update$1;\n  var unregister$1 = unregister;\n  var version$1 = version;\n  var observable$1 = observable;\n\n  var riot$1 = extend({}, core, {\n    observable: observable,\n    settings: settings$1,\n    util: util,\n  })\n\n  exports.settings = settings$1;\n  exports.util = util;\n  exports.Tag = Tag$1;\n  exports.tag = tag$1;\n  exports.tag2 = tag2$1;\n  exports.mount = mount$2;\n  exports.mixin = mixin$1;\n  exports.update = update$2;\n  exports.unregister = unregister$1;\n  exports.version = version$1;\n  exports.observable = observable$1;\n  exports.default = riot$1;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmlvdC9yaW90LmpzP2ZhNTIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsQ0FBQyw0QkFBNEI7O0FBRTdCO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxHQUFHLEdBQUc7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLDZDQUE2QztBQUNwRDtBQUNBLE9BQU8sNkJBQTZCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBCQUEwQjtBQUNwRDtBQUNBLE9BQU8sT0FBTyxvQ0FBb0M7O0FBRWxEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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MEI7O0FBRTFCO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBOztBQUVBLDJDQUEyQyxnREFBZ0QsRUFBRTtBQUM3RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsc0NBQXNDLG9EQUFvRCxFQUFFO0FBQzVGLG9EQUFvRCxtREFBbUQsRUFBRTs7QUFFekc7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0EsdUJBQXVCLDJDQUEyQyxHQUFHLG9DQUFvQztBQUN6Rzs7QUFFQSx1QkFBdUIsd0NBQXdDOztBQUUvRDtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsd0JBQXdCO0FBQ2pFOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdELGNBQWM7O0FBRTlELENBQUMiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIFJpb3QgdjMuOS40LCBAbGljZW5zZSBNSVQgKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgKGZhY3RvcnkoKGdsb2JhbC5yaW90ID0ge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIFNob3J0ZXIgYW5kIGZhc3Qgd2F5IHRvIHNlbGVjdCBhIHNpbmdsZSBub2RlIGluIHRoZSBET01cbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSBzZWxlY3RvciAtIHVuaXF1ZSBkb20gc2VsZWN0b3JcbiAgICogQHBhcmFtICAgeyBPYmplY3QgfSBjdHggLSBET00gbm9kZSB3aGVyZSB0aGUgdGFyZ2V0IG9mIG91ciBzZWFyY2ggd2lsbCBpcyBsb2NhdGVkXG4gICAqIEByZXR1cm5zIHsgT2JqZWN0IH0gZG9tIG5vZGUgZm91bmRcbiAgICovXG4gIGZ1bmN0aW9uICQoc2VsZWN0b3IsIGN0eCkge1xuICAgIHJldHVybiAoY3R4IHx8IGRvY3VtZW50KS5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKVxuICB9XG5cbiAgdmFyXG4gICAgLy8gYmUgYXdhcmUsIGludGVybmFsIHVzYWdlXG4gICAgLy8gQVRURU5USU9OOiBwcmVmaXggdGhlIGdsb2JhbCBkeW5hbWljIHZhcmlhYmxlcyB3aXRoIGBfX2BcbiAgICAvLyB0YWdzIGluc3RhbmNlcyBjYWNoZVxuICAgIF9fVEFHU19DQUNIRSA9IFtdLFxuICAgIC8vIHRhZ3MgaW1wbGVtZW50YXRpb24gY2FjaGVcbiAgICBfX1RBR19JTVBMID0ge30sXG4gICAgWUlFTERfVEFHID0gJ3lpZWxkJyxcblxuICAgIC8qKlxuICAgICAqIENvbnN0XG4gICAgICovXG4gICAgR0xPQkFMX01JWElOID0gJ19fZ2xvYmFsX21peGluJyxcblxuICAgIC8vIHJpb3Qgc3BlY2lmaWMgcHJlZml4ZXMgb3IgYXR0cmlidXRlc1xuICAgIEFUVFJTX1BSRUZJWCA9ICdyaW90LScsXG5cbiAgICAvLyBSaW90IERpcmVjdGl2ZXNcbiAgICBSRUZfRElSRUNUSVZFUyA9IFsncmVmJywgJ2RhdGEtcmVmJ10sXG4gICAgSVNfRElSRUNUSVZFID0gJ2RhdGEtaXMnLFxuICAgIENPTkRJVElPTkFMX0RJUkVDVElWRSA9ICdpZicsXG4gICAgTE9PUF9ESVJFQ1RJVkUgPSAnZWFjaCcsXG4gICAgTE9PUF9OT19SRU9SREVSX0RJUkVDVElWRSA9ICduby1yZW9yZGVyJyxcbiAgICBTSE9XX0RJUkVDVElWRSA9ICdzaG93JyxcbiAgICBISURFX0RJUkVDVElWRSA9ICdoaWRlJyxcbiAgICBLRVlfRElSRUNUSVZFID0gJ2tleScsXG4gICAgUklPVF9FVkVOVFNfS0VZID0gJ19fcmlvdC1ldmVudHNfXycsXG5cbiAgICAvLyBmb3IgdHlwZW9mID09ICcnIGNvbXBhcmlzb25zXG4gICAgVF9TVFJJTkcgPSAnc3RyaW5nJyxcbiAgICBUX09CSkVDVCA9ICdvYmplY3QnLFxuICAgIFRfVU5ERUYgID0gJ3VuZGVmaW5lZCcsXG4gICAgVF9GVU5DVElPTiA9ICdmdW5jdGlvbicsXG5cbiAgICBYTElOS19OUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcbiAgICBTVkdfTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICAgIFhMSU5LX1JFR0VYID0gL154bGluazooXFx3KykvLFxuXG4gICAgV0lOID0gdHlwZW9mIHdpbmRvdyA9PT0gVF9VTkRFRiA/IHVuZGVmaW5lZCA6IHdpbmRvdyxcblxuICAgIC8vIHNwZWNpYWwgbmF0aXZlIHRhZ3MgdGhhdCBjYW5ub3QgYmUgdHJlYXRlZCBsaWtlIHRoZSBvdGhlcnNcbiAgICBSRV9TUEVDSUFMX1RBR1MgPSAvXig/OnQoPzpib2R5fGhlYWR8Zm9vdHxbcmhkXSl8Y2FwdGlvbnxjb2woPzpncm91cCk/fG9wdCg/Omlvbnxncm91cCkpJC8sXG4gICAgUkVfU1BFQ0lBTF9UQUdTX05PX09QVElPTiA9IC9eKD86dCg/OmJvZHl8aGVhZHxmb290fFtyaGRdKXxjYXB0aW9ufGNvbCg/Omdyb3VwKT8pJC8sXG4gICAgUkVfRVZFTlRTX1BSRUZJWCA9IC9eb24vLFxuICAgIFJFX0hUTUxfQVRUUlMgPSAvKFstXFx3XSspID89ID8oPzpcIihbXlwiXSopfCcoW14nXSopfCh7W159XSp9KSkvZyxcbiAgICAvLyBzb21lIERPTSBhdHRyaWJ1dGVzIG11c3QgYmUgbm9ybWFsaXplZFxuICAgIENBU0VfU0VOU0lUSVZFX0FUVFJJQlVURVMgPSB7XG4gICAgICAndmlld2JveCc6ICd2aWV3Qm94JyxcbiAgICAgICdwcmVzZXJ2ZWFzcGVjdHJhdGlvJzogJ3ByZXNlcnZlQXNwZWN0UmF0aW8nXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBNYXRjaGVzIGJvb2xlYW4gSFRNTCBhdHRyaWJ1dGVzIGluIHRoZSByaW90IHRhZyBkZWZpbml0aW9uLlxuICAgICAqIFdpdGggYSBsb25nIGxpc3QgbGlrZSB0aGlzLCBhIHJlZ2V4IGlzIGZhc3RlciB0aGFuIGBbXS5pbmRleE9mYCBpbiBtb3N0IGJyb3dzZXJzLlxuICAgICAqIEBjb25zdCB7UmVnRXhwfVxuICAgICAqIEBzZWUgW2F0dHJpYnV0ZXMubWRdKGh0dHBzOi8vZ2l0aHViLmNvbS9yaW90L2NvbXBpbGVyL2Jsb2IvZGV2L2RvYy9hdHRyaWJ1dGVzLm1kKVxuICAgICAqL1xuICAgIFJFX0JPT0xfQVRUUlMgPSAvXig/OmRpc2FibGVkfGNoZWNrZWR8cmVhZG9ubHl8cmVxdWlyZWR8YWxsb3dmdWxsc2NyZWVufGF1dG8oPzpmb2N1c3xwbGF5KXxjb21wYWN0fGNvbnRyb2xzfGRlZmF1bHR8Zm9ybW5vdmFsaWRhdGV8aGlkZGVufGlzbWFwfGl0ZW1zY29wZXxsb29wfG11bHRpcGxlfG11dGVkfG5vKD86cmVzaXplfHNoYWRlfHZhbGlkYXRlfHdyYXApP3xvcGVufHJldmVyc2VkfHNlYW1sZXNzfHNlbGVjdGVkfHNvcnRhYmxlfHRydWVzcGVlZHx0eXBlbXVzdG1hdGNoKSQvLFxuICAgIC8vIHZlcnNpb24jIGZvciBJRSA4LTExLCAwIGZvciBvdGhlcnNcbiAgICBJRV9WRVJTSU9OID0gKFdJTiAmJiBXSU4uZG9jdW1lbnQgfHwge30pLmRvY3VtZW50TW9kZSB8IDA7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGdlbmVyaWMgRE9NIG5vZGVcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSBuYW1lIC0gbmFtZSBvZiB0aGUgRE9NIG5vZGUgd2Ugd2FudCB0byBjcmVhdGVcbiAgICogQHJldHVybnMgeyBPYmplY3QgfSBET00gbm9kZSBqdXN0IGNyZWF0ZWRcbiAgICovXG4gIGZ1bmN0aW9uIG1ha2VFbGVtZW50KG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZSA9PT0gJ3N2ZycgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBuYW1lKSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYW55IERPTSBhdHRyaWJ1dGVcbiAgICogQHBhcmFtIHsgT2JqZWN0IH0gZG9tIC0gRE9NIG5vZGUgd2Ugd2FudCB0byB1cGRhdGVcbiAgICogQHBhcmFtIHsgU3RyaW5nIH0gbmFtZSAtIG5hbWUgb2YgdGhlIHByb3BlcnR5IHdlIHdhbnQgdG8gc2V0XG4gICAqIEBwYXJhbSB7IFN0cmluZyB9IHZhbCAtIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSB3ZSB3YW50IHRvIHNldFxuICAgKi9cbiAgZnVuY3Rpb24gc2V0QXR0cmlidXRlKGRvbSwgbmFtZSwgdmFsKSB7XG4gICAgdmFyIHhsaW5rID0gWExJTktfUkVHRVguZXhlYyhuYW1lKTtcbiAgICBpZiAoeGxpbmsgJiYgeGxpbmtbMV0pXG4gICAgICB7IGRvbS5zZXRBdHRyaWJ1dGVOUyhYTElOS19OUywgeGxpbmtbMV0sIHZhbCk7IH1cbiAgICBlbHNlXG4gICAgICB7IGRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsKTsgfVxuICB9XG5cbiAgdmFyIHN0eWxlTm9kZTtcbiAgLy8gQ3JlYXRlIGNhY2hlIGFuZCBzaG9ydGN1dCB0byB0aGUgY29ycmVjdCBwcm9wZXJ0eVxuICB2YXIgY3NzVGV4dFByb3A7XG4gIHZhciBieU5hbWUgPSB7fTtcbiAgdmFyIG5lZWRzSW5qZWN0ID0gZmFsc2U7XG5cbiAgLy8gc2tpcCB0aGUgZm9sbG93aW5nIGNvZGUgb24gdGhlIHNlcnZlclxuICBpZiAoV0lOKSB7XG4gICAgc3R5bGVOb2RlID0gKChmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBjcmVhdGUgYSBuZXcgc3R5bGUgZWxlbWVudCB3aXRoIHRoZSBjb3JyZWN0IHR5cGVcbiAgICAgIHZhciBuZXdOb2RlID0gbWFrZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAvLyByZXBsYWNlIGFueSB1c2VyIG5vZGUgb3IgaW5zZXJ0IHRoZSBuZXcgb25lIGludG8gdGhlIGhlYWRcbiAgICAgIHZhciB1c2VyTm9kZSA9ICQoJ3N0eWxlW3R5cGU9cmlvdF0nKTtcblxuICAgICAgc2V0QXR0cmlidXRlKG5ld05vZGUsICd0eXBlJywgJ3RleHQvY3NzJyk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgaWYgKHVzZXJOb2RlKSB7XG4gICAgICAgIGlmICh1c2VyTm9kZS5pZCkgeyBuZXdOb2RlLmlkID0gdXNlck5vZGUuaWQ7IH1cbiAgICAgICAgdXNlck5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobmV3Tm9kZSwgdXNlck5vZGUpO1xuICAgICAgfSBlbHNlIHsgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChuZXdOb2RlKTsgfVxuXG4gICAgICByZXR1cm4gbmV3Tm9kZVxuICAgIH0pKSgpO1xuICAgIGNzc1RleHRQcm9wID0gc3R5bGVOb2RlLnN0eWxlU2hlZXQ7XG4gIH1cblxuICAvKipcbiAgICogT2JqZWN0IHRoYXQgd2lsbCBiZSB1c2VkIHRvIGluamVjdCBhbmQgbWFuYWdlIHRoZSBjc3Mgb2YgZXZlcnkgdGFnIGluc3RhbmNlXG4gICAqL1xuICB2YXIgc3R5bGVNYW5hZ2VyID0ge1xuICAgIHN0eWxlTm9kZTogc3R5bGVOb2RlLFxuICAgIC8qKlxuICAgICAqIFNhdmUgYSB0YWcgc3R5bGUgdG8gYmUgbGF0ZXIgaW5qZWN0ZWQgaW50byBET01cbiAgICAgKiBAcGFyYW0geyBTdHJpbmcgfSBjc3MgLSBjc3Mgc3RyaW5nXG4gICAgICogQHBhcmFtIHsgU3RyaW5nIH0gbmFtZSAtIGlmIGl0J3MgcGFzc2VkIHdlIHdpbGwgbWFwIHRoZSBjc3MgdG8gYSB0YWduYW1lXG4gICAgICovXG4gICAgYWRkOiBmdW5jdGlvbiBhZGQoY3NzLCBuYW1lKSB7XG4gICAgICBieU5hbWVbbmFtZV0gPSBjc3M7XG4gICAgICBuZWVkc0luamVjdCA9IHRydWU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJbmplY3QgYWxsIHByZXZpb3VzbHkgc2F2ZWQgdGFnIHN0eWxlcyBpbnRvIERPTVxuICAgICAqIGlubmVySFRNTCBzZWVtcyBzbG93OiBodHRwOi8vanNwZXJmLmNvbS9yaW90LWluc2VydC1zdHlsZVxuICAgICAqL1xuICAgIGluamVjdDogZnVuY3Rpb24gaW5qZWN0KCkge1xuICAgICAgaWYgKCFXSU4gfHwgIW5lZWRzSW5qZWN0KSB7IHJldHVybiB9XG4gICAgICBuZWVkc0luamVjdCA9IGZhbHNlO1xuICAgICAgdmFyIHN0eWxlID0gT2JqZWN0LmtleXMoYnlOYW1lKVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChrKSB7IHJldHVybiBieU5hbWVba107IH0pXG4gICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICBpZiAoY3NzVGV4dFByb3ApIHsgY3NzVGV4dFByb3AuY3NzVGV4dCA9IHN0eWxlOyB9XG4gICAgICBlbHNlIHsgc3R5bGVOb2RlLmlubmVySFRNTCA9IHN0eWxlOyB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIHRhZyBzdHlsZSBvZiBpbmplY3RlZCBET00gbGF0ZXIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgYSByZWdpc3RlcmVkIHRhZ25hbWVcbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShuYW1lKSB7XG4gICAgICBkZWxldGUgYnlOYW1lW25hbWVdO1xuICAgICAgbmVlZHNJbmplY3QgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcmlvdCB0ZW1wbGF0ZSBlbmdpbmVcbiAgICogQHZlcnNpb24gdjMuMC44XG4gICAqL1xuXG4gIHZhciBza2lwUmVnZXggPSAoZnVuY3Rpb24gKCkgeyAvL2VzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAgIHZhciBiZWZvcmVSZUNoYXJzID0gJ1t7KCw7Oj89fCYhXn4+JSovJztcblxuICAgIHZhciBiZWZvcmVSZVdvcmRzID0gW1xuICAgICAgJ2Nhc2UnLFxuICAgICAgJ2RlZmF1bHQnLFxuICAgICAgJ2RvJyxcbiAgICAgICdlbHNlJyxcbiAgICAgICdpbicsXG4gICAgICAnaW5zdGFuY2VvZicsXG4gICAgICAncHJlZml4JyxcbiAgICAgICdyZXR1cm4nLFxuICAgICAgJ3R5cGVvZicsXG4gICAgICAndm9pZCcsXG4gICAgICAneWllbGQnXG4gICAgXTtcblxuICAgIHZhciB3b3Jkc0xhc3RDaGFyID0gYmVmb3JlUmVXb3Jkcy5yZWR1Y2UoZnVuY3Rpb24gKHMsIHcpIHtcbiAgICAgIHJldHVybiBzICsgdy5zbGljZSgtMSlcbiAgICB9LCAnJyk7XG5cbiAgICB2YXIgUkVfUkVHRVggPSAvXlxcLyg/PVteKj4vXSlbXlsvXFxcXF0qKD86KD86XFxcXC58XFxbKD86XFxcXC58W15cXF1cXFxcXSopKlxcXSlbXltcXFxcL10qKSo/XFwvW2dpbXV5XSovO1xuICAgIHZhciBSRV9WTl9DSEFSID0gL1skXFx3XS87XG5cbiAgICBmdW5jdGlvbiBwcmV2IChjb2RlLCBwb3MpIHtcbiAgICAgIHdoaWxlICgtLXBvcyA+PSAwICYmIC9cXHMvLnRlc3QoY29kZVtwb3NdKSl7IH1cbiAgICAgIHJldHVybiBwb3NcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfc2tpcFJlZ2V4IChjb2RlLCBzdGFydCkge1xuXG4gICAgICB2YXIgcmUgPSAvLiovZztcbiAgICAgIHZhciBwb3MgPSByZS5sYXN0SW5kZXggPSBzdGFydCsrO1xuICAgICAgdmFyIG1hdGNoID0gcmUuZXhlYyhjb2RlKVswXS5tYXRjaChSRV9SRUdFWCk7XG5cbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICB2YXIgbmV4dCA9IHBvcyArIG1hdGNoWzBdLmxlbmd0aDtcblxuICAgICAgICBwb3MgPSBwcmV2KGNvZGUsIHBvcyk7XG4gICAgICAgIHZhciBjID0gY29kZVtwb3NdO1xuXG4gICAgICAgIGlmIChwb3MgPCAwIHx8IH5iZWZvcmVSZUNoYXJzLmluZGV4T2YoYykpIHtcbiAgICAgICAgICByZXR1cm4gbmV4dFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPT09ICcuJykge1xuXG4gICAgICAgICAgaWYgKGNvZGVbcG9zIC0gMV0gPT09ICcuJykge1xuICAgICAgICAgICAgc3RhcnQgPSBuZXh0O1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICcrJyB8fCBjID09PSAnLScpIHtcblxuICAgICAgICAgIGlmIChjb2RlWy0tcG9zXSAhPT0gYyB8fFxuICAgICAgICAgICAgICAocG9zID0gcHJldihjb2RlLCBwb3MpKSA8IDAgfHxcbiAgICAgICAgICAgICAgIVJFX1ZOX0NIQVIudGVzdChjb2RlW3Bvc10pKSB7XG4gICAgICAgICAgICBzdGFydCA9IG5leHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAofndvcmRzTGFzdENoYXIuaW5kZXhPZihjKSkge1xuXG4gICAgICAgICAgdmFyIGVuZCA9IHBvcyArIDE7XG5cbiAgICAgICAgICB3aGlsZSAoLS1wb3MgPj0gMCAmJiBSRV9WTl9DSEFSLnRlc3QoY29kZVtwb3NdKSl7IH1cbiAgICAgICAgICBpZiAofmJlZm9yZVJlV29yZHMuaW5kZXhPZihjb2RlLnNsaWNlKHBvcyArIDEsIGVuZCkpKSB7XG4gICAgICAgICAgICBzdGFydCA9IG5leHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGFydFxuICAgIH1cblxuICAgIHJldHVybiBfc2tpcFJlZ2V4XG5cbiAgfSkoKTtcblxuICAvKipcbiAgICogcmlvdC51dGlsLmJyYWNrZXRzXG4gICAqXG4gICAqIC0gYGJyYWNrZXRzICAgIGAgLSBSZXR1cm5zIGEgc3RyaW5nIG9yIHJlZ2V4IGJhc2VkIG9uIGl0cyBwYXJhbWV0ZXJcbiAgICogLSBgYnJhY2tldHMuc2V0YCAtIENoYW5nZSB0aGUgY3VycmVudCByaW90IGJyYWNrZXRzXG4gICAqXG4gICAqIEBtb2R1bGVcbiAgICovXG5cbiAgLyogZ2xvYmFsIHJpb3QgKi9cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB2YXIgYnJhY2tldHMgPSAoZnVuY3Rpb24gKFVOREVGKSB7XG5cbiAgICB2YXJcbiAgICAgIFJFR0xPQiA9ICdnJyxcblxuICAgICAgUl9NTENPTU1TID0gL1xcL1xcKlteKl0qXFwqKyg/OlteKlxcL11bXipdKlxcKispKlxcLy9nLFxuXG4gICAgICBSX1NUUklOR1MgPSAvXCJbXlwiXFxcXF0qKD86XFxcXFtcXFNcXHNdW15cIlxcXFxdKikqXCJ8J1teJ1xcXFxdKig/OlxcXFxbXFxTXFxzXVteJ1xcXFxdKikqJ3xgW15gXFxcXF0qKD86XFxcXFtcXFNcXHNdW15gXFxcXF0qKSpgL2csXG5cbiAgICAgIFNfUUJMT0NLUyA9IFJfU1RSSU5HUy5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAvKD86XFxicmV0dXJuXFxzK3woPzpbJFxcd1xcKVxcXV18XFwrXFwrfC0tKVxccyooXFwvKSg/IVsqXFwvXSkpLy5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAvXFwvKD89W14qXFwvXSlbXltcXC9cXFxcXSooPzooPzpcXFsoPzpcXFxcLnxbXlxcXVxcXFxdKikqXFxdfFxcXFwuKVteW1xcL1xcXFxdKikqPyhbXjxdXFwvKVtnaW1dKi8uc291cmNlLFxuXG4gICAgICBVTlNVUFBPUlRFRCA9IFJlZ0V4cCgnW1xcXFwnICsgJ3gwMC1cXFxceDFGPD5hLXpBLVowLTlcXCdcIiw7XFxcXFxcXFxdJyksXG5cbiAgICAgIE5FRURfRVNDQVBFID0gLyg/PVtbXFxdKCkqKz8uXiR8XSkvZyxcblxuICAgICAgU19RQkxPQ0syID0gUl9TVFJJTkdTLnNvdXJjZSArICd8JyArIC8oXFwvKSg/IVsqXFwvXSkvLnNvdXJjZSxcblxuICAgICAgRklOREJSQUNFUyA9IHtcbiAgICAgICAgJygnOiBSZWdFeHAoJyhbKCldKXwnICAgKyBTX1FCTE9DSzIsIFJFR0xPQiksXG4gICAgICAgICdbJzogUmVnRXhwKCcoW1tcXFxcXV0pfCcgKyBTX1FCTE9DSzIsIFJFR0xPQiksXG4gICAgICAgICd7JzogUmVnRXhwKCcoW3t9XSl8JyAgICsgU19RQkxPQ0syLCBSRUdMT0IpXG4gICAgICB9LFxuXG4gICAgICBERUZBVUxUID0gJ3sgfSc7XG5cbiAgICB2YXIgX3BhaXJzID0gW1xuICAgICAgJ3snLCAnfScsXG4gICAgICAneycsICd9JyxcbiAgICAgIC97W159XSp9LyxcbiAgICAgIC9cXFxcKFt7fV0pL2csXG4gICAgICAvXFxcXCh7KXx7L2csXG4gICAgICBSZWdFeHAoJ1xcXFxcXFxcKH0pfChbWyh7XSl8KH0pfCcgKyBTX1FCTE9DSzIsIFJFR0xPQiksXG4gICAgICBERUZBVUxULFxuICAgICAgL15cXHMqe1xcXj9cXHMqKFskXFx3XSspKD86XFxzKixcXHMqKFxcUyspKT9cXHMraW5cXHMrKFxcUy4qKVxccyp9LyxcbiAgICAgIC8oXnxbXlxcXFxdKXs9W1xcU1xcc10qP30vXG4gICAgXTtcblxuICAgIHZhclxuICAgICAgY2FjaGVkQnJhY2tldHMgPSBVTkRFRixcbiAgICAgIF9yZWdleCxcbiAgICAgIF9jYWNoZSA9IFtdLFxuICAgICAgX3NldHRpbmdzO1xuXG4gICAgZnVuY3Rpb24gX2xvb3BiYWNrIChyZSkgeyByZXR1cm4gcmUgfVxuXG4gICAgZnVuY3Rpb24gX3Jld3JpdGUgKHJlLCBicCkge1xuICAgICAgaWYgKCFicCkgeyBicCA9IF9jYWNoZTsgfVxuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoXG4gICAgICAgIHJlLnNvdXJjZS5yZXBsYWNlKC97L2csIGJwWzJdKS5yZXBsYWNlKC99L2csIGJwWzNdKSwgcmUuZ2xvYmFsID8gUkVHTE9CIDogJydcbiAgICAgIClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY3JlYXRlIChwYWlyKSB7XG4gICAgICBpZiAocGFpciA9PT0gREVGQVVMVCkgeyByZXR1cm4gX3BhaXJzIH1cblxuICAgICAgdmFyIGFyciA9IHBhaXIuc3BsaXQoJyAnKTtcblxuICAgICAgaWYgKGFyci5sZW5ndGggIT09IDIgfHwgVU5TVVBQT1JURUQudGVzdChwYWlyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGJyYWNrZXRzIFwiJyArIHBhaXIgKyAnXCInKVxuICAgICAgfVxuICAgICAgYXJyID0gYXJyLmNvbmNhdChwYWlyLnJlcGxhY2UoTkVFRF9FU0NBUEUsICdcXFxcJykuc3BsaXQoJyAnKSk7XG5cbiAgICAgIGFycls0XSA9IF9yZXdyaXRlKGFyclsxXS5sZW5ndGggPiAxID8gL3tbXFxTXFxzXSo/fS8gOiBfcGFpcnNbNF0sIGFycik7XG4gICAgICBhcnJbNV0gPSBfcmV3cml0ZShwYWlyLmxlbmd0aCA+IDMgPyAvXFxcXCh7fH0pL2cgOiBfcGFpcnNbNV0sIGFycik7XG4gICAgICBhcnJbNl0gPSBfcmV3cml0ZShfcGFpcnNbNl0sIGFycik7XG4gICAgICBhcnJbN10gPSBSZWdFeHAoJ1xcXFxcXFxcKCcgKyBhcnJbM10gKyAnKXwoW1soe10pfCgnICsgYXJyWzNdICsgJyl8JyArIFNfUUJMT0NLMiwgUkVHTE9CKTtcbiAgICAgIGFycls4XSA9IHBhaXI7XG4gICAgICByZXR1cm4gYXJyXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2JyYWNrZXRzIChyZU9ySWR4KSB7XG4gICAgICByZXR1cm4gcmVPcklkeCBpbnN0YW5jZW9mIFJlZ0V4cCA/IF9yZWdleChyZU9ySWR4KSA6IF9jYWNoZVtyZU9ySWR4XVxuICAgIH1cblxuICAgIF9icmFja2V0cy5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0IChzdHIsIHRtcGwsIF9icCkge1xuICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHQ6IF9icCBpcyBmb3IgdGhlIGNvbXBpbGVyXG4gICAgICBpZiAoIV9icCkgeyBfYnAgPSBfY2FjaGU7IH1cblxuICAgICAgdmFyXG4gICAgICAgIHBhcnRzID0gW10sXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBpc2V4cHIsXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBwb3MsXG4gICAgICAgIHJlID0gX2JwWzZdO1xuXG4gICAgICB2YXIgcWJsb2NrcyA9IFtdO1xuICAgICAgdmFyIHByZXZTdHIgPSAnJztcbiAgICAgIHZhciBtYXJrLCBsYXN0SW5kZXg7XG5cbiAgICAgIGlzZXhwciA9IHN0YXJ0ID0gcmUubGFzdEluZGV4ID0gMDtcblxuICAgICAgd2hpbGUgKChtYXRjaCA9IHJlLmV4ZWMoc3RyKSkpIHtcblxuICAgICAgICBsYXN0SW5kZXggPSByZS5sYXN0SW5kZXg7XG4gICAgICAgIHBvcyA9IG1hdGNoLmluZGV4O1xuXG4gICAgICAgIGlmIChpc2V4cHIpIHtcblxuICAgICAgICAgIGlmIChtYXRjaFsyXSkge1xuXG4gICAgICAgICAgICB2YXIgY2ggPSBtYXRjaFsyXTtcbiAgICAgICAgICAgIHZhciByZWNoID0gRklOREJSQUNFU1tjaF07XG4gICAgICAgICAgICB2YXIgaXggPSAxO1xuXG4gICAgICAgICAgICByZWNoLmxhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICAgIHdoaWxlICgobWF0Y2ggPSByZWNoLmV4ZWMoc3RyKSkpIHtcbiAgICAgICAgICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoWzFdID09PSBjaCkgeyArK2l4OyB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIS0taXgpIHsgYnJlYWsgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlY2gubGFzdEluZGV4ID0gcHVzaFFCbG9jayhtYXRjaC5pbmRleCwgcmVjaC5sYXN0SW5kZXgsIG1hdGNoWzJdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmUubGFzdEluZGV4ID0gaXggPyBzdHIubGVuZ3RoIDogcmVjaC5sYXN0SW5kZXg7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghbWF0Y2hbM10pIHtcbiAgICAgICAgICAgIHJlLmxhc3RJbmRleCA9IHB1c2hRQmxvY2socG9zLCBsYXN0SW5kZXgsIG1hdGNoWzRdKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtYXRjaFsxXSkge1xuICAgICAgICAgIHVuZXNjYXBlU3RyKHN0ci5zbGljZShzdGFydCwgcG9zKSk7XG4gICAgICAgICAgc3RhcnQgPSByZS5sYXN0SW5kZXg7XG4gICAgICAgICAgcmUgPSBfYnBbNiArIChpc2V4cHIgXj0gMSldO1xuICAgICAgICAgIHJlLmxhc3RJbmRleCA9IHN0YXJ0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHIgJiYgc3RhcnQgPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgIHVuZXNjYXBlU3RyKHN0ci5zbGljZShzdGFydCkpO1xuICAgICAgfVxuXG4gICAgICBwYXJ0cy5xYmxvY2tzID0gcWJsb2NrcztcblxuICAgICAgcmV0dXJuIHBhcnRzXG5cbiAgICAgIGZ1bmN0aW9uIHVuZXNjYXBlU3RyIChzKSB7XG4gICAgICAgIGlmIChwcmV2U3RyKSB7XG4gICAgICAgICAgcyA9IHByZXZTdHIgKyBzO1xuICAgICAgICAgIHByZXZTdHIgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodG1wbCB8fCBpc2V4cHIpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHMgJiYgcy5yZXBsYWNlKF9icFs1XSwgJyQxJykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnRzLnB1c2gocyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcHVzaFFCbG9jayhfcG9zLCBfbGFzdEluZGV4LCBzbGFzaCkgeyAvL2VzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgaWYgKHNsYXNoKSB7XG4gICAgICAgICAgX2xhc3RJbmRleCA9IHNraXBSZWdleChzdHIsIF9wb3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRtcGwgJiYgX2xhc3RJbmRleCA+IF9wb3MgKyAyKSB7XG4gICAgICAgICAgbWFyayA9ICdcXHUyMDU3JyArIHFibG9ja3MubGVuZ3RoICsgJ34nO1xuICAgICAgICAgIHFibG9ja3MucHVzaChzdHIuc2xpY2UoX3BvcywgX2xhc3RJbmRleCkpO1xuICAgICAgICAgIHByZXZTdHIgKz0gc3RyLnNsaWNlKHN0YXJ0LCBfcG9zKSArIG1hcms7XG4gICAgICAgICAgc3RhcnQgPSBfbGFzdEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfbGFzdEluZGV4XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9icmFja2V0cy5oYXNFeHByID0gZnVuY3Rpb24gaGFzRXhwciAoc3RyKSB7XG4gICAgICByZXR1cm4gX2NhY2hlWzRdLnRlc3Qoc3RyKVxuICAgIH07XG5cbiAgICBfYnJhY2tldHMubG9vcEtleXMgPSBmdW5jdGlvbiBsb29wS2V5cyAoZXhwcikge1xuICAgICAgdmFyIG0gPSBleHByLm1hdGNoKF9jYWNoZVs5XSk7XG5cbiAgICAgIHJldHVybiBtXG4gICAgICAgID8geyBrZXk6IG1bMV0sIHBvczogbVsyXSwgdmFsOiBfY2FjaGVbMF0gKyBtWzNdLnRyaW0oKSArIF9jYWNoZVsxXSB9XG4gICAgICAgIDogeyB2YWw6IGV4cHIudHJpbSgpIH1cbiAgICB9O1xuXG4gICAgX2JyYWNrZXRzLmFycmF5ID0gZnVuY3Rpb24gYXJyYXkgKHBhaXIpIHtcbiAgICAgIHJldHVybiBwYWlyID8gX2NyZWF0ZShwYWlyKSA6IF9jYWNoZVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfcmVzZXQgKHBhaXIpIHtcbiAgICAgIGlmICgocGFpciB8fCAocGFpciA9IERFRkFVTFQpKSAhPT0gX2NhY2hlWzhdKSB7XG4gICAgICAgIF9jYWNoZSA9IF9jcmVhdGUocGFpcik7XG4gICAgICAgIF9yZWdleCA9IHBhaXIgPT09IERFRkFVTFQgPyBfbG9vcGJhY2sgOiBfcmV3cml0ZTtcbiAgICAgICAgX2NhY2hlWzldID0gX3JlZ2V4KF9wYWlyc1s5XSk7XG4gICAgICB9XG4gICAgICBjYWNoZWRCcmFja2V0cyA9IHBhaXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3NldFNldHRpbmdzIChvKSB7XG4gICAgICB2YXIgYjtcblxuICAgICAgbyA9IG8gfHwge307XG4gICAgICBiID0gby5icmFja2V0cztcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCAnYnJhY2tldHMnLCB7XG4gICAgICAgIHNldDogX3Jlc2V0LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhY2hlZEJyYWNrZXRzIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgX3NldHRpbmdzID0gbztcbiAgICAgIF9yZXNldChiKTtcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2JyYWNrZXRzLCAnc2V0dGluZ3MnLCB7XG4gICAgICBzZXQ6IF9zZXRTZXR0aW5ncyxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX3NldHRpbmdzIH1cbiAgICB9KTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBpbiB0aGUgYnJvd3NlciByaW90IGlzIGFsd2F5cyBpbiB0aGUgc2NvcGUgKi9cbiAgICBfYnJhY2tldHMuc2V0dGluZ3MgPSB0eXBlb2YgcmlvdCAhPT0gJ3VuZGVmaW5lZCcgJiYgcmlvdC5zZXR0aW5ncyB8fCB7fTtcbiAgICBfYnJhY2tldHMuc2V0ID0gX3Jlc2V0O1xuICAgIF9icmFja2V0cy5za2lwUmVnZXggPSBza2lwUmVnZXg7XG5cbiAgICBfYnJhY2tldHMuUl9TVFJJTkdTID0gUl9TVFJJTkdTO1xuICAgIF9icmFja2V0cy5SX01MQ09NTVMgPSBSX01MQ09NTVM7XG4gICAgX2JyYWNrZXRzLlNfUUJMT0NLUyA9IFNfUUJMT0NLUztcbiAgICBfYnJhY2tldHMuU19RQkxPQ0syID0gU19RQkxPQ0syO1xuXG4gICAgcmV0dXJuIF9icmFja2V0c1xuXG4gIH0pKCk7XG5cbiAgLyoqXG4gICAqIEBtb2R1bGUgdG1wbFxuICAgKlxuICAgKiB0bXBsICAgICAgICAgIC0gUm9vdCBmdW5jdGlvbiwgcmV0dXJucyB0aGUgdGVtcGxhdGUgdmFsdWUsIHJlbmRlciB3aXRoIGRhdGFcbiAgICogdG1wbC5oYXNFeHByICAtIFRlc3QgdGhlIGV4aXN0ZW5jZSBvZiBhIGV4cHJlc3Npb24gaW5zaWRlIGEgc3RyaW5nXG4gICAqIHRtcGwubG9vcEtleXMgLSBHZXQgdGhlIGtleXMgZm9yIGFuICdlYWNoJyBsb29wICh1c2VkIGJ5IGBfZWFjaGApXG4gICAqL1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHZhciB0bXBsID0gKGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBfY2FjaGUgPSB7fTtcblxuICAgIGZ1bmN0aW9uIF90bXBsIChzdHIsIGRhdGEpIHtcbiAgICAgIGlmICghc3RyKSB7IHJldHVybiBzdHIgfVxuXG4gICAgICByZXR1cm4gKF9jYWNoZVtzdHJdIHx8IChfY2FjaGVbc3RyXSA9IF9jcmVhdGUoc3RyKSkpLmNhbGwoXG4gICAgICAgIGRhdGEsIF9sb2dFcnIuYmluZCh7XG4gICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICB0bXBsOiBzdHJcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9XG5cbiAgICBfdG1wbC5oYXNFeHByID0gYnJhY2tldHMuaGFzRXhwcjtcblxuICAgIF90bXBsLmxvb3BLZXlzID0gYnJhY2tldHMubG9vcEtleXM7XG5cbiAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgIF90bXBsLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7IF9jYWNoZSA9IHt9OyB9O1xuXG4gICAgX3RtcGwuZXJyb3JIYW5kbGVyID0gbnVsbDtcblxuICAgIGZ1bmN0aW9uIF9sb2dFcnIgKGVyciwgY3R4KSB7XG5cbiAgICAgIGVyci5yaW90RGF0YSA9IHtcbiAgICAgICAgdGFnTmFtZTogY3R4ICYmIGN0eC5fXyAmJiBjdHguX18udGFnTmFtZSxcbiAgICAgICAgX3Jpb3RfaWQ6IGN0eCAmJiBjdHguX3Jpb3RfaWQgIC8vZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgICAgIH07XG5cbiAgICAgIGlmIChfdG1wbC5lcnJvckhhbmRsZXIpIHsgX3RtcGwuZXJyb3JIYW5kbGVyKGVycik7IH1cbiAgICAgIGVsc2UgaWYgKFxuICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbidcbiAgICAgICkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVyci5tZXNzYWdlKTtcbiAgICAgICAgY29uc29sZS5sb2coJzwlcz4gJXMnLCBlcnIucmlvdERhdGEudGFnTmFtZSB8fCAnVW5rbm93biB0YWcnLCB0aGlzLnRtcGwpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMuZGF0YSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY3JlYXRlIChzdHIpIHtcbiAgICAgIHZhciBleHByID0gX2dldFRtcGwoc3RyKTtcblxuICAgICAgaWYgKGV4cHIuc2xpY2UoMCwgMTEpICE9PSAndHJ5e3JldHVybiAnKSB7IGV4cHIgPSAncmV0dXJuICcgKyBleHByOyB9XG5cbiAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ0UnLCBleHByICsgJzsnKSAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy1mdW5jXG4gICAgfVxuXG4gICAgdmFyIFJFX0RRVU9URSA9IC9cXHUyMDU3L2c7XG4gICAgdmFyIFJFX1FCTUFSSyA9IC9cXHUyMDU3KFxcZCspfi9nO1xuXG4gICAgZnVuY3Rpb24gX2dldFRtcGwgKHN0cikge1xuICAgICAgdmFyIHBhcnRzID0gYnJhY2tldHMuc3BsaXQoc3RyLnJlcGxhY2UoUkVfRFFVT1RFLCAnXCInKSwgMSk7XG4gICAgICB2YXIgcXN0ciA9IHBhcnRzLnFibG9ja3M7XG4gICAgICB2YXIgZXhwcjtcblxuICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDIgfHwgcGFydHNbMF0pIHtcbiAgICAgICAgdmFyIGksIGosIGxpc3QgPSBbXTtcblxuICAgICAgICBmb3IgKGkgPSBqID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG5cbiAgICAgICAgICBleHByID0gcGFydHNbaV07XG5cbiAgICAgICAgICBpZiAoZXhwciAmJiAoZXhwciA9IGkgJiAxXG5cbiAgICAgICAgICAgICAgPyBfcGFyc2VFeHByKGV4cHIsIDEsIHFzdHIpXG5cbiAgICAgICAgICAgICAgOiAnXCInICsgZXhwclxuICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJylcbiAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHJcXG4/fFxcbi9nLCAnXFxcXG4nKVxuICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKSArXG4gICAgICAgICAgICAgICAgJ1wiJ1xuXG4gICAgICAgICAgICApKSB7IGxpc3RbaisrXSA9IGV4cHI7IH1cblxuICAgICAgICB9XG5cbiAgICAgICAgZXhwciA9IGogPCAyID8gbGlzdFswXVxuICAgICAgICAgICAgIDogJ1snICsgbGlzdC5qb2luKCcsJykgKyAnXS5qb2luKFwiXCIpJztcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBleHByID0gX3BhcnNlRXhwcihwYXJ0c1sxXSwgMCwgcXN0cik7XG4gICAgICB9XG5cbiAgICAgIGlmIChxc3RyLmxlbmd0aCkge1xuICAgICAgICBleHByID0gZXhwci5yZXBsYWNlKFJFX1FCTUFSSywgZnVuY3Rpb24gKF8sIHBvcykge1xuICAgICAgICAgIHJldHVybiBxc3RyW3Bvc11cbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHIvZywgJ1xcXFxyJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXG4vZywgJ1xcXFxuJylcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhwclxuICAgIH1cblxuICAgIHZhciBSRV9DU05BTUUgPSAvXig/OigtP1tfQS1aYS16XFx4QTAtXFx4RkZdWy1cXHdcXHhBMC1cXHhGRl0qKXxcXHUyMDU3KFxcZCspfik6LztcbiAgICB2YXJcbiAgICAgIFJFX0JSRU5EID0ge1xuICAgICAgICAnKCc6IC9bKCldL2csXG4gICAgICAgICdbJzogL1tbXFxdXS9nLFxuICAgICAgICAneyc6IC9be31dL2dcbiAgICAgIH07XG5cbiAgICBmdW5jdGlvbiBfcGFyc2VFeHByIChleHByLCBhc1RleHQsIHFzdHIpIHtcblxuICAgICAgZXhwciA9IGV4cHJcbiAgICAgICAgLnJlcGxhY2UoL1xccysvZywgJyAnKS50cmltKClcbiAgICAgICAgLnJlcGxhY2UoL1xcID8oW1tcXCh7fSw/XFwuOl0pXFwgPy9nLCAnJDEnKTtcblxuICAgICAgaWYgKGV4cHIpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgbGlzdCA9IFtdLFxuICAgICAgICAgIGNudCA9IDAsXG4gICAgICAgICAgbWF0Y2g7XG5cbiAgICAgICAgd2hpbGUgKGV4cHIgJiZcbiAgICAgICAgICAgICAgKG1hdGNoID0gZXhwci5tYXRjaChSRV9DU05BTUUpKSAmJlxuICAgICAgICAgICAgICAhbWF0Y2guaW5kZXhcbiAgICAgICAgICApIHtcbiAgICAgICAgICB2YXJcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGpzYixcbiAgICAgICAgICAgIHJlID0gLyx8KFtbeyhdKXwkL2c7XG5cbiAgICAgICAgICBleHByID0gUmVnRXhwLnJpZ2h0Q29udGV4dDtcbiAgICAgICAgICBrZXkgID0gbWF0Y2hbMl0gPyBxc3RyW21hdGNoWzJdXS5zbGljZSgxLCAtMSkudHJpbSgpLnJlcGxhY2UoL1xccysvZywgJyAnKSA6IG1hdGNoWzFdO1xuXG4gICAgICAgICAgd2hpbGUgKGpzYiA9IChtYXRjaCA9IHJlLmV4ZWMoZXhwcikpWzFdKSB7IHNraXBCcmFjZXMoanNiLCByZSk7IH1cblxuICAgICAgICAgIGpzYiAgPSBleHByLnNsaWNlKDAsIG1hdGNoLmluZGV4KTtcbiAgICAgICAgICBleHByID0gUmVnRXhwLnJpZ2h0Q29udGV4dDtcblxuICAgICAgICAgIGxpc3RbY250KytdID0gX3dyYXBFeHByKGpzYiwgMSwga2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cHIgPSAhY250ID8gX3dyYXBFeHByKGV4cHIsIGFzVGV4dClcbiAgICAgICAgICAgICA6IGNudCA+IDEgPyAnWycgKyBsaXN0LmpvaW4oJywnKSArICddLmpvaW4oXCIgXCIpLnRyaW0oKScgOiBsaXN0WzBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV4cHJcblxuICAgICAgZnVuY3Rpb24gc2tpcEJyYWNlcyAoY2gsIHJlKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgIG1tLFxuICAgICAgICAgIGx2ID0gMSxcbiAgICAgICAgICBpciA9IFJFX0JSRU5EW2NoXTtcblxuICAgICAgICBpci5sYXN0SW5kZXggPSByZS5sYXN0SW5kZXg7XG4gICAgICAgIHdoaWxlIChtbSA9IGlyLmV4ZWMoZXhwcikpIHtcbiAgICAgICAgICBpZiAobW1bMF0gPT09IGNoKSB7ICsrbHY7IH1cbiAgICAgICAgICBlbHNlIGlmICghLS1sdikgeyBicmVhayB9XG4gICAgICAgIH1cbiAgICAgICAgcmUubGFzdEluZGV4ID0gbHYgPyBleHByLmxlbmd0aCA6IGlyLmxhc3RJbmRleDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogbm90IGJvdGhcbiAgICB2YXIgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgICAgIEpTX0NPTlRFWFQgPSAnXCJpbiB0aGlzP3RoaXM6JyArICh0eXBlb2Ygd2luZG93ICE9PSAnb2JqZWN0JyA/ICdnbG9iYWwnIDogJ3dpbmRvdycpICsgJykuJyxcbiAgICAgIEpTX1ZBUk5BTUUgPSAvWyx7XVtcXCRcXHddKyg/PTopfCheICp8W14kXFx3XFwue10pKD8hKD86dHlwZW9mfHRydWV8ZmFsc2V8bnVsbHx1bmRlZmluZWR8aW58aW5zdGFuY2VvZnxpcyg/OkZpbml0ZXxOYU4pfHZvaWR8TmFOfG5ld3xEYXRlfFJlZ0V4cHxNYXRoKSg/IVskXFx3XSkpKFskX0EtWmEtel1bJFxcd10qKS9nLFxuICAgICAgSlNfTk9QUk9QUyA9IC9eKD89KFxcLlskXFx3XSspKVxcMSg/OlteLlsoXXwkKS87XG5cbiAgICBmdW5jdGlvbiBfd3JhcEV4cHIgKGV4cHIsIGFzVGV4dCwga2V5KSB7XG4gICAgICB2YXIgdGI7XG5cbiAgICAgIGV4cHIgPSBleHByLnJlcGxhY2UoSlNfVkFSTkFNRSwgZnVuY3Rpb24gKG1hdGNoLCBwLCBtdmFyLCBwb3MsIHMpIHtcbiAgICAgICAgaWYgKG12YXIpIHtcbiAgICAgICAgICBwb3MgPSB0YiA/IDAgOiBwb3MgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgICAgICBpZiAobXZhciAhPT0gJ3RoaXMnICYmIG12YXIgIT09ICdnbG9iYWwnICYmIG12YXIgIT09ICd3aW5kb3cnKSB7XG4gICAgICAgICAgICBtYXRjaCA9IHAgKyAnKFwiJyArIG12YXIgKyBKU19DT05URVhUICsgbXZhcjtcbiAgICAgICAgICAgIGlmIChwb3MpIHsgdGIgPSAocyA9IHNbcG9zXSkgPT09ICcuJyB8fCBzID09PSAnKCcgfHwgcyA9PT0gJ1snOyB9XG4gICAgICAgICAgfSBlbHNlIGlmIChwb3MpIHtcbiAgICAgICAgICAgIHRiID0gIUpTX05PUFJPUFMudGVzdChzLnNsaWNlKHBvcykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF0Y2hcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGIpIHtcbiAgICAgICAgZXhwciA9ICd0cnl7cmV0dXJuICcgKyBleHByICsgJ31jYXRjaChlKXtFKGUsdGhpcyl9JztcbiAgICAgIH1cblxuICAgICAgaWYgKGtleSkge1xuXG4gICAgICAgIGV4cHIgPSAodGJcbiAgICAgICAgICAgID8gJ2Z1bmN0aW9uKCl7JyArIGV4cHIgKyAnfS5jYWxsKHRoaXMpJyA6ICcoJyArIGV4cHIgKyAnKSdcbiAgICAgICAgICApICsgJz9cIicgKyBrZXkgKyAnXCI6XCJcIic7XG5cbiAgICAgIH0gZWxzZSBpZiAoYXNUZXh0KSB7XG5cbiAgICAgICAgZXhwciA9ICdmdW5jdGlvbih2KXsnICsgKHRiXG4gICAgICAgICAgICA/IGV4cHIucmVwbGFjZSgncmV0dXJuICcsICd2PScpIDogJ3Y9KCcgKyBleHByICsgJyknXG4gICAgICAgICAgKSArICc7cmV0dXJuIHZ8fHY9PT0wP3Y6XCJcIn0uY2FsbCh0aGlzKSc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHByXG4gICAgfVxuXG4gICAgX3RtcGwudmVyc2lvbiA9IGJyYWNrZXRzLnZlcnNpb24gPSAndjMuMC44JztcblxuICAgIHJldHVybiBfdG1wbFxuXG4gIH0pKCk7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgdmFyIG9ic2VydmFibGUgPSBmdW5jdGlvbihlbCkge1xuXG4gICAgLyoqXG4gICAgICogRXh0ZW5kIHRoZSBvcmlnaW5hbCBvYmplY3Qgb3IgY3JlYXRlIGEgbmV3IGVtcHR5IG9uZVxuICAgICAqIEB0eXBlIHsgT2JqZWN0IH1cbiAgICAgKi9cblxuICAgIGVsID0gZWwgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBQcml2YXRlIHZhcmlhYmxlc1xuICAgICAqL1xuICAgIHZhciBjYWxsYmFja3MgPSB7fSxcbiAgICAgIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gICAgLyoqXG4gICAgICogUHVibGljIEFwaVxuICAgICAqL1xuXG4gICAgLy8gZXh0ZW5kIHRoZSBlbCBvYmplY3QgYWRkaW5nIHRoZSBvYnNlcnZhYmxlIG1ldGhvZHNcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlbCwge1xuICAgICAgLyoqXG4gICAgICAgKiBMaXN0ZW4gdG8gdGhlIGdpdmVuIGBldmVudGAgYW5kc1xuICAgICAgICogZXhlY3V0ZSB0aGUgYGNhbGxiYWNrYCBlYWNoIHRpbWUgYW4gZXZlbnQgaXMgdHJpZ2dlcmVkLlxuICAgICAgICogQHBhcmFtICB7IFN0cmluZyB9IGV2ZW50IC0gZXZlbnQgaWRcbiAgICAgICAqIEBwYXJhbSAgeyBGdW5jdGlvbiB9IGZuIC0gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAqIEByZXR1cm5zIHsgT2JqZWN0IH0gZWxcbiAgICAgICAqL1xuICAgICAgb246IHtcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKGV2ZW50LCBmbikge1xuICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHsgKGNhbGxiYWNrc1tldmVudF0gPSBjYWxsYmFja3NbZXZlbnRdIHx8IFtdKS5wdXNoKGZuKTsgfVxuICAgICAgICAgIHJldHVybiBlbFxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZXMgdGhlIGdpdmVuIGBldmVudGAgbGlzdGVuZXJzXG4gICAgICAgKiBAcGFyYW0gICB7IFN0cmluZyB9IGV2ZW50IC0gZXZlbnQgaWRcbiAgICAgICAqIEBwYXJhbSAgIHsgRnVuY3Rpb24gfSBmbiAtIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgKiBAcmV0dXJucyB7IE9iamVjdCB9IGVsXG4gICAgICAgKi9cbiAgICAgIG9mZjoge1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oZXZlbnQsIGZuKSB7XG4gICAgICAgICAgaWYgKGV2ZW50ID09ICcqJyAmJiAhZm4pIHsgY2FsbGJhY2tzID0ge307IH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICB2YXIgYXJyID0gY2FsbGJhY2tzW2V2ZW50XTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGNiOyBjYiA9IGFyciAmJiBhcnJbaV07ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChjYiA9PSBmbikgeyBhcnIuc3BsaWNlKGktLSwgMSk7IH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHsgZGVsZXRlIGNhbGxiYWNrc1tldmVudF07IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGVsXG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogTGlzdGVuIHRvIHRoZSBnaXZlbiBgZXZlbnRgIGFuZFxuICAgICAgICogZXhlY3V0ZSB0aGUgYGNhbGxiYWNrYCBhdCBtb3N0IG9uY2VcbiAgICAgICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gZXZlbnQgLSBldmVudCBpZFxuICAgICAgICogQHBhcmFtICAgeyBGdW5jdGlvbiB9IGZuIC0gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAqIEByZXR1cm5zIHsgT2JqZWN0IH0gZWxcbiAgICAgICAqL1xuICAgICAgb25lOiB7XG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbihldmVudCwgZm4pIHtcbiAgICAgICAgICBmdW5jdGlvbiBvbigpIHtcbiAgICAgICAgICAgIGVsLm9mZihldmVudCwgb24pO1xuICAgICAgICAgICAgZm4uYXBwbHkoZWwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBlbC5vbihldmVudCwgb24pXG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogRXhlY3V0ZSBhbGwgY2FsbGJhY2sgZnVuY3Rpb25zIHRoYXQgbGlzdGVuIHRvXG4gICAgICAgKiB0aGUgZ2l2ZW4gYGV2ZW50YFxuICAgICAgICogQHBhcmFtICAgeyBTdHJpbmcgfSBldmVudCAtIGV2ZW50IGlkXG4gICAgICAgKiBAcmV0dXJucyB7IE9iamVjdCB9IGVsXG4gICAgICAgKi9cbiAgICAgIHRyaWdnZXI6IHtcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG5cbiAgICAgICAgICAvLyBnZXR0aW5nIHRoZSBhcmd1bWVudHNcbiAgICAgICAgICB2YXIgYXJnbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICBhcmdzID0gbmV3IEFycmF5KGFyZ2xlbiksXG4gICAgICAgICAgICBmbnMsXG4gICAgICAgICAgICBmbixcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJnbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHMkMVtpICsgMV07IC8vIHNraXAgZmlyc3QgYXJndW1lbnRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmbnMgPSBzbGljZS5jYWxsKGNhbGxiYWNrc1tldmVudF0gfHwgW10sIDApO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgZm4gPSBmbnNbaV07ICsraSkge1xuICAgICAgICAgICAgZm4uYXBwbHkoZWwsIGFyZ3MpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjYWxsYmFja3NbJyonXSAmJiBldmVudCAhPSAnKicpXG4gICAgICAgICAgICB7IGVsLnRyaWdnZXIuYXBwbHkoZWwsIFsnKicsIGV2ZW50XS5jb25jYXQoYXJncykpOyB9XG5cbiAgICAgICAgICByZXR1cm4gZWxcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGVsXG5cbiAgfTtcblxuICAvKipcbiAgICogU2hvcnQgYWxpYXMgZm9yIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JcbiAgICovXG4gIGZ1bmN0aW9uIGdldFByb3BEZXNjcmlwdG9yIChvLCBrKSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobywgaylcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBwYXNzZWQgYXJndW1lbnQgaXMgdW5kZWZpbmVkXG4gICAqIEBwYXJhbSAgIHsgKiB9IHZhbHVlIC1cbiAgICogQHJldHVybnMgeyBCb29sZWFuIH0gLVxuICAgKi9cbiAgZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBUX1VOREVGXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciBvYmplY3QncyBwcm9wZXJ0eSBjb3VsZCBiZSBvdmVycmlkZGVuXG4gICAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gIG9iaiAtIHNvdXJjZSBvYmplY3RcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSAga2V5IC0gb2JqZWN0IHByb3BlcnR5XG4gICAqIEByZXR1cm5zIHsgQm9vbGVhbiB9IHRydWUgaWYgd3JpdGFibGVcbiAgICovXG4gIGZ1bmN0aW9uIGlzV3JpdGFibGUob2JqLCBrZXkpIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IGdldFByb3BEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgICByZXR1cm4gaXNVbmRlZmluZWQob2JqW2tleV0pIHx8IGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci53cml0YWJsZVxuICB9XG5cbiAgLyoqXG4gICAqIEV4dGVuZCBhbnkgb2JqZWN0IHdpdGggb3RoZXIgcHJvcGVydGllc1xuICAgKiBAcGFyYW0gICB7IE9iamVjdCB9IHNyYyAtIHNvdXJjZSBvYmplY3RcbiAgICogQHJldHVybnMgeyBPYmplY3QgfSB0aGUgcmVzdWx0aW5nIGV4dGVuZGVkIG9iamVjdFxuICAgKlxuICAgKiB2YXIgb2JqID0geyBmb286ICdiYXonIH1cbiAgICogZXh0ZW5kKG9iaiwge2JhcjogJ2JhcicsIGZvbzogJ2Jhcid9KVxuICAgKiBjb25zb2xlLmxvZyhvYmopID0+IHtiYXI6ICdiYXInLCBmb286ICdiYXInfVxuICAgKlxuICAgKi9cbiAgZnVuY3Rpb24gZXh0ZW5kKHNyYykge1xuICAgIHZhciBvYmo7XG4gICAgdmFyIGkgPSAxO1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBsID0gYXJncy5sZW5ndGg7XG5cbiAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKG9iaiA9IGFyZ3NbaV0pIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgcHJvcGVydHkgb2YgdGhlIHNvdXJjZSBvYmplY3QgY291bGQgYmUgb3ZlcnJpZGRlblxuICAgICAgICAgIGlmIChpc1dyaXRhYmxlKHNyYywga2V5KSlcbiAgICAgICAgICAgIHsgc3JjW2tleV0gPSBvYmpba2V5XTsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzcmNcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGlhcyBmb3IgT2JqZWN0LmNyZWF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlKHNyYykge1xuICAgIHJldHVybiBPYmplY3QuY3JlYXRlKHNyYylcbiAgfVxuXG4gIHZhciBzZXR0aW5ncyA9IGV4dGVuZChjcmVhdGUoYnJhY2tldHMuc2V0dGluZ3MpLCB7XG4gICAgc2tpcEFub255bW91c1RhZ3M6IHRydWUsXG4gICAgLy8gaGFuZGxlIHRoZSBhdXRvIHVwZGF0ZXMgb24gYW55IERPTSBldmVudFxuICAgIGF1dG9VcGRhdGU6IHRydWVcbiAgfSlcblxuICAvKipcbiAgICogU2hvcnRlciBhbmQgZmFzdCB3YXkgdG8gc2VsZWN0IG11bHRpcGxlIG5vZGVzIGluIHRoZSBET01cbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSBzZWxlY3RvciAtIERPTSBzZWxlY3RvclxuICAgKiBAcGFyYW0gICB7IE9iamVjdCB9IGN0eCAtIERPTSBub2RlIHdoZXJlIHRoZSB0YXJnZXRzIG9mIG91ciBzZWFyY2ggd2lsbCBpcyBsb2NhdGVkXG4gICAqIEByZXR1cm5zIHsgT2JqZWN0IH0gZG9tIG5vZGVzIGZvdW5kXG4gICAqL1xuICBmdW5jdGlvbiAkJChzZWxlY3RvciwgY3R4KSB7XG4gICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwoKGN0eCB8fCBkb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgZG9jdW1lbnQgdGV4dCBub2RlXG4gICAqIEByZXR1cm5zIHsgT2JqZWN0IH0gY3JlYXRlIGEgdGV4dCBub2RlIHRvIHVzZSBhcyBwbGFjZWhvbGRlclxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlRE9NUGxhY2Vob2xkZXIoKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKVxuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZSB0aGUgdmlzaWJpbGl0eSBvZiBhbnkgRE9NIG5vZGVcbiAgICogQHBhcmFtICAgeyBPYmplY3QgfSAgZG9tIC0gRE9NIG5vZGUgd2Ugd2FudCB0byBoaWRlXG4gICAqIEBwYXJhbSAgIHsgQm9vbGVhbiB9IHNob3cgLSBkbyB3ZSB3YW50IHRvIHNob3cgaXQ/XG4gICAqL1xuXG4gIGZ1bmN0aW9uIHRvZ2dsZVZpc2liaWxpdHkoZG9tLCBzaG93KSB7XG4gICAgZG9tLnN0eWxlLmRpc3BsYXkgPSBzaG93ID8gJycgOiAnbm9uZSc7XG4gICAgZG9tLmhpZGRlbiA9IHNob3cgPyBmYWxzZSA6IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBvZiBhbnkgRE9NIGF0dHJpYnV0ZSBvbiBhIG5vZGVcbiAgICogQHBhcmFtICAgeyBPYmplY3QgfSBkb20gLSBET00gbm9kZSB3ZSB3YW50IHRvIHBhcnNlXG4gICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gbmFtZSAtIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB3ZSB3YW50IHRvIGdldFxuICAgKiBAcmV0dXJucyB7IFN0cmluZyB8IHVuZGVmaW5lZCB9IG5hbWUgb2YgdGhlIG5vZGUgYXR0cmlidXRlIHdoZXRoZXIgaXQgZXhpc3RzXG4gICAqL1xuICBmdW5jdGlvbiBnZXRBdHRyaWJ1dGUoZG9tLCBuYW1lKSB7XG4gICAgcmV0dXJuIGRvbS5nZXRBdHRyaWJ1dGUobmFtZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW55IERPTSBhdHRyaWJ1dGUgZnJvbSBhIG5vZGVcbiAgICogQHBhcmFtICAgeyBPYmplY3QgfSBkb20gLSBET00gbm9kZSB3ZSB3YW50IHRvIHVwZGF0ZVxuICAgKiBAcGFyYW0gICB7IFN0cmluZyB9IG5hbWUgLSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB3ZSB3YW50IHRvIHJlbW92ZVxuICAgKi9cbiAgZnVuY3Rpb24gcmVtb3ZlQXR0cmlidXRlKGRvbSwgbmFtZSkge1xuICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBpbm5lciBodG1sIG9mIGFueSBET00gbm9kZSBTVkdzIGluY2x1ZGVkXG4gICAqIEBwYXJhbSB7IE9iamVjdCB9IGNvbnRhaW5lciAtIERPTSBub2RlIHdoZXJlIHdlJ2xsIGluamVjdCBuZXcgaHRtbFxuICAgKiBAcGFyYW0geyBTdHJpbmcgfSBodG1sIC0gaHRtbCB0byBpbmplY3RcbiAgICogQHBhcmFtIHsgQm9vbGVhbiB9IGlzU3ZnIC0gc3ZnIHRhZ3Mgc2hvdWxkIGJlIHRyZWF0ZWQgYSBiaXQgZGlmZmVyZW50bHlcbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGZ1bmN0aW9uIHNldElubmVySFRNTChjb250YWluZXIsIGh0bWwsIGlzU3ZnKSB7XG4gICAgLy8gaW5uZXJIVE1MIGlzIG5vdCBzdXBwb3J0ZWQgb24gc3ZnIHRhZ3Mgc28gd2UgbmVldCB0byB0cmVhdCB0aGVtIGRpZmZlcmVudGx5XG4gICAgaWYgKGlzU3ZnKSB7XG4gICAgICB2YXIgbm9kZSA9IGNvbnRhaW5lci5vd25lckRvY3VtZW50LmltcG9ydE5vZGUoXG4gICAgICAgIG5ldyBET01QYXJzZXIoKVxuICAgICAgICAgIC5wYXJzZUZyb21TdHJpbmcoKFwiPHN2ZyB4bWxucz1cXFwiXCIgKyBTVkdfTlMgKyBcIlxcXCI+XCIgKyBodG1sICsgXCI8L3N2Zz5cIiksICdhcHBsaWNhdGlvbi94bWwnKVxuICAgICAgICAgIC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICAgIHRydWVcbiAgICAgICk7XG5cbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9IGh0bWw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1pbmltaXplIHJpc2s6IG9ubHkgemVybyBvciBvbmUgX3NwYWNlXyBiZXR3ZWVuIGF0dHIgJiB2YWx1ZVxuICAgKiBAcGFyYW0gICB7IFN0cmluZyB9ICAgaHRtbCAtIGh0bWwgc3RyaW5nIHdlIHdhbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtICAgeyBGdW5jdGlvbiB9IGZuIC0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gYXBwbHkgb24gYW55IGF0dHJpYnV0ZSBmb3VuZFxuICAgKi9cbiAgZnVuY3Rpb24gd2Fsa0F0dHJpYnV0ZXMoaHRtbCwgZm4pIHtcbiAgICBpZiAoIWh0bWwpIHsgcmV0dXJuIH1cbiAgICB2YXIgbTtcbiAgICB3aGlsZSAobSA9IFJFX0hUTUxfQVRUUlMuZXhlYyhodG1sKSlcbiAgICAgIHsgZm4obVsxXS50b0xvd2VyQ2FzZSgpLCBtWzJdIHx8IG1bM10gfHwgbVs0XSk7IH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBkb2N1bWVudCBmcmFnbWVudFxuICAgKiBAcmV0dXJucyB7IE9iamVjdCB9IGRvY3VtZW50IGZyYWdtZW50XG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVGcmFnbWVudCgpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0IHNhZmVseSBhIHRhZyB0byBmaXggIzE5NjIgIzE2NDlcbiAgICogQHBhcmFtICAgeyBIVE1MRWxlbWVudCB9IHJvb3QgLSBjaGlsZHJlbiBjb250YWluZXJcbiAgICogQHBhcmFtICAgeyBIVE1MRWxlbWVudCB9IGN1cnIgLSBub2RlIHRvIGluc2VydFxuICAgKiBAcGFyYW0gICB7IEhUTUxFbGVtZW50IH0gbmV4dCAtIG5vZGUgdGhhdCBzaG91bGQgcHJlY2VlZCB0aGUgY3VycmVudCBub2RlIGluc2VydGVkXG4gICAqL1xuICBmdW5jdGlvbiBzYWZlSW5zZXJ0KHJvb3QsIGN1cnIsIG5leHQpIHtcbiAgICByb290Lmluc2VydEJlZm9yZShjdXJyLCBuZXh0LnBhcmVudE5vZGUgJiYgbmV4dCk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhIHN0eWxlIG9iamVjdCB0byBhIHN0cmluZ1xuICAgKiBAcGFyYW0gICB7IE9iamVjdCB9IHN0eWxlIC0gc3R5bGUgb2JqZWN0IHdlIG5lZWQgdG8gcGFyc2VcbiAgICogQHJldHVybnMgeyBTdHJpbmcgfSByZXN1bHRpbmcgY3NzIHN0cmluZ1xuICAgKiBAZXhhbXBsZVxuICAgKiBzdHlsZU9iamVjdFRvU3RyaW5nKHsgY29sb3I6ICdyZWQnLCBoZWlnaHQ6ICcxMHB4J30pIC8vID0+ICdjb2xvcjogcmVkOyBoZWlnaHQ6IDEwcHgnXG4gICAqL1xuICBmdW5jdGlvbiBzdHlsZU9iamVjdFRvU3RyaW5nKHN0eWxlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHN0eWxlKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcHJvcCkge1xuICAgICAgcmV0dXJuIChhY2MgKyBcIiBcIiArIHByb3AgKyBcIjogXCIgKyAoc3R5bGVbcHJvcF0pICsgXCI7XCIpXG4gICAgfSwgJycpXG4gIH1cblxuICAvKipcbiAgICogV2FsayBkb3duIHJlY3Vyc2l2ZWx5IGFsbCB0aGUgY2hpbGRyZW4gdGFncyBzdGFydGluZyBkb20gbm9kZVxuICAgKiBAcGFyYW0gICB7IE9iamVjdCB9ICAgZG9tIC0gc3RhcnRpbmcgbm9kZSB3aGVyZSB3ZSB3aWxsIHN0YXJ0IHRoZSByZWN1cnNpb25cbiAgICogQHBhcmFtICAgeyBGdW5jdGlvbiB9IGZuIC0gY2FsbGJhY2sgdG8gdHJhbnNmb3JtIHRoZSBjaGlsZCBub2RlIGp1c3QgZm91bmRcbiAgICogQHBhcmFtICAgeyBPYmplY3QgfSAgIGNvbnRleHQgLSBmbiBjYW4gb3B0aW9uYWxseSByZXR1cm4gYW4gb2JqZWN0LCB3aGljaCBpcyBwYXNzZWQgdG8gY2hpbGRyZW5cbiAgICovXG4gIGZ1bmN0aW9uIHdhbGtOb2Rlcyhkb20sIGZuLCBjb250ZXh0KSB7XG4gICAgaWYgKGRvbSkge1xuICAgICAgdmFyIHJlcyA9IGZuKGRvbSwgY29udGV4dCk7XG4gICAgICB2YXIgbmV4dDtcbiAgICAgIC8vIHN0b3AgdGhlIHJlY3Vyc2lvblxuICAgICAgaWYgKHJlcyA9PT0gZmFsc2UpIHsgcmV0dXJuIH1cblxuICAgICAgZG9tID0gZG9tLmZpcnN0Q2hpbGQ7XG5cbiAgICAgIHdoaWxlIChkb20pIHtcbiAgICAgICAgbmV4dCA9IGRvbS5uZXh0U2libGluZztcbiAgICAgICAgd2Fsa05vZGVzKGRvbSwgZm4sIHJlcyk7XG4gICAgICAgIGRvbSA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuXG4gIHZhciBkb20gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgJCQ6ICQkLFxuICAgICQ6ICQsXG4gICAgY3JlYXRlRE9NUGxhY2Vob2xkZXI6IGNyZWF0ZURPTVBsYWNlaG9sZGVyLFxuICAgIG1rRWw6IG1ha2VFbGVtZW50LFxuICAgIHNldEF0dHI6IHNldEF0dHJpYnV0ZSxcbiAgICB0b2dnbGVWaXNpYmlsaXR5OiB0b2dnbGVWaXNpYmlsaXR5LFxuICAgIGdldEF0dHI6IGdldEF0dHJpYnV0ZSxcbiAgICByZW1BdHRyOiByZW1vdmVBdHRyaWJ1dGUsXG4gICAgc2V0SW5uZXJIVE1MOiBzZXRJbm5lckhUTUwsXG4gICAgd2Fsa0F0dHJzOiB3YWxrQXR0cmlidXRlcyxcbiAgICBjcmVhdGVGcmFnOiBjcmVhdGVGcmFnbWVudCxcbiAgICBzYWZlSW5zZXJ0OiBzYWZlSW5zZXJ0LFxuICAgIHN0eWxlT2JqZWN0VG9TdHJpbmc6IHN0eWxlT2JqZWN0VG9TdHJpbmcsXG4gICAgd2Fsa05vZGVzOiB3YWxrTm9kZXNcbiAgfSk7XG5cbiAgLyoqXG4gICAqIENoZWNrIGFnYWluc3QgdGhlIG51bGwgYW5kIHVuZGVmaW5lZCB2YWx1ZXNcbiAgICogQHBhcmFtICAgeyAqIH0gIHZhbHVlIC1cbiAgICogQHJldHVybnMge0Jvb2xlYW59IC1cbiAgICovXG4gIGZ1bmN0aW9uIGlzTmlsKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzVW5kZWZpbmVkKHZhbHVlKSB8fCB2YWx1ZSA9PT0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHBhc3NlZCBhcmd1bWVudCBpcyBlbXB0eS4gRGlmZmVyZW50IGZyb20gZmFsc3ksIGJlY2F1c2Ugd2UgZG9udCBjb25zaWRlciAwIG9yIGZhbHNlIHRvIGJlIGJsYW5rXG4gICAqIEBwYXJhbSB7ICogfSB2YWx1ZSAtXG4gICAqIEByZXR1cm5zIHsgQm9vbGVhbiB9IC1cbiAgICovXG4gIGZ1bmN0aW9uIGlzQmxhbmsodmFsdWUpIHtcbiAgICByZXR1cm4gaXNOaWwodmFsdWUpIHx8IHZhbHVlID09PSAnJ1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHBhc3NlZCBhcmd1bWVudCBpcyBhIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSAgIHsgKiB9IHZhbHVlIC1cbiAgICogQHJldHVybnMgeyBCb29sZWFuIH0gLVxuICAgKi9cbiAgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFRfRlVOQ1RJT05cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBwYXNzZWQgYXJndW1lbnQgaXMgYW4gb2JqZWN0LCBleGNsdWRlIG51bGxcbiAgICogTk9URTogdXNlIGlzT2JqZWN0KHgpICYmICFpc0FycmF5KHgpIHRvIGV4Y2x1ZGVzIGFycmF5cy5cbiAgICogQHBhcmFtICAgeyAqIH0gdmFsdWUgLVxuICAgKiBAcmV0dXJucyB7IEJvb2xlYW4gfSAtXG4gICAqL1xuICBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFRfT0JKRUNUIC8vIHR5cGVvZiBudWxsIGlzICdvYmplY3QnXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBET00gbm9kZSBpcyBhbiBzdmcgdGFnIG9yIHBhcnQgb2YgYW4gc3ZnXG4gICAqIEBwYXJhbSAgIHsgSFRNTEVsZW1lbnQgfSAgZWwgLSBub2RlIHdlIHdhbnQgdG8gdGVzdFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiBpdCdzIGFuIHN2ZyBub2RlXG4gICAqL1xuICBmdW5jdGlvbiBpc1N2ZyhlbCkge1xuICAgIHZhciBvd25lciA9IGVsLm93bmVyU1ZHRWxlbWVudDtcbiAgICByZXR1cm4gISFvd25lciB8fCBvd25lciA9PT0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHBhc3NlZCBhcmd1bWVudCBpcyBhIGtpbmQgb2YgYXJyYXlcbiAgICogQHBhcmFtICAgeyAqIH0gdmFsdWUgLVxuICAgKiBAcmV0dXJucyB7IEJvb2xlYW4gfSAtXG4gICAqL1xuICBmdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgQXJyYXlcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgcGFzc2VkIGFyZ3VtZW50IGlzIGEgYm9vbGVhbiBhdHRyaWJ1dGVcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSB2YWx1ZSAtXG4gICAqIEByZXR1cm5zIHsgQm9vbGVhbiB9IC1cbiAgICovXG4gIGZ1bmN0aW9uIGlzQm9vbEF0dHIodmFsdWUpIHtcbiAgICByZXR1cm4gUkVfQk9PTF9BVFRSUy50ZXN0KHZhbHVlKVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHBhc3NlZCBhcmd1bWVudCBpcyBhIHN0cmluZ1xuICAgKiBAcGFyYW0gICB7ICogfSB2YWx1ZSAtXG4gICAqIEByZXR1cm5zIHsgQm9vbGVhbiB9IC1cbiAgICovXG4gIGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gVF9TVFJJTkdcbiAgfVxuXG5cblxuICB2YXIgY2hlY2sgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgaXNCbGFuazogaXNCbGFuayxcbiAgICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICAgIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgICBpc1N2ZzogaXNTdmcsXG4gICAgaXNXcml0YWJsZTogaXNXcml0YWJsZSxcbiAgICBpc0FycmF5OiBpc0FycmF5LFxuICAgIGlzQm9vbEF0dHI6IGlzQm9vbEF0dHIsXG4gICAgaXNOaWw6IGlzTmlsLFxuICAgIGlzU3RyaW5nOiBpc1N0cmluZyxcbiAgICBpc1VuZGVmaW5lZDogaXNVbmRlZmluZWRcbiAgfSk7XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgYW4gYXJyYXkgY29udGFpbnMgYW4gaXRlbVxuICAgKiBAcGFyYW0gICB7IEFycmF5IH0gYXJyYXkgLSB0YXJnZXQgYXJyYXlcbiAgICogQHBhcmFtICAgeyAqIH0gaXRlbSAtIGl0ZW0gdG8gdGVzdFxuICAgKiBAcmV0dXJucyB7IEJvb2xlYW4gfSAtXG4gICAqL1xuICBmdW5jdGlvbiBjb250YWlucyhhcnJheSwgaXRlbSkge1xuICAgIHJldHVybiBhcnJheS5pbmRleE9mKGl0ZW0pICE9PSAtMVxuICB9XG5cbiAgLyoqXG4gICAqIFNwZWNpYWxpemVkIGZ1bmN0aW9uIGZvciBsb29waW5nIGFuIGFycmF5LWxpa2UgY29sbGVjdGlvbiB3aXRoIGBlYWNoPXt9YFxuICAgKiBAcGFyYW0gICB7IEFycmF5IH0gbGlzdCAtIGNvbGxlY3Rpb24gb2YgaXRlbXNcbiAgICogQHBhcmFtICAge0Z1bmN0aW9ufSBmbiAtIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAqIEByZXR1cm5zIHsgQXJyYXkgfSB0aGUgYXJyYXkgbG9vcGVkXG4gICAqL1xuICBmdW5jdGlvbiBlYWNoKGxpc3QsIGZuKSB7XG4gICAgdmFyIGxlbiA9IGxpc3QgPyBsaXN0Lmxlbmd0aCA6IDA7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHsgZm4obGlzdFtpXSwgaSk7IH1cbiAgICByZXR1cm4gbGlzdFxuICB9XG5cbiAgLyoqXG4gICAqIEZhc3RlciBTdHJpbmcgc3RhcnRzV2l0aCBhbHRlcm5hdGl2ZVxuICAgKiBAcGFyYW0gICB7IFN0cmluZyB9IHN0ciAtIHNvdXJjZSBzdHJpbmdcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSB2YWx1ZSAtIHRlc3Qgc3RyaW5nXG4gICAqIEByZXR1cm5zIHsgQm9vbGVhbiB9IC1cbiAgICovXG4gIGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyLCB2YWx1ZSkge1xuICAgIHJldHVybiBzdHIuc2xpY2UoMCwgdmFsdWUubGVuZ3RoKSA9PT0gdmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiByZXR1cm5pbmcgYWx3YXlzIGEgdW5pcXVlIGlkZW50aWZpZXJcbiAgICogQHJldHVybnMgeyBOdW1iZXIgfSAtIG51bWJlciBmcm9tIDAuLi5uXG4gICAqL1xuICB2YXIgdWlkID0gKGZ1bmN0aW9uIHVpZCgpIHtcbiAgICB2YXIgaSA9IC0xO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiArK2k7IH1cbiAgfSkoKVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gc2V0IGFuIGltbXV0YWJsZSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0gICB7IE9iamVjdCB9IGVsIC0gb2JqZWN0IHdoZXJlIHRoZSBuZXcgcHJvcGVydHkgd2lsbCBiZSBzZXRcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSBrZXkgLSBvYmplY3Qga2V5IHdoZXJlIHRoZSBuZXcgcHJvcGVydHkgd2lsbCBiZSBzdG9yZWRcbiAgICogQHBhcmFtICAgeyAqIH0gdmFsdWUgLSB2YWx1ZSBvZiB0aGUgbmV3IHByb3BlcnR5XG4gICAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gb3B0aW9ucyAtIHNldCB0aGUgcHJvcGVyeSBvdmVycmlkaW5nIHRoZSBkZWZhdWx0IG9wdGlvbnNcbiAgICogQHJldHVybnMgeyBPYmplY3QgfSAtIHRoZSBpbml0aWFsIG9iamVjdFxuICAgKi9cbiAgZnVuY3Rpb24gZGVmaW5lKGVsLCBrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsLCBrZXksIGV4dGVuZCh7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0sIG9wdGlvbnMpKTtcbiAgICByZXR1cm4gZWxcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgc3RyaW5nIGNvbnRhaW5pbmcgZGFzaGVzIHRvIGNhbWVsIGNhc2VcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSBzdHIgLSBpbnB1dCBzdHJpbmdcbiAgICogQHJldHVybnMgeyBTdHJpbmcgfSBteS1zdHJpbmcgLT4gbXlTdHJpbmdcbiAgICovXG4gIGZ1bmN0aW9uIHRvQ2FtZWwoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8tKFxcdykvZywgZnVuY3Rpb24gKF8sIGMpIHsgcmV0dXJuIGMudG9VcHBlckNhc2UoKTsgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBXYXJuIGEgbWVzc2FnZSB2aWEgY29uc29sZVxuICAgKiBAcGFyYW0gICB7U3RyaW5nfSBtZXNzYWdlIC0gd2FybmluZyBtZXNzYWdlXG4gICAqL1xuICBmdW5jdGlvbiB3YXJuKG1lc3NhZ2UpIHtcbiAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIHsgY29uc29sZS53YXJuKG1lc3NhZ2UpOyB9XG4gIH1cblxuXG5cbiAgdmFyIG1pc2MgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgY29udGFpbnM6IGNvbnRhaW5zLFxuICAgIGVhY2g6IGVhY2gsXG4gICAgZ2V0UHJvcERlc2NyaXB0b3I6IGdldFByb3BEZXNjcmlwdG9yLFxuICAgIHN0YXJ0c1dpdGg6IHN0YXJ0c1dpdGgsXG4gICAgdWlkOiB1aWQsXG4gICAgZGVmaW5lUHJvcGVydHk6IGRlZmluZSxcbiAgICBvYmplY3RDcmVhdGU6IGNyZWF0ZSxcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICB0b0NhbWVsOiB0b0NhbWVsLFxuICAgIHdhcm46IHdhcm5cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcHJvcGVydHkgb2YgYW4gb2JqZWN0IGZvciBhIGdpdmVuIGtleS4gSWYgc29tZXRoaW5nIGFscmVhZHlcbiAgICogZXhpc3RzIHRoZXJlLCB0aGVuIGl0IGJlY29tZXMgYW4gYXJyYXkgY29udGFpbmluZyBib3RoIHRoZSBvbGQgYW5kIG5ldyB2YWx1ZS5cbiAgICogQHBhcmFtIHsgT2JqZWN0IH0gb2JqIC0gb2JqZWN0IG9uIHdoaWNoIHRvIHNldCB0aGUgcHJvcGVydHlcbiAgICogQHBhcmFtIHsgU3RyaW5nIH0ga2V5IC0gcHJvcGVydHkgbmFtZVxuICAgKiBAcGFyYW0geyBPYmplY3QgfSB2YWx1ZSAtIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgc2V0XG4gICAqIEBwYXJhbSB7IEJvb2xlYW4gfSBlbnN1cmVBcnJheSAtIGVuc3VyZSB0aGF0IHRoZSBwcm9wZXJ0eSByZW1haW5zIGFuIGFycmF5XG4gICAqIEBwYXJhbSB7IE51bWJlciB9IGluZGV4IC0gYWRkIHRoZSBuZXcgaXRlbSBpbiBhIGNlcnRhaW4gYXJyYXkgcG9zaXRpb25cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5aXNoQWRkKG9iaiwga2V5LCB2YWx1ZSwgZW5zdXJlQXJyYXksIGluZGV4KSB7XG4gICAgdmFyIGRlc3QgPSBvYmpba2V5XTtcbiAgICB2YXIgaXNBcnIgPSBpc0FycmF5KGRlc3QpO1xuICAgIHZhciBoYXNJbmRleCA9ICFpc1VuZGVmaW5lZChpbmRleCk7XG5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ID09PSB2YWx1ZSkgeyByZXR1cm4gfVxuXG4gICAgLy8gaWYgdGhlIGtleSB3YXMgbmV2ZXIgc2V0LCBzZXQgaXQgb25jZVxuICAgIGlmICghZGVzdCAmJiBlbnN1cmVBcnJheSkgeyBvYmpba2V5XSA9IFt2YWx1ZV07IH1cbiAgICBlbHNlIGlmICghZGVzdCkgeyBvYmpba2V5XSA9IHZhbHVlOyB9XG4gICAgLy8gaWYgaXQgd2FzIGFuIGFycmF5IGFuZCBub3QgeWV0IHNldFxuICAgIGVsc2Uge1xuICAgICAgaWYgKGlzQXJyKSB7XG4gICAgICAgIHZhciBvbGRJbmRleCA9IGRlc3QuaW5kZXhPZih2YWx1ZSk7XG4gICAgICAgIC8vIHRoaXMgaXRlbSBuZXZlciBjaGFuZ2VkIGl0cyBwb3NpdGlvblxuICAgICAgICBpZiAob2xkSW5kZXggPT09IGluZGV4KSB7IHJldHVybiB9XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgaXRlbSBmcm9tIGl0cyBvbGQgcG9zaXRpb25cbiAgICAgICAgaWYgKG9sZEluZGV4ICE9PSAtMSkgeyBkZXN0LnNwbGljZShvbGRJbmRleCwgMSk7IH1cbiAgICAgICAgLy8gbW92ZSBvciBhZGQgdGhlIGl0ZW1cbiAgICAgICAgaWYgKGhhc0luZGV4KSB7XG4gICAgICAgICAgZGVzdC5zcGxpY2UoaW5kZXgsIDAsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZXN0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgeyBvYmpba2V5XSA9IFtkZXN0LCB2YWx1ZV07IH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGV0ZWN0IHRoZSB0YWcgaW1wbGVtZW50YXRpb24gYnkgYSBET00gbm9kZVxuICAgKiBAcGFyYW0gICB7IE9iamVjdCB9IGRvbSAtIERPTSBub2RlIHdlIG5lZWQgdG8gcGFyc2UgdG8gZ2V0IGl0cyB0YWcgaW1wbGVtZW50YXRpb25cbiAgICogQHJldHVybnMgeyBPYmplY3QgfSBpdCByZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiBhIGN1c3RvbSB0YWcgKHRlbXBsYXRlIGFuZCBib290IGZ1bmN0aW9uKVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0KGRvbSkge1xuICAgIHJldHVybiBkb20udGFnTmFtZSAmJiBfX1RBR19JTVBMW2dldEF0dHJpYnV0ZShkb20sIElTX0RJUkVDVElWRSkgfHxcbiAgICAgIGdldEF0dHJpYnV0ZShkb20sIElTX0RJUkVDVElWRSkgfHwgZG9tLnRhZ05hbWUudG9Mb3dlckNhc2UoKV1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRhZyBuYW1lIG9mIGFueSBET00gbm9kZVxuICAgKiBAcGFyYW0gICB7IE9iamVjdCB9IGRvbSAtIERPTSBub2RlIHdlIHdhbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtICAgeyBCb29sZWFuIH0gc2tpcERhdGFJcyAtIGhhY2sgdG8gaWdub3JlIHRoZSBkYXRhLWlzIGF0dHJpYnV0ZSB3aGVuIGF0dGFjaGluZyB0byBwYXJlbnRcbiAgICogQHJldHVybnMgeyBTdHJpbmcgfSBuYW1lIHRvIGlkZW50aWZ5IHRoaXMgZG9tIG5vZGUgaW4gcmlvdFxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0TmFtZShkb20sIHNraXBEYXRhSXMpIHtcbiAgICB2YXIgY2hpbGQgPSBnZXQoZG9tKTtcbiAgICB2YXIgbmFtZWRUYWcgPSAhc2tpcERhdGFJcyAmJiBnZXRBdHRyaWJ1dGUoZG9tLCBJU19ESVJFQ1RJVkUpO1xuICAgIHJldHVybiBuYW1lZFRhZyAmJiAhdG1wbC5oYXNFeHByKG5hbWVkVGFnKSA/XG4gICAgICBuYW1lZFRhZyA6IGNoaWxkID8gY2hpbGQubmFtZSA6IGRvbS50YWdOYW1lLnRvTG93ZXJDYXNlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSB0ZW1wb3JhcnkgY29udGV4dCBjb250YWluaW5nIGFsc28gdGhlIHBhcmVudCBwcm9wZXJ0aWVzXG4gICAqIEB0aGlzIFRhZ1xuICAgKiBAcGFyYW0geyBUYWcgfSAtIHRlbXBvcmFyeSB0YWcgY29udGV4dCBjb250YWluaW5nIGFsbCB0aGUgcGFyZW50IHByb3BlcnRpZXNcbiAgICovXG4gIGZ1bmN0aW9uIGluaGVyaXRQYXJlbnRQcm9wcygpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHsgcmV0dXJuIGV4dGVuZChjcmVhdGUodGhpcyksIHRoaXMucGFyZW50KSB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qXG4gICAgSW5jbHVkZXMgaGFja3MgbmVlZGVkIGZvciB0aGUgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbiA5IGFuZCBiZWxvd1xuICAgIFNlZTogaHR0cDovL2thbmdheC5naXRodWIuaW8vY29tcGF0LXRhYmxlL2VzNS8jaWU4XG4gICAgICAgICBodHRwOi8vY29kZXBsYW5ldC5pby9kcm9wcGluZy1pZTgvXG4gICovXG5cbiAgdmFyXG4gICAgcmVIYXNZaWVsZCAgPSAvPHlpZWxkXFxiL2ksXG4gICAgcmVZaWVsZEFsbCAgPSAvPHlpZWxkXFxzKig/OlxcLz58PihbXFxTXFxzXSo/KTxcXC95aWVsZFxccyo+fD4pL2lnLFxuICAgIHJlWWllbGRTcmMgID0gLzx5aWVsZFxccyt0bz1bJ1wiXShbXidcIj5dKilbJ1wiXVxccyo+KFtcXFNcXHNdKj8pPFxcL3lpZWxkXFxzKj4vaWcsXG4gICAgcmVZaWVsZERlc3QgPSAvPHlpZWxkXFxzK2Zyb209WydcIl0/KFstXFx3XSspWydcIl0/XFxzKig/OlxcLz58PihbXFxTXFxzXSo/KTxcXC95aWVsZFxccyo+KS9pZyxcbiAgICByb290RWxzID0geyB0cjogJ3Rib2R5JywgdGg6ICd0cicsIHRkOiAndHInLCBjb2w6ICdjb2xncm91cCcgfSxcbiAgICB0YmxUYWdzID0gSUVfVkVSU0lPTiAmJiBJRV9WRVJTSU9OIDwgMTAgPyBSRV9TUEVDSUFMX1RBR1MgOiBSRV9TUEVDSUFMX1RBR1NfTk9fT1BUSU9OLFxuICAgIEdFTkVSSUMgPSAnZGl2JyxcbiAgICBTVkcgPSAnc3ZnJztcblxuXG4gIC8qXG4gICAgQ3JlYXRlcyB0aGUgcm9vdCBlbGVtZW50IGZvciB0YWJsZSBvciBzZWxlY3QgY2hpbGQgZWxlbWVudHM6XG4gICAgdHIvdGgvdGQvdGhlYWQvdGZvb3QvdGJvZHkvY2FwdGlvbi9jb2wvY29sZ3JvdXAvb3B0aW9uL29wdGdyb3VwXG4gICovXG4gIGZ1bmN0aW9uIHNwZWNpYWxUYWdzKGVsLCB0bXBsLCB0YWdOYW1lKSB7XG5cbiAgICB2YXJcbiAgICAgIHNlbGVjdCA9IHRhZ05hbWVbMF0gPT09ICdvJyxcbiAgICAgIHBhcmVudCA9IHNlbGVjdCA/ICdzZWxlY3Q+JyA6ICd0YWJsZT4nO1xuXG4gICAgLy8gdHJpbSgpIGlzIGltcG9ydGFudCBoZXJlLCB0aGlzIGVuc3VyZXMgd2UgZG9uJ3QgaGF2ZSBhcnRpZmFjdHMsXG4gICAgLy8gc28gd2UgY2FuIGNoZWNrIGlmIHdlIGhhdmUgb25seSBvbmUgZWxlbWVudCBpbnNpZGUgdGhlIHBhcmVudFxuICAgIGVsLmlubmVySFRNTCA9ICc8JyArIHBhcmVudCArIHRtcGwudHJpbSgpICsgJzwvJyArIHBhcmVudDtcbiAgICBwYXJlbnQgPSBlbC5maXJzdENoaWxkO1xuXG4gICAgLy8gcmV0dXJucyB0aGUgaW1tZWRpYXRlIHBhcmVudCBpZiB0ci90aC90ZC9jb2wgaXMgdGhlIG9ubHkgZWxlbWVudCwgaWYgbm90XG4gICAgLy8gcmV0dXJucyB0aGUgd2hvbGUgdHJlZSwgYXMgdGhpcyBjYW4gaW5jbHVkZSBhZGRpdGlvbmFsIGVsZW1lbnRzXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAoc2VsZWN0KSB7XG4gICAgICBwYXJlbnQuc2VsZWN0ZWRJbmRleCA9IC0xOyAgLy8gZm9yIElFOSwgY29tcGF0aWJsZSB3L2N1cnJlbnQgcmlvdCBiZWhhdmlvclxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdm9pZHMgaW5zZXJ0aW9uIG9mIGNvaW50YWluZXIgaW5zaWRlIGNvbnRhaW5lciAoZXg6IHRib2R5IGluc2lkZSB0Ym9keSlcbiAgICAgIHZhciB0bmFtZSA9IHJvb3RFbHNbdGFnTmFtZV07XG4gICAgICBpZiAodG5hbWUgJiYgcGFyZW50LmNoaWxkRWxlbWVudENvdW50ID09PSAxKSB7IHBhcmVudCA9ICQodG5hbWUsIHBhcmVudCk7IH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudFxuICB9XG5cbiAgLypcbiAgICBSZXBsYWNlIHRoZSB5aWVsZCB0YWcgZnJvbSBhbnkgdGFnIHRlbXBsYXRlIHdpdGggdGhlIGlubmVySFRNTCBvZiB0aGVcbiAgICBvcmlnaW5hbCB0YWcgaW4gdGhlIHBhZ2VcbiAgKi9cbiAgZnVuY3Rpb24gcmVwbGFjZVlpZWxkKHRtcGwsIGh0bWwpIHtcbiAgICAvLyBkbyBub3RoaW5nIGlmIG5vIHlpZWxkXG4gICAgaWYgKCFyZUhhc1lpZWxkLnRlc3QodG1wbCkpIHsgcmV0dXJuIHRtcGwgfVxuXG4gICAgLy8gYmUgY2FyZWZ1bCB3aXRoICMxMzQzIC0gc3RyaW5nIG9uIHRoZSBzb3VyY2UgaGF2aW5nIGAkMWBcbiAgICB2YXIgc3JjID0ge307XG5cbiAgICBodG1sID0gaHRtbCAmJiBodG1sLnJlcGxhY2UocmVZaWVsZFNyYywgZnVuY3Rpb24gKF8sIHJlZiwgdGV4dCkge1xuICAgICAgc3JjW3JlZl0gPSBzcmNbcmVmXSB8fCB0ZXh0OyAgIC8vIHByZXNlcnZlIGZpcnN0IGRlZmluaXRpb25cbiAgICAgIHJldHVybiAnJ1xuICAgIH0pLnRyaW0oKTtcblxuICAgIHJldHVybiB0bXBsXG4gICAgICAucmVwbGFjZShyZVlpZWxkRGVzdCwgZnVuY3Rpb24gKF8sIHJlZiwgZGVmKSB7ICAvLyB5aWVsZCB3aXRoIGZyb20gLSB0byBhdHRyc1xuICAgICAgICByZXR1cm4gc3JjW3JlZl0gfHwgZGVmIHx8ICcnXG4gICAgICB9KVxuICAgICAgLnJlcGxhY2UocmVZaWVsZEFsbCwgZnVuY3Rpb24gKF8sIGRlZikgeyAgICAgICAgLy8geWllbGQgd2l0aG91dCBhbnkgXCJmcm9tXCJcbiAgICAgICAgcmV0dXJuIGh0bWwgfHwgZGVmIHx8ICcnXG4gICAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBET00gZWxlbWVudCB0byB3cmFwIHRoZSBnaXZlbiBjb250ZW50LiBOb3JtYWxseSBhbiBgRElWYCwgYnV0IGNhbiBiZVxuICAgKiBhbHNvIGEgYFRBQkxFYCwgYFNFTEVDVGAsIGBUQk9EWWAsIGBUUmAsIG9yIGBDT0xHUk9VUGAgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSB0bXBsICAtIFRoZSB0ZW1wbGF0ZSBjb21pbmcgZnJvbSB0aGUgY3VzdG9tIHRhZyBkZWZpbml0aW9uXG4gICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gaHRtbCAtIEhUTUwgY29udGVudCB0aGF0IGNvbWVzIGZyb20gdGhlIERPTSBlbGVtZW50IHdoZXJlIHlvdVxuICAgKiAgICAgICAgICAgd2lsbCBtb3VudCB0aGUgdGFnLCBtb3N0bHkgdGhlIG9yaWdpbmFsIHRhZyBpbiB0aGUgcGFnZVxuICAgKiBAcGFyYW0gICB7IEJvb2xlYW4gfSBpc1N2ZyAtIHRydWUgaWYgdGhlIHJvb3Qgbm9kZSBpcyBhbiBzdmdcbiAgICogQHJldHVybnMgeyBIVE1MRWxlbWVudCB9IERPTSBlbGVtZW50IHdpdGggX3RtcGxfIG1lcmdlZCB0aHJvdWdoIGBZSUVMRGAgd2l0aCB0aGUgX2h0bWxfLlxuICAgKi9cbiAgZnVuY3Rpb24gbWtkb20odG1wbCwgaHRtbCwgaXNTdmcpIHtcbiAgICB2YXIgbWF0Y2ggICA9IHRtcGwgJiYgdG1wbC5tYXRjaCgvXlxccyo8KFstXFx3XSspLyk7XG4gICAgdmFyICB0YWdOYW1lID0gbWF0Y2ggJiYgbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgZWwgPSBtYWtlRWxlbWVudChpc1N2ZyA/IFNWRyA6IEdFTkVSSUMpO1xuXG4gICAgLy8gcmVwbGFjZSBhbGwgdGhlIHlpZWxkIHRhZ3Mgd2l0aCB0aGUgdGFnIGlubmVyIGh0bWxcbiAgICB0bXBsID0gcmVwbGFjZVlpZWxkKHRtcGwsIGh0bWwpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodGJsVGFncy50ZXN0KHRhZ05hbWUpKVxuICAgICAgeyBlbCA9IHNwZWNpYWxUYWdzKGVsLCB0bXBsLCB0YWdOYW1lKTsgfVxuICAgIGVsc2VcbiAgICAgIHsgc2V0SW5uZXJIVE1MKGVsLCB0bXBsLCBpc1N2Zyk7IH1cblxuICAgIHJldHVybiBlbFxuICB9XG5cbiAgLyoqXG4gICAqIExvb3AgYmFja3dhcmQgYWxsIHRoZSBwYXJlbnRzIHRyZWUgdG8gZGV0ZWN0IHRoZSBmaXJzdCBjdXN0b20gcGFyZW50IHRhZ1xuICAgKiBAcGFyYW0gICB7IE9iamVjdCB9IHRhZyAtIGEgVGFnIGluc3RhbmNlXG4gICAqIEByZXR1cm5zIHsgT2JqZWN0IH0gdGhlIGluc3RhbmNlIG9mIHRoZSBmaXJzdCBjdXN0b20gcGFyZW50IHRhZyBmb3VuZFxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SW1tZWRpYXRlQ3VzdG9tUGFyZW50KHRhZykge1xuICAgIHZhciBwdGFnID0gdGFnO1xuICAgIHdoaWxlIChwdGFnLl9fLmlzQW5vbnltb3VzKSB7XG4gICAgICBpZiAoIXB0YWcucGFyZW50KSB7IGJyZWFrIH1cbiAgICAgIHB0YWcgPSBwdGFnLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHB0YWdcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIERPTSBldmVudHNcbiAgICogQHBhcmFtICAgeyBIVE1MRWxlbWVudCB9IGRvbSAtIGRvbSBlbGVtZW50IHRhcmdldCBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtICAgeyBGdW5jdGlvbiB9IGhhbmRsZXIgLSB1c2VyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gZSAtIGV2ZW50IG9iamVjdFxuICAgKi9cbiAgZnVuY3Rpb24gaGFuZGxlRXZlbnQoZG9tLCBoYW5kbGVyLCBlKSB7XG4gICAgdmFyIHB0YWcgPSB0aGlzLl9fLnBhcmVudDtcbiAgICB2YXIgaXRlbSA9IHRoaXMuX18uaXRlbTtcblxuICAgIGlmICghaXRlbSlcbiAgICAgIHsgd2hpbGUgKHB0YWcgJiYgIWl0ZW0pIHtcbiAgICAgICAgaXRlbSA9IHB0YWcuX18uaXRlbTtcbiAgICAgICAgcHRhZyA9IHB0YWcuX18ucGFyZW50O1xuICAgICAgfSB9XG5cbiAgICAvLyBvdmVycmlkZSB0aGUgZXZlbnQgcHJvcGVydGllc1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKGlzV3JpdGFibGUoZSwgJ2N1cnJlbnRUYXJnZXQnKSkgeyBlLmN1cnJlbnRUYXJnZXQgPSBkb207IH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmIChpc1dyaXRhYmxlKGUsICd0YXJnZXQnKSkgeyBlLnRhcmdldCA9IGUuc3JjRWxlbWVudDsgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKGlzV3JpdGFibGUoZSwgJ3doaWNoJykpIHsgZS53aGljaCA9IGUuY2hhckNvZGUgfHwgZS5rZXlDb2RlOyB9XG5cbiAgICBlLml0ZW0gPSBpdGVtO1xuXG4gICAgaGFuZGxlci5jYWxsKHRoaXMsIGUpO1xuXG4gICAgLy8gYXZvaWQgYXV0byB1cGRhdGVzXG4gICAgaWYgKCFzZXR0aW5ncy5hdXRvVXBkYXRlKSB7IHJldHVybiB9XG5cbiAgICBpZiAoIWUucHJldmVudFVwZGF0ZSkge1xuICAgICAgdmFyIHAgPSBnZXRJbW1lZGlhdGVDdXN0b21QYXJlbnQodGhpcyk7XG4gICAgICAvLyBmaXhlcyAjMjA4M1xuICAgICAgaWYgKHAuaXNNb3VudGVkKSB7IHAudXBkYXRlKCk7IH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoIGFuIGV2ZW50IHRvIGEgRE9NIG5vZGVcbiAgICogQHBhcmFtIHsgU3RyaW5nIH0gbmFtZSAtIGV2ZW50IG5hbWVcbiAgICogQHBhcmFtIHsgRnVuY3Rpb24gfSBoYW5kbGVyIC0gZXZlbnQgY2FsbGJhY2tcbiAgICogQHBhcmFtIHsgT2JqZWN0IH0gZG9tIC0gZG9tIG5vZGVcbiAgICogQHBhcmFtIHsgVGFnIH0gdGFnIC0gdGFnIGluc3RhbmNlXG4gICAqL1xuICBmdW5jdGlvbiBzZXRFdmVudEhhbmRsZXIobmFtZSwgaGFuZGxlciwgZG9tLCB0YWcpIHtcbiAgICB2YXIgZXZlbnROYW1lO1xuICAgIHZhciBjYiA9IGhhbmRsZUV2ZW50LmJpbmQodGFnLCBkb20sIGhhbmRsZXIpO1xuXG4gICAgLy8gYXZvaWQgdG8gYmluZCB0d2ljZSB0aGUgc2FtZSBldmVudFxuICAgIC8vIHBvc3NpYmxlIGZpeCBmb3IgIzIzMzJcbiAgICBkb21bbmFtZV0gPSBudWxsO1xuXG4gICAgLy8gbm9ybWFsaXplIGV2ZW50IG5hbWVcbiAgICBldmVudE5hbWUgPSBuYW1lLnJlcGxhY2UoUkVfRVZFTlRTX1BSRUZJWCwgJycpO1xuXG4gICAgLy8gY2FjaGUgdGhlIGxpc3RlbmVyIGludG8gdGhlIGxpc3RlbmVycyBhcnJheVxuICAgIGlmICghY29udGFpbnModGFnLl9fLmxpc3RlbmVycywgZG9tKSkgeyB0YWcuX18ubGlzdGVuZXJzLnB1c2goZG9tKTsgfVxuICAgIGlmICghZG9tW1JJT1RfRVZFTlRTX0tFWV0pIHsgZG9tW1JJT1RfRVZFTlRTX0tFWV0gPSB7fTsgfVxuICAgIGlmIChkb21bUklPVF9FVkVOVFNfS0VZXVtuYW1lXSkgeyBkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGRvbVtSSU9UX0VWRU5UU19LRVldW25hbWVdKTsgfVxuXG4gICAgZG9tW1JJT1RfRVZFTlRTX0tFWV1bbmFtZV0gPSBjYjtcbiAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGNiLCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGNoaWxkIHRhZyBpbmNsdWRpbmcgaXQgY29ycmVjdGx5IGludG8gaXRzIHBhcmVudFxuICAgKiBAcGFyYW0gICB7IE9iamVjdCB9IGNoaWxkIC0gY2hpbGQgdGFnIGltcGxlbWVudGF0aW9uXG4gICAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gb3B0cyAtIHRhZyBvcHRpb25zIGNvbnRhaW5pbmcgdGhlIERPTSBub2RlIHdoZXJlIHRoZSB0YWcgd2lsbCBiZSBtb3VudGVkXG4gICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gaW5uZXJIVE1MIC0gaW5uZXIgaHRtbCBvZiB0aGUgY2hpbGQgbm9kZVxuICAgKiBAcGFyYW0gICB7IE9iamVjdCB9IHBhcmVudCAtIGluc3RhbmNlIG9mIHRoZSBwYXJlbnQgdGFnIGluY2x1ZGluZyB0aGUgY2hpbGQgY3VzdG9tIHRhZ1xuICAgKiBAcmV0dXJucyB7IE9iamVjdCB9IGluc3RhbmNlIG9mIHRoZSBuZXcgY2hpbGQgdGFnIGp1c3QgY3JlYXRlZFxuICAgKi9cbiAgZnVuY3Rpb24gaW5pdENoaWxkKGNoaWxkLCBvcHRzLCBpbm5lckhUTUwsIHBhcmVudCkge1xuICAgIHZhciB0YWcgPSBjcmVhdGVUYWcoY2hpbGQsIG9wdHMsIGlubmVySFRNTCk7XG4gICAgdmFyIHRhZ05hbWUgPSBvcHRzLnRhZ05hbWUgfHwgZ2V0TmFtZShvcHRzLnJvb3QsIHRydWUpO1xuICAgIHZhciBwdGFnID0gZ2V0SW1tZWRpYXRlQ3VzdG9tUGFyZW50KHBhcmVudCk7XG4gICAgLy8gZml4IGZvciB0aGUgcGFyZW50IGF0dHJpYnV0ZSBpbiB0aGUgbG9vcGVkIGVsZW1lbnRzXG4gICAgZGVmaW5lKHRhZywgJ3BhcmVudCcsIHB0YWcpO1xuICAgIC8vIHN0b3JlIHRoZSByZWFsIHBhcmVudCB0YWdcbiAgICAvLyBpbiBzb21lIGNhc2VzIHRoaXMgY291bGQgYmUgZGlmZmVyZW50IGZyb20gdGhlIGN1c3RvbSBwYXJlbnQgdGFnXG4gICAgLy8gZm9yIGV4YW1wbGUgaW4gbmVzdGVkIGxvb3BzXG4gICAgdGFnLl9fLnBhcmVudCA9IHBhcmVudDtcblxuICAgIC8vIGFkZCB0aGlzIHRhZyB0byB0aGUgY3VzdG9tIHBhcmVudCB0YWdcbiAgICBhcnJheWlzaEFkZChwdGFnLnRhZ3MsIHRhZ05hbWUsIHRhZyk7XG5cbiAgICAvLyBhbmQgYWxzbyB0byB0aGUgcmVhbCBwYXJlbnQgdGFnXG4gICAgaWYgKHB0YWcgIT09IHBhcmVudClcbiAgICAgIHsgYXJyYXlpc2hBZGQocGFyZW50LnRhZ3MsIHRhZ05hbWUsIHRhZyk7IH1cblxuICAgIHJldHVybiB0YWdcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSBhbiBvYmplY3QgYXQgYSBnaXZlbiBrZXkuIElmIHRoZSBrZXkgcG9pbnRzIHRvIGFuIGFycmF5LFxuICAgKiB0aGVuIHRoZSBpdGVtIGlzIGp1c3QgcmVtb3ZlZCBmcm9tIHRoZSBhcnJheS5cbiAgICogQHBhcmFtIHsgT2JqZWN0IH0gb2JqIC0gb2JqZWN0IG9uIHdoaWNoIHRvIHJlbW92ZSB0aGUgcHJvcGVydHlcbiAgICogQHBhcmFtIHsgU3RyaW5nIH0ga2V5IC0gcHJvcGVydHkgbmFtZVxuICAgKiBAcGFyYW0geyBPYmplY3QgfSB2YWx1ZSAtIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgcmVtb3ZlZFxuICAgKiBAcGFyYW0geyBCb29sZWFuIH0gZW5zdXJlQXJyYXkgLSBlbnN1cmUgdGhhdCB0aGUgcHJvcGVydHkgcmVtYWlucyBhbiBhcnJheVxuICAqL1xuICBmdW5jdGlvbiBhcnJheWlzaFJlbW92ZShvYmosIGtleSwgdmFsdWUsIGVuc3VyZUFycmF5KSB7XG4gICAgaWYgKGlzQXJyYXkob2JqW2tleV0pKSB7XG4gICAgICB2YXIgaW5kZXggPSBvYmpba2V5XS5pbmRleE9mKHZhbHVlKTtcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHsgb2JqW2tleV0uc3BsaWNlKGluZGV4LCAxKTsgfVxuICAgICAgaWYgKCFvYmpba2V5XS5sZW5ndGgpIHsgZGVsZXRlIG9ialtrZXldOyB9XG4gICAgICBlbHNlIGlmIChvYmpba2V5XS5sZW5ndGggPT09IDEgJiYgIWVuc3VyZUFycmF5KSB7IG9ialtrZXldID0gb2JqW2tleV1bMF07IH1cbiAgICB9IGVsc2UgaWYgKG9ialtrZXldID09PSB2YWx1ZSlcbiAgICAgIHsgZGVsZXRlIG9ialtrZXldOyB9IC8vIG90aGVyd2lzZSBqdXN0IGRlbGV0ZSB0aGUga2V5XG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgZWxlbWVudHMgZm9yIGEgdmlydHVhbCB0YWdcbiAgICogQHRoaXMgVGFnXG4gICAqIEBwYXJhbSB7IE5vZGUgfSBzcmMgLSB0aGUgbm9kZSB0aGF0IHdpbGwgZG8gdGhlIGluc2VydGluZyBvciBhcHBlbmRpbmdcbiAgICogQHBhcmFtIHsgVGFnIH0gdGFyZ2V0IC0gb25seSBpZiBpbnNlcnRpbmcsIGluc2VydCBiZWZvcmUgdGhpcyB0YWcncyBmaXJzdCBjaGlsZFxuICAgKi9cbiAgZnVuY3Rpb24gbWFrZVZpcnR1YWwoc3JjLCB0YXJnZXQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBoZWFkID0gY3JlYXRlRE9NUGxhY2Vob2xkZXIoKTtcbiAgICB2YXIgdGFpbCA9IGNyZWF0ZURPTVBsYWNlaG9sZGVyKCk7XG4gICAgdmFyIGZyYWcgPSBjcmVhdGVGcmFnbWVudCgpO1xuICAgIHZhciBzaWI7XG4gICAgdmFyIGVsO1xuXG4gICAgdGhpcy5yb290Lmluc2VydEJlZm9yZShoZWFkLCB0aGlzLnJvb3QuZmlyc3RDaGlsZCk7XG4gICAgdGhpcy5yb290LmFwcGVuZENoaWxkKHRhaWwpO1xuXG4gICAgdGhpcy5fXy5oZWFkID0gZWwgPSBoZWFkO1xuICAgIHRoaXMuX18udGFpbCA9IHRhaWw7XG5cbiAgICB3aGlsZSAoZWwpIHtcbiAgICAgIHNpYiA9IGVsLm5leHRTaWJsaW5nO1xuICAgICAgZnJhZy5hcHBlbmRDaGlsZChlbCk7XG4gICAgICB0aGlzJDEuX18udmlydHMucHVzaChlbCk7IC8vIGhvbGQgZm9yIHVubW91bnRpbmdcbiAgICAgIGVsID0gc2liO1xuICAgIH1cblxuICAgIGlmICh0YXJnZXQpXG4gICAgICB7IHNyYy5pbnNlcnRCZWZvcmUoZnJhZywgdGFyZ2V0Ll9fLmhlYWQpOyB9XG4gICAgZWxzZVxuICAgICAgeyBzcmMuYXBwZW5kQ2hpbGQoZnJhZyk7IH1cbiAgfVxuXG4gIC8qKlxuICAgKiBtYWtlcyBhIHRhZyB2aXJ0dWFsIGFuZCByZXBsYWNlcyBhIHJlZmVyZW5jZSBpbiB0aGUgZG9tXG4gICAqIEB0aGlzIFRhZ1xuICAgKiBAcGFyYW0geyB0YWcgfSB0aGUgdGFnIHRvIG1ha2UgdmlydHVhbFxuICAgKiBAcGFyYW0geyByZWYgfSB0aGUgZG9tIHJlZmVyZW5jZSBsb2NhdGlvblxuICAgKi9cbiAgZnVuY3Rpb24gbWFrZVJlcGxhY2VWaXJ0dWFsKHRhZywgcmVmKSB7XG4gICAgdmFyIGZyYWcgPSBjcmVhdGVGcmFnbWVudCgpO1xuICAgIG1ha2VWaXJ0dWFsLmNhbGwodGFnLCBmcmFnKTtcbiAgICByZWYucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoZnJhZywgcmVmKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgZHluYW1pY2FsbHkgY3JlYXRlZCBkYXRhLWlzIHRhZ3Mgd2l0aCBjaGFuZ2luZyBleHByZXNzaW9uc1xuICAgKiBAcGFyYW0geyBPYmplY3QgfSBleHByIC0gZXhwcmVzc2lvbiB0YWcgYW5kIGV4cHJlc3Npb24gaW5mb1xuICAgKiBAcGFyYW0geyBUYWcgfSAgICBwYXJlbnQgLSBwYXJlbnQgZm9yIHRhZyBjcmVhdGlvblxuICAgKiBAcGFyYW0geyBTdHJpbmcgfSB0YWdOYW1lIC0gdGFnIGltcGxlbWVudGF0aW9uIHdlIHdhbnQgdG8gdXNlXG4gICAqL1xuICBmdW5jdGlvbiB1cGRhdGVEYXRhSXMoZXhwciwgcGFyZW50LCB0YWdOYW1lKSB7XG4gICAgdmFyIHRhZyA9IGV4cHIudGFnIHx8IGV4cHIuZG9tLl90YWc7XG4gICAgdmFyIHJlZjtcblxuICAgIHZhciByZWYkMSA9IHRhZyA/IHRhZy5fXyA6IHt9O1xuICAgIHZhciBoZWFkID0gcmVmJDEuaGVhZDtcbiAgICB2YXIgaXNWaXJ0dWFsID0gZXhwci5kb20udGFnTmFtZSA9PT0gJ1ZJUlRVQUwnO1xuXG4gICAgaWYgKHRhZyAmJiBleHByLnRhZ05hbWUgPT09IHRhZ05hbWUpIHtcbiAgICAgIHRhZy51cGRhdGUoKTtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHN5bmMgX3BhcmVudCB0byBhY2NvbW1vZGF0ZSBjaGFuZ2luZyB0YWduYW1lc1xuICAgIGlmICh0YWcpIHtcbiAgICAgIC8vIG5lZWQgcGxhY2Vob2xkZXIgYmVmb3JlIHVubW91bnRcbiAgICAgIGlmKGlzVmlydHVhbCkge1xuICAgICAgICByZWYgPSBjcmVhdGVET01QbGFjZWhvbGRlcigpO1xuICAgICAgICBoZWFkLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHJlZiwgaGVhZCk7XG4gICAgICB9XG5cbiAgICAgIHRhZy51bm1vdW50KHRydWUpO1xuICAgIH1cblxuICAgIC8vIHVuYWJsZSB0byBnZXQgdGhlIHRhZyBuYW1lXG4gICAgaWYgKCFpc1N0cmluZyh0YWdOYW1lKSkgeyByZXR1cm4gfVxuXG4gICAgZXhwci5pbXBsID0gX19UQUdfSU1QTFt0YWdOYW1lXTtcblxuICAgIC8vIHVua25vd24gaW1wbGVtZW50YXRpb25cbiAgICBpZiAoIWV4cHIuaW1wbCkgeyByZXR1cm4gfVxuXG4gICAgZXhwci50YWcgPSB0YWcgPSBpbml0Q2hpbGQoXG4gICAgICBleHByLmltcGwsIHtcbiAgICAgICAgcm9vdDogZXhwci5kb20sXG4gICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICB0YWdOYW1lOiB0YWdOYW1lXG4gICAgICB9LFxuICAgICAgZXhwci5kb20uaW5uZXJIVE1MLFxuICAgICAgcGFyZW50XG4gICAgKTtcblxuICAgIGVhY2goZXhwci5hdHRycywgZnVuY3Rpb24gKGEpIHsgcmV0dXJuIHNldEF0dHJpYnV0ZSh0YWcucm9vdCwgYS5uYW1lLCBhLnZhbHVlKTsgfSk7XG4gICAgZXhwci50YWdOYW1lID0gdGFnTmFtZTtcbiAgICB0YWcubW91bnQoKTtcblxuICAgIC8vIHJvb3QgZXhpc3QgZmlyc3QgdGltZSwgYWZ0ZXIgdXNlIHBsYWNlaG9sZGVyXG4gICAgaWYgKGlzVmlydHVhbCkgeyBtYWtlUmVwbGFjZVZpcnR1YWwodGFnLCByZWYgfHwgdGFnLnJvb3QpOyB9XG5cbiAgICAvLyBwYXJlbnQgaXMgdGhlIHBsYWNlaG9sZGVyIHRhZywgbm90IHRoZSBkeW5hbWljIHRhZyBzbyBjbGVhbiB1cFxuICAgIHBhcmVudC5fXy5vblVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZGVsTmFtZSA9IHRhZy5vcHRzLmRhdGFJcztcbiAgICAgIGFycmF5aXNoUmVtb3ZlKHRhZy5wYXJlbnQudGFncywgZGVsTmFtZSwgdGFnKTtcbiAgICAgIGFycmF5aXNoUmVtb3ZlKHRhZy5fXy5wYXJlbnQudGFncywgZGVsTmFtZSwgdGFnKTtcbiAgICAgIHRhZy51bm1vdW50KCk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb21hbGl6ZSBhbnkgYXR0cmlidXRlIHJlbW92aW5nIHRoZSBcInJpb3QtXCIgcHJlZml4XG4gICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gYXR0ck5hbWUgLSBvcmlnaW5hbCBhdHRyaWJ1dGUgbmFtZVxuICAgKiBAcmV0dXJucyB7IFN0cmluZyB9IHZhbGlkIGh0bWwgYXR0cmlidXRlIG5hbWVcbiAgICovXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUF0dHJOYW1lKGF0dHJOYW1lKSB7XG4gICAgaWYgKCFhdHRyTmFtZSkgeyByZXR1cm4gbnVsbCB9XG4gICAgYXR0ck5hbWUgPSBhdHRyTmFtZS5yZXBsYWNlKEFUVFJTX1BSRUZJWCwgJycpO1xuICAgIGlmIChDQVNFX1NFTlNJVElWRV9BVFRSSUJVVEVTW2F0dHJOYW1lXSkgeyBhdHRyTmFtZSA9IENBU0VfU0VOU0lUSVZFX0FUVFJJQlVURVNbYXR0ck5hbWVdOyB9XG4gICAgcmV0dXJuIGF0dHJOYW1lXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIG9uIHNpbmdsZSB0YWcgZXhwcmVzc2lvblxuICAgKiBAdGhpcyBUYWdcbiAgICogQHBhcmFtIHsgT2JqZWN0IH0gZXhwciAtIGV4cHJlc3Npb24gbG9naWNcbiAgICogQHJldHVybnMgeyB1bmRlZmluZWQgfVxuICAgKi9cbiAgZnVuY3Rpb24gdXBkYXRlRXhwcmVzc2lvbihleHByKSB7XG4gICAgaWYgKHRoaXMucm9vdCAmJiBnZXRBdHRyaWJ1dGUodGhpcy5yb290LCd2aXJ0dWFsaXplZCcpKSB7IHJldHVybiB9XG5cbiAgICB2YXIgZG9tID0gZXhwci5kb207XG4gICAgLy8gcmVtb3ZlIHRoZSByaW90LSBwcmVmaXhcbiAgICB2YXIgYXR0ck5hbWUgPSBub3JtYWxpemVBdHRyTmFtZShleHByLmF0dHIpO1xuICAgIHZhciBpc1RvZ2dsZSA9IGNvbnRhaW5zKFtTSE9XX0RJUkVDVElWRSwgSElERV9ESVJFQ1RJVkVdLCBhdHRyTmFtZSk7XG4gICAgdmFyIGlzVmlydHVhbCA9IGV4cHIucm9vdCAmJiBleHByLnJvb3QudGFnTmFtZSA9PT0gJ1ZJUlRVQUwnO1xuICAgIHZhciByZWYgPSB0aGlzLl9fO1xuICAgIHZhciBpc0Fub255bW91cyA9IHJlZi5pc0Fub255bW91cztcbiAgICB2YXIgcGFyZW50ID0gZG9tICYmIChleHByLnBhcmVudCB8fCBkb20ucGFyZW50Tm9kZSk7XG4gICAgLy8gZGV0ZWN0IHRoZSBzdHlsZSBhdHRyaWJ1dGVzXG4gICAgdmFyIGlzU3R5bGVBdHRyID0gYXR0ck5hbWUgPT09ICdzdHlsZSc7XG4gICAgdmFyIGlzQ2xhc3NBdHRyID0gYXR0ck5hbWUgPT09ICdjbGFzcyc7XG5cbiAgICB2YXIgdmFsdWU7XG5cbiAgICAvLyBpZiBpdCdzIGEgdGFnIHdlIGNvdWxkIHRvdGFsbHkgc2tpcCB0aGUgcmVzdFxuICAgIGlmIChleHByLl9yaW90X2lkKSB7XG4gICAgICBpZiAoZXhwci5fXy53YXNDcmVhdGVkKSB7XG4gICAgICAgIGV4cHIudXBkYXRlKCk7XG4gICAgICAvLyBpZiBpdCBoYXNuJ3QgYmVlbiBtb3VudGVkIHlldCwgZG8gdGhhdCBub3cuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleHByLm1vdW50KCk7XG4gICAgICAgIGlmIChpc1ZpcnR1YWwpIHtcbiAgICAgICAgICBtYWtlUmVwbGFjZVZpcnR1YWwoZXhwciwgZXhwci5yb290KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gaWYgdGhpcyBleHByZXNzaW9uIGhhcyB0aGUgdXBkYXRlIG1ldGhvZCBpdCBtZWFucyBpdCBjYW4gaGFuZGxlIHRoZSBET00gY2hhbmdlcyBieSBpdHNlbGZcbiAgICBpZiAoZXhwci51cGRhdGUpIHsgcmV0dXJuIGV4cHIudXBkYXRlKCkgfVxuXG4gICAgdmFyIGNvbnRleHQgPSBpc1RvZ2dsZSAmJiAhaXNBbm9ueW1vdXMgPyBpbmhlcml0UGFyZW50UHJvcHMuY2FsbCh0aGlzKSA6IHRoaXM7XG5cbiAgICAvLyAuLi5pdCBzZWVtcyB0byBiZSBhIHNpbXBsZSBleHByZXNzaW9uIHNvIHdlIHRyeSB0byBjYWxjdWxhdGUgaXRzIHZhbHVlXG4gICAgdmFsdWUgPSB0bXBsKGV4cHIuZXhwciwgY29udGV4dCk7XG5cbiAgICB2YXIgaGFzVmFsdWUgPSAhaXNCbGFuayh2YWx1ZSk7XG4gICAgdmFyIGlzT2JqID0gaXNPYmplY3QodmFsdWUpO1xuXG4gICAgLy8gY29udmVydCB0aGUgc3R5bGUvY2xhc3Mgb2JqZWN0cyB0byBzdHJpbmdzXG4gICAgaWYgKGlzT2JqKSB7XG4gICAgICBpZiAoaXNDbGFzc0F0dHIpIHtcbiAgICAgICAgdmFsdWUgPSB0bXBsKEpTT04uc3RyaW5naWZ5KHZhbHVlKSwgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKGlzU3R5bGVBdHRyKSB7XG4gICAgICAgIHZhbHVlID0gc3R5bGVPYmplY3RUb1N0cmluZyh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIG9yaWdpbmFsIGF0dHJpYnV0ZVxuICAgIGlmIChleHByLmF0dHIgJiYgKCFleHByLndhc1BhcnNlZE9uY2UgfHwgIWhhc1ZhbHVlIHx8IHZhbHVlID09PSBmYWxzZSkpIHtcbiAgICAgIC8vIHJlbW92ZSBlaXRoZXIgcmlvdC0qIGF0dHJpYnV0ZXMgb3IganVzdCB0aGUgYXR0cmlidXRlIG5hbWVcbiAgICAgIHJlbW92ZUF0dHJpYnV0ZShkb20sIGdldEF0dHJpYnV0ZShkb20sIGV4cHIuYXR0cikgPyBleHByLmF0dHIgOiBhdHRyTmFtZSk7XG4gICAgfVxuXG4gICAgLy8gZm9yIHRoZSBib29sZWFuIGF0dHJpYnV0ZXMgd2UgZG9uJ3QgbmVlZCB0aGUgdmFsdWVcbiAgICAvLyB3ZSBjYW4gY29udmVydCBpdCB0byBjaGVja2VkPXRydWUgdG8gY2hlY2tlZD1jaGVja2VkXG4gICAgaWYgKGV4cHIuYm9vbCkgeyB2YWx1ZSA9IHZhbHVlID8gYXR0ck5hbWUgOiBmYWxzZTsgfVxuICAgIGlmIChleHByLmlzUnRhZykgeyByZXR1cm4gdXBkYXRlRGF0YUlzKGV4cHIsIHRoaXMsIHZhbHVlKSB9XG4gICAgaWYgKGV4cHIud2FzUGFyc2VkT25jZSAmJiBleHByLnZhbHVlID09PSB2YWx1ZSkgeyByZXR1cm4gfVxuXG4gICAgLy8gdXBkYXRlIHRoZSBleHByZXNzaW9uIHZhbHVlXG4gICAgZXhwci52YWx1ZSA9IHZhbHVlO1xuICAgIGV4cHIud2FzUGFyc2VkT25jZSA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0IChhbmQgaXQncyBub3QgYSBzdHlsZSBvciBjbGFzcyBhdHRyaWJ1dGUpIHdlIGNhbiBub3QgZG8gbXVjaCBtb3JlIHdpdGggaXRcbiAgICBpZiAoaXNPYmogJiYgIWlzQ2xhc3NBdHRyICYmICFpc1N0eWxlQXR0ciAmJiAhaXNUb2dnbGUpIHsgcmV0dXJuIH1cbiAgICAvLyBhdm9pZCB0byByZW5kZXIgdW5kZWZpbmVkL251bGwgdmFsdWVzXG4gICAgaWYgKCFoYXNWYWx1ZSkgeyB2YWx1ZSA9ICcnOyB9XG5cbiAgICAvLyB0ZXh0YXJlYSBhbmQgdGV4dCBub2RlcyBoYXZlIG5vIGF0dHJpYnV0ZSBuYW1lXG4gICAgaWYgKCFhdHRyTmFtZSkge1xuICAgICAgLy8gYWJvdXQgIzgxNSB3L28gcmVwbGFjZTogdGhlIGJyb3dzZXIgY29udmVydHMgdGhlIHZhbHVlIHRvIGEgc3RyaW5nLFxuICAgICAgLy8gdGhlIGNvbXBhcmlzb24gYnkgXCI9PVwiIGRvZXMgdG9vLCBidXQgbm90IGluIHRoZSBzZXJ2ZXJcbiAgICAgIHZhbHVlICs9ICcnO1xuICAgICAgLy8gdGVzdCBmb3IgcGFyZW50IGF2b2lkcyBlcnJvciB3aXRoIGludmFsaWQgYXNzaWdubWVudCB0byBub2RlVmFsdWVcbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgLy8gY2FjaGUgdGhlIHBhcmVudCBub2RlIGJlY2F1c2Ugc29tZWhvdyBpdCB3aWxsIGJlY29tZSBudWxsIG9uIElFXG4gICAgICAgIC8vIG9uIHRoZSBuZXh0IGl0ZXJhdGlvblxuICAgICAgICBleHByLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgaWYgKHBhcmVudC50YWdOYW1lID09PSAnVEVYVEFSRUEnKSB7XG4gICAgICAgICAgcGFyZW50LnZhbHVlID0gdmFsdWU7ICAgICAgICAgICAgICAgICAgICAvLyAjMTExM1xuICAgICAgICAgIGlmICghSUVfVkVSU0lPTikgeyBkb20ubm9kZVZhbHVlID0gdmFsdWU7IH0gIC8vICMxNjI1IElFIHRocm93cyBoZXJlLCBub2RlVmFsdWVcbiAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCBiZSBhdmFpbGFibGUgb24gJ3VwZGF0ZWQnXG4gICAgICAgIGVsc2UgeyBkb20ubm9kZVZhbHVlID0gdmFsdWU7IH1cbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuXG4gICAgLy8gZXZlbnQgaGFuZGxlclxuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgc2V0RXZlbnRIYW5kbGVyKGF0dHJOYW1lLCB2YWx1ZSwgZG9tLCB0aGlzKTtcbiAgICAvLyBzaG93IC8gaGlkZVxuICAgIH0gZWxzZSBpZiAoaXNUb2dnbGUpIHtcbiAgICAgIHRvZ2dsZVZpc2liaWxpdHkoZG9tLCBhdHRyTmFtZSA9PT0gSElERV9ESVJFQ1RJVkUgPyAhdmFsdWUgOiB2YWx1ZSk7XG4gICAgLy8gaGFuZGxlIGF0dHJpYnV0ZXNcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGV4cHIuYm9vbCkge1xuICAgICAgICBkb21bYXR0ck5hbWVdID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChhdHRyTmFtZSA9PT0gJ3ZhbHVlJyAmJiBkb20udmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgIGRvbS52YWx1ZSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChoYXNWYWx1ZSAmJiB2YWx1ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgc2V0QXR0cmlidXRlKGRvbSwgYXR0ck5hbWUsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgaW4gY2FzZSBvZiBzdHlsZSBjaGFuZ2VzXG4gICAgICAvLyB0aGUgZWxlbWVudCBzdGF5cyBoaWRkZW5cbiAgICAgIGlmIChpc1N0eWxlQXR0ciAmJiBkb20uaGlkZGVuKSB7IHRvZ2dsZVZpc2liaWxpdHkoZG9tLCBmYWxzZSk7IH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGFsbCB0aGUgZXhwcmVzc2lvbnMgaW4gYSBUYWcgaW5zdGFuY2VcbiAgICogQHRoaXMgVGFnXG4gICAqIEBwYXJhbSB7IEFycmF5IH0gZXhwcmVzc2lvbnMgLSBleHByZXNzaW9uIHRoYXQgbXVzdCBiZSByZSBldmFsdWF0ZWRcbiAgICovXG4gIGZ1bmN0aW9uIHVwZGF0ZShleHByZXNzaW9ucykge1xuICAgIGVhY2goZXhwcmVzc2lvbnMsIHVwZGF0ZUV4cHJlc3Npb24uYmluZCh0aGlzKSk7XG4gIH1cblxuICAvKipcbiAgICogV2UgbmVlZCB0byB1cGRhdGUgb3B0cyBmb3IgdGhpcyB0YWcuIFRoYXQgcmVxdWlyZXMgdXBkYXRpbmcgdGhlIGV4cHJlc3Npb25zXG4gICAqIGluIGFueSBhdHRyaWJ1dGVzIG9uIHRoZSB0YWcsIGFuZCB0aGVuIGNvcHlpbmcgdGhlIHJlc3VsdCBvbnRvIG9wdHMuXG4gICAqIEB0aGlzIFRhZ1xuICAgKiBAcGFyYW0gICB7Qm9vbGVhbn0gaXNMb29wIC0gaXMgaXQgYSBsb29wIHRhZz9cbiAgICogQHBhcmFtICAgeyBUYWcgfSAgcGFyZW50IC0gcGFyZW50IHRhZyBub2RlXG4gICAqIEBwYXJhbSAgIHsgQm9vbGVhbiB9ICBpc0Fub255bW91cyAtIGlzIGl0IGEgdGFnIHdpdGhvdXQgYW55IGltcGw/IChhIHRhZyBub3QgcmVnaXN0ZXJlZClcbiAgICogQHBhcmFtICAgeyBPYmplY3QgfSAgb3B0cyAtIHRhZyBvcHRpb25zXG4gICAqIEBwYXJhbSAgIHsgQXJyYXkgfSAgaW5zdEF0dHJzIC0gdGFnIGF0dHJpYnV0ZXMgYXJyYXlcbiAgICovXG4gIGZ1bmN0aW9uIHVwZGF0ZU9wdHMoaXNMb29wLCBwYXJlbnQsIGlzQW5vbnltb3VzLCBvcHRzLCBpbnN0QXR0cnMpIHtcbiAgICAvLyBpc0Fub255bW91cyBgZWFjaGAgdGFncyB0cmVhdCBgZG9tYCBhbmQgYHJvb3RgIGRpZmZlcmVudGx5LiBJbiB0aGlzIGNhc2VcbiAgICAvLyAoYW5kIG9ubHkgdGhpcyBjYXNlKSB3ZSBkb24ndCBuZWVkIHRvIGRvIHVwZGF0ZU9wdHMsIGJlY2F1c2UgdGhlIHJlZ3VsYXIgcGFyc2VcbiAgICAvLyB3aWxsIHVwZGF0ZSB0aG9zZSBhdHRycy4gUGx1cywgaXNBbm9ueW1vdXMgdGFncyBkb24ndCBuZWVkIG9wdHMgYW55d2F5XG4gICAgaWYgKGlzTG9vcCAmJiBpc0Fub255bW91cykgeyByZXR1cm4gfVxuICAgIHZhciBjdHggPSBpc0xvb3AgPyBpbmhlcml0UGFyZW50UHJvcHMuY2FsbCh0aGlzKSA6IHBhcmVudCB8fCB0aGlzO1xuXG4gICAgZWFjaChpbnN0QXR0cnMsIGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICBpZiAoYXR0ci5leHByKSB7IHVwZGF0ZUV4cHJlc3Npb24uY2FsbChjdHgsIGF0dHIuZXhwcik7IH1cbiAgICAgIC8vIG5vcm1hbGl6ZSB0aGUgYXR0cmlidXRlIG5hbWVzXG4gICAgICBvcHRzW3RvQ2FtZWwoYXR0ci5uYW1lKS5yZXBsYWNlKEFUVFJTX1BSRUZJWCwgJycpXSA9IGF0dHIuZXhwciA/IGF0dHIuZXhwci52YWx1ZSA6IGF0dHIudmFsdWU7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSB0YWcgZXhwcmVzc2lvbnMgYW5kIG9wdGlvbnNcbiAgICogQHBhcmFtIHsgVGFnIH0gdGFnIC0gdGFnIG9iamVjdFxuICAgKiBAcGFyYW0geyAqIH0gZGF0YSAtIGRhdGEgd2Ugd2FudCB0byB1c2UgdG8gZXh0ZW5kIHRoZSB0YWcgcHJvcGVydGllc1xuICAgKiBAcGFyYW0geyBBcnJheSB9IGV4cHJlc3Npb25zIC0gY29tcG9uZW50IGV4cHJlc3Npb25zIGFycmF5XG4gICAqIEByZXR1cm5zIHsgVGFnIH0gdGhlIGN1cnJlbnQgdGFnIGluc3RhbmNlXG4gICAqL1xuICBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGUodGFnLCBkYXRhLCBleHByZXNzaW9ucykge1xuICAgIHZhciBfXyA9IHRhZy5fXztcbiAgICB2YXIgbmV4dE9wdHMgPSB7fTtcbiAgICB2YXIgY2FuVHJpZ2dlciA9IHRhZy5pc01vdW50ZWQgJiYgIV9fLnNraXBBbm9ueW1vdXM7XG5cbiAgICAvLyBpbmhlcml0IHByb3BlcnRpZXMgZnJvbSB0aGUgcGFyZW50IHRhZ1xuICAgIGlmIChfXy5pc0Fub255bW91cyAmJiBfXy5wYXJlbnQpIHsgZXh0ZW5kKHRhZywgX18ucGFyZW50KTsgfVxuICAgIGV4dGVuZCh0YWcsIGRhdGEpO1xuXG4gICAgdXBkYXRlT3B0cy5hcHBseSh0YWcsIFtfXy5pc0xvb3AsIF9fLnBhcmVudCwgX18uaXNBbm9ueW1vdXMsIG5leHRPcHRzLCBfXy5pbnN0QXR0cnNdKTtcblxuICAgIGlmIChcbiAgICAgIGNhblRyaWdnZXIgJiZcbiAgICAgIHRhZy5pc01vdW50ZWQgJiZcbiAgICAgIGlzRnVuY3Rpb24odGFnLnNob3VsZFVwZGF0ZSkgJiYgIXRhZy5zaG91bGRVcGRhdGUoZGF0YSwgbmV4dE9wdHMpXG4gICAgKSB7XG4gICAgICByZXR1cm4gdGFnXG4gICAgfVxuXG4gICAgZXh0ZW5kKHRhZy5vcHRzLCBuZXh0T3B0cyk7XG5cbiAgICBpZiAoY2FuVHJpZ2dlcikgeyB0YWcudHJpZ2dlcigndXBkYXRlJywgZGF0YSk7IH1cbiAgICB1cGRhdGUuY2FsbCh0YWcsIGV4cHJlc3Npb25zKTtcbiAgICBpZiAoY2FuVHJpZ2dlcikgeyB0YWcudHJpZ2dlcigndXBkYXRlZCcpOyB9XG5cbiAgICByZXR1cm4gdGFnXG4gIH1cblxuICAvKipcbiAgICogR2V0IHNlbGVjdG9ycyBmb3IgdGFnc1xuICAgKiBAcGFyYW0gICB7IEFycmF5IH0gdGFncyAtIHRhZyBuYW1lcyB0byBzZWxlY3RcbiAgICogQHJldHVybnMgeyBTdHJpbmcgfSBzZWxlY3RvclxuICAgKi9cbiAgZnVuY3Rpb24gcXVlcnkodGFncykge1xuICAgIC8vIHNlbGVjdCBhbGwgdGFnc1xuICAgIGlmICghdGFncykge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhfX1RBR19JTVBMKTtcbiAgICAgIHJldHVybiBrZXlzICsgcXVlcnkoa2V5cylcbiAgICB9XG5cbiAgICByZXR1cm4gdGFnc1xuICAgICAgLmZpbHRlcihmdW5jdGlvbiAodCkgeyByZXR1cm4gIS9bXi1cXHddLy50ZXN0KHQpOyB9KVxuICAgICAgLnJlZHVjZShmdW5jdGlvbiAobGlzdCwgdCkge1xuICAgICAgICB2YXIgbmFtZSA9IHQudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBsaXN0ICsgXCIsW1wiICsgSVNfRElSRUNUSVZFICsgXCI9XFxcIlwiICsgbmFtZSArIFwiXFxcIl1cIlxuICAgICAgfSwgJycpXG4gIH1cblxuICAvKipcbiAgICogQW5vdGhlciB3YXkgdG8gY3JlYXRlIGEgcmlvdCB0YWcgYSBiaXQgbW9yZSBlczYgZnJpZW5kbHlcbiAgICogQHBhcmFtIHsgSFRNTEVsZW1lbnQgfSBlbCAtIHRhZyBET00gc2VsZWN0b3Igb3IgRE9NIG5vZGUvc1xuICAgKiBAcGFyYW0geyBPYmplY3QgfSBvcHRzIC0gdGFnIGxvZ2ljXG4gICAqIEByZXR1cm5zIHsgVGFnIH0gbmV3IHJpb3QgdGFnIGluc3RhbmNlXG4gICAqL1xuICBmdW5jdGlvbiBUYWcoZWwsIG9wdHMpIHtcbiAgICAvLyBnZXQgdGhlIHRhZyBwcm9wZXJ0aWVzIGZyb20gdGhlIGNsYXNzIGNvbnN0cnVjdG9yXG4gICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgdmFyIG5hbWUgPSByZWYubmFtZTtcbiAgICB2YXIgdG1wbCA9IHJlZi50bXBsO1xuICAgIHZhciBjc3MgPSByZWYuY3NzO1xuICAgIHZhciBhdHRycyA9IHJlZi5hdHRycztcbiAgICB2YXIgb25DcmVhdGUgPSByZWYub25DcmVhdGU7XG4gICAgLy8gcmVnaXN0ZXIgYSBuZXcgdGFnIGFuZCBjYWNoZSB0aGUgY2xhc3MgcHJvdG90eXBlXG4gICAgaWYgKCFfX1RBR19JTVBMW25hbWVdKSB7XG4gICAgICB0YWcobmFtZSwgdG1wbCwgY3NzLCBhdHRycywgb25DcmVhdGUpO1xuICAgICAgLy8gY2FjaGUgdGhlIGNsYXNzIGNvbnN0cnVjdG9yXG4gICAgICBfX1RBR19JTVBMW25hbWVdLmNsYXNzID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICB9XG5cbiAgICAvLyBtb3VudCB0aGUgdGFnIHVzaW5nIHRoZSBjbGFzcyBpbnN0YW5jZVxuICAgIG1vdW50JDEoZWwsIG5hbWUsIG9wdHMsIHRoaXMpO1xuICAgIC8vIGluamVjdCB0aGUgY29tcG9uZW50IGNzc1xuICAgIGlmIChjc3MpIHsgc3R5bGVNYW5hZ2VyLmluamVjdCgpOyB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyByaW90IHRhZyBpbXBsZW1lbnRhdGlvblxuICAgKiBAcGFyYW0gICB7IFN0cmluZyB9ICAgbmFtZSAtIG5hbWUvaWQgb2YgdGhlIG5ldyByaW90IHRhZ1xuICAgKiBAcGFyYW0gICB7IFN0cmluZyB9ICAgdG1wbCAtIHRhZyB0ZW1wbGF0ZVxuICAgKiBAcGFyYW0gICB7IFN0cmluZyB9ICAgY3NzIC0gY3VzdG9tIHRhZyBjc3NcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSAgIGF0dHJzIC0gcm9vdCB0YWcgYXR0cmlidXRlc1xuICAgKiBAcGFyYW0gICB7IEZ1bmN0aW9uIH0gZm4gLSB1c2VyIGZ1bmN0aW9uXG4gICAqIEByZXR1cm5zIHsgU3RyaW5nIH0gbmFtZS9pZCBvZiB0aGUgdGFnIGp1c3QgY3JlYXRlZFxuICAgKi9cbiAgZnVuY3Rpb24gdGFnKG5hbWUsIHRtcGwsIGNzcywgYXR0cnMsIGZuKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24oYXR0cnMpKSB7XG4gICAgICBmbiA9IGF0dHJzO1xuXG4gICAgICBpZiAoL15bXFx3LV0rXFxzPz0vLnRlc3QoY3NzKSkge1xuICAgICAgICBhdHRycyA9IGNzcztcbiAgICAgICAgY3NzID0gJyc7XG4gICAgICB9IGVsc2VcbiAgICAgICAgeyBhdHRycyA9ICcnOyB9XG4gICAgfVxuXG4gICAgaWYgKGNzcykge1xuICAgICAgaWYgKGlzRnVuY3Rpb24oY3NzKSlcbiAgICAgICAgeyBmbiA9IGNzczsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IHN0eWxlTWFuYWdlci5hZGQoY3NzLCBuYW1lKTsgfVxuICAgIH1cblxuICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgX19UQUdfSU1QTFtuYW1lXSA9IHsgbmFtZTogbmFtZSwgdG1wbDogdG1wbCwgYXR0cnM6IGF0dHJzLCBmbjogZm4gfTtcblxuICAgIHJldHVybiBuYW1lXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHJpb3QgdGFnIGltcGxlbWVudGF0aW9uIChmb3IgdXNlIGJ5IHRoZSBjb21waWxlcilcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSAgIG5hbWUgLSBuYW1lL2lkIG9mIHRoZSBuZXcgcmlvdCB0YWdcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSAgIHRtcGwgLSB0YWcgdGVtcGxhdGVcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSAgIGNzcyAtIGN1c3RvbSB0YWcgY3NzXG4gICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gICBhdHRycyAtIHJvb3QgdGFnIGF0dHJpYnV0ZXNcbiAgICogQHBhcmFtICAgeyBGdW5jdGlvbiB9IGZuIC0gdXNlciBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7IFN0cmluZyB9IG5hbWUvaWQgb2YgdGhlIHRhZyBqdXN0IGNyZWF0ZWRcbiAgICovXG4gIGZ1bmN0aW9uIHRhZzIobmFtZSwgdG1wbCwgY3NzLCBhdHRycywgZm4pIHtcbiAgICBpZiAoY3NzKSB7IHN0eWxlTWFuYWdlci5hZGQoY3NzLCBuYW1lKTsgfVxuXG4gICAgX19UQUdfSU1QTFtuYW1lXSA9IHsgbmFtZTogbmFtZSwgdG1wbDogdG1wbCwgYXR0cnM6IGF0dHJzLCBmbjogZm4gfTtcblxuICAgIHJldHVybiBuYW1lXG4gIH1cblxuICAvKipcbiAgICogTW91bnQgYSB0YWcgdXNpbmcgYSBzcGVjaWZpYyB0YWcgaW1wbGVtZW50YXRpb25cbiAgICogQHBhcmFtICAgeyAqIH0gc2VsZWN0b3IgLSB0YWcgRE9NIHNlbGVjdG9yIG9yIERPTSBub2RlL3NcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSB0YWdOYW1lIC0gdGFnIGltcGxlbWVudGF0aW9uIG5hbWVcbiAgICogQHBhcmFtICAgeyBPYmplY3QgfSBvcHRzIC0gdGFnIGxvZ2ljXG4gICAqIEByZXR1cm5zIHsgQXJyYXkgfSBuZXcgdGFncyBpbnN0YW5jZXNcbiAgICovXG4gIGZ1bmN0aW9uIG1vdW50KHNlbGVjdG9yLCB0YWdOYW1lLCBvcHRzKSB7XG4gICAgdmFyIHRhZ3MgPSBbXTtcbiAgICB2YXIgZWxlbSwgYWxsVGFncztcblxuICAgIGZ1bmN0aW9uIHB1c2hUYWdzVG8ocm9vdCkge1xuICAgICAgaWYgKHJvb3QudGFnTmFtZSkge1xuICAgICAgICB2YXIgcmlvdFRhZyA9IGdldEF0dHJpYnV0ZShyb290LCBJU19ESVJFQ1RJVkUpLCB0YWc7XG5cbiAgICAgICAgLy8gaGF2ZSB0YWdOYW1lPyBmb3JjZSByaW90LXRhZyB0byBiZSB0aGUgc2FtZVxuICAgICAgICBpZiAodGFnTmFtZSAmJiByaW90VGFnICE9PSB0YWdOYW1lKSB7XG4gICAgICAgICAgcmlvdFRhZyA9IHRhZ05hbWU7XG4gICAgICAgICAgc2V0QXR0cmlidXRlKHJvb3QsIElTX0RJUkVDVElWRSwgdGFnTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0YWcgPSBtb3VudCQxKHJvb3QsIHJpb3RUYWcgfHwgcm9vdC50YWdOYW1lLnRvTG93ZXJDYXNlKCksIG9wdHMpO1xuXG4gICAgICAgIGlmICh0YWcpXG4gICAgICAgICAgeyB0YWdzLnB1c2godGFnKTsgfVxuICAgICAgfSBlbHNlIGlmIChyb290Lmxlbmd0aClcbiAgICAgICAgeyBlYWNoKHJvb3QsIHB1c2hUYWdzVG8pOyB9IC8vIGFzc3VtZSBub2RlTGlzdFxuICAgIH1cblxuICAgIC8vIGluamVjdCBzdHlsZXMgaW50byBET01cbiAgICBzdHlsZU1hbmFnZXIuaW5qZWN0KCk7XG5cbiAgICBpZiAoaXNPYmplY3QodGFnTmFtZSkpIHtcbiAgICAgIG9wdHMgPSB0YWdOYW1lO1xuICAgICAgdGFnTmFtZSA9IDA7XG4gICAgfVxuXG4gICAgLy8gY3Jhd2wgdGhlIERPTSB0byBmaW5kIHRoZSB0YWdcbiAgICBpZiAoaXNTdHJpbmcoc2VsZWN0b3IpKSB7XG4gICAgICBzZWxlY3RvciA9IHNlbGVjdG9yID09PSAnKicgP1xuICAgICAgICAvLyBzZWxlY3QgYWxsIHJlZ2lzdGVyZWQgdGFnc1xuICAgICAgICAvLyAmIHRhZ3MgZm91bmQgd2l0aCB0aGUgcmlvdC10YWcgYXR0cmlidXRlIHNldFxuICAgICAgICBhbGxUYWdzID0gcXVlcnkoKSA6XG4gICAgICAgIC8vIG9yIGp1c3QgdGhlIG9uZXMgbmFtZWQgbGlrZSB0aGUgc2VsZWN0b3JcbiAgICAgICAgc2VsZWN0b3IgKyBxdWVyeShzZWxlY3Rvci5zcGxpdCgvLCAqLykpO1xuXG4gICAgICAvLyBtYWtlIHN1cmUgdG8gcGFzcyBhbHdheXMgYSBzZWxlY3RvclxuICAgICAgLy8gdG8gdGhlIHF1ZXJ5U2VsZWN0b3JBbGwgZnVuY3Rpb25cbiAgICAgIGVsZW0gPSBzZWxlY3RvciA/ICQkKHNlbGVjdG9yKSA6IFtdO1xuICAgIH1cbiAgICBlbHNlXG4gICAgICAvLyBwcm9iYWJseSB5b3UgaGF2ZSBwYXNzZWQgYWxyZWFkeSBhIHRhZyBvciBhIE5vZGVMaXN0XG4gICAgICB7IGVsZW0gPSBzZWxlY3RvcjsgfVxuXG4gICAgLy8gc2VsZWN0IGFsbCB0aGUgcmVnaXN0ZXJlZCBhbmQgbW91bnQgdGhlbSBpbnNpZGUgdGhlaXIgcm9vdCBlbGVtZW50c1xuICAgIGlmICh0YWdOYW1lID09PSAnKicpIHtcbiAgICAgIC8vIGdldCBhbGwgY3VzdG9tIHRhZ3NcbiAgICAgIHRhZ05hbWUgPSBhbGxUYWdzIHx8IHF1ZXJ5KCk7XG4gICAgICAvLyBpZiB0aGUgcm9vdCBlbHMgaXQncyBqdXN0IGEgc2luZ2xlIHRhZ1xuICAgICAgaWYgKGVsZW0udGFnTmFtZSlcbiAgICAgICAgeyBlbGVtID0gJCQodGFnTmFtZSwgZWxlbSk7IH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBzZWxlY3QgYWxsIHRoZSBjaGlsZHJlbiBmb3IgYWxsIHRoZSBkaWZmZXJlbnQgcm9vdCBlbGVtZW50c1xuICAgICAgICB2YXIgbm9kZUxpc3QgPSBbXTtcblxuICAgICAgICBlYWNoKGVsZW0sIGZ1bmN0aW9uIChfZWwpIHsgcmV0dXJuIG5vZGVMaXN0LnB1c2goJCQodGFnTmFtZSwgX2VsKSk7IH0pO1xuXG4gICAgICAgIGVsZW0gPSBub2RlTGlzdDtcbiAgICAgIH1cbiAgICAgIC8vIGdldCByaWQgb2YgdGhlIHRhZ05hbWVcbiAgICAgIHRhZ05hbWUgPSAwO1xuICAgIH1cblxuICAgIHB1c2hUYWdzVG8oZWxlbSk7XG5cbiAgICByZXR1cm4gdGFnc1xuICB9XG5cbiAgLy8gQ3JlYXRlIGEgbWl4aW4gdGhhdCBjb3VsZCBiZSBnbG9iYWxseSBzaGFyZWQgYWNyb3NzIGFsbCB0aGUgdGFnc1xuICB2YXIgbWl4aW5zID0ge307XG4gIHZhciBnbG9iYWxzID0gbWl4aW5zW0dMT0JBTF9NSVhJTl0gPSB7fTtcbiAgdmFyIG1peGluc19pZCA9IDA7XG5cbiAgLyoqXG4gICAqIENyZWF0ZS9SZXR1cm4gYSBtaXhpbiBieSBpdHMgbmFtZVxuICAgKiBAcGFyYW0gICB7IFN0cmluZyB9ICBuYW1lIC0gbWl4aW4gbmFtZSAoZ2xvYmFsIG1peGluIGlmIG9iamVjdClcbiAgICogQHBhcmFtICAgeyBPYmplY3QgfSAgbWl4IC0gbWl4aW4gbG9naWNcbiAgICogQHBhcmFtICAgeyBCb29sZWFuIH0gZyAtIGlzIGdsb2JhbD9cbiAgICogQHJldHVybnMgeyBPYmplY3QgfSAgdGhlIG1peGluIGxvZ2ljXG4gICAqL1xuICBmdW5jdGlvbiBtaXhpbihuYW1lLCBtaXgsIGcpIHtcbiAgICAvLyBVbm5hbWVkIGdsb2JhbFxuICAgIGlmIChpc09iamVjdChuYW1lKSkge1xuICAgICAgbWl4aW4oKFwiX19cIiArIChtaXhpbnNfaWQrKykgKyBcIl9fXCIpLCBuYW1lLCB0cnVlKTtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBzdG9yZSA9IGcgPyBnbG9iYWxzIDogbWl4aW5zO1xuXG4gICAgLy8gR2V0dGVyXG4gICAgaWYgKCFtaXgpIHtcbiAgICAgIGlmIChpc1VuZGVmaW5lZChzdG9yZVtuYW1lXSkpXG4gICAgICAgIHsgdGhyb3cgbmV3IEVycm9yKChcIlVucmVnaXN0ZXJlZCBtaXhpbjogXCIgKyBuYW1lKSkgfVxuXG4gICAgICByZXR1cm4gc3RvcmVbbmFtZV1cbiAgICB9XG5cbiAgICAvLyBTZXR0ZXJcbiAgICBzdG9yZVtuYW1lXSA9IGlzRnVuY3Rpb24obWl4KSA/XG4gICAgICBleHRlbmQobWl4LnByb3RvdHlwZSwgc3RvcmVbbmFtZV0gfHwge30pICYmIG1peCA6XG4gICAgICBleHRlbmQoc3RvcmVbbmFtZV0gfHwge30sIG1peCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGFsbCB0aGUgdGFncyBpbnN0YW5jZXMgY3JlYXRlZFxuICAgKiBAcmV0dXJucyB7IEFycmF5IH0gYWxsIHRoZSB0YWdzIGluc3RhbmNlc1xuICAgKi9cbiAgZnVuY3Rpb24gdXBkYXRlJDEoKSB7XG4gICAgcmV0dXJuIGVhY2goX19UQUdTX0NBQ0hFLCBmdW5jdGlvbiAodGFnKSB7IHJldHVybiB0YWcudXBkYXRlKCk7IH0pXG4gIH1cblxuICBmdW5jdGlvbiB1bnJlZ2lzdGVyKG5hbWUpIHtcbiAgICBzdHlsZU1hbmFnZXIucmVtb3ZlKG5hbWUpO1xuICAgIHJldHVybiBkZWxldGUgX19UQUdfSU1QTFtuYW1lXVxuICB9XG5cbiAgdmFyIHZlcnNpb24gPSAndjMuOS40JztcblxuICB2YXIgY29yZSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBUYWc6IFRhZyxcbiAgICB0YWc6IHRhZyxcbiAgICB0YWcyOiB0YWcyLFxuICAgIG1vdW50OiBtb3VudCxcbiAgICBtaXhpbjogbWl4aW4sXG4gICAgdXBkYXRlOiB1cGRhdGUkMSxcbiAgICB1bnJlZ2lzdGVyOiB1bnJlZ2lzdGVyLFxuICAgIHZlcnNpb246IHZlcnNpb25cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEFkZCBhIG1peGluIHRvIHRoaXMgdGFnXG4gICAqIEByZXR1cm5zIHsgVGFnIH0gdGhlIGN1cnJlbnQgdGFnIGluc3RhbmNlXG4gICAqL1xuICBmdW5jdGlvbiBjb21wb25lbnRNaXhpbih0YWckJDEpIHtcbiAgICB2YXIgbWl4aW5zID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICAgIHdoaWxlICggbGVuLS0gPiAwICkgbWl4aW5zWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXG4gICAgZWFjaChtaXhpbnMsIGZ1bmN0aW9uIChtaXgpIHtcbiAgICAgIHZhciBpbnN0YW5jZTtcbiAgICAgIHZhciBvYmo7XG4gICAgICB2YXIgcHJvcHMgPSBbXTtcblxuICAgICAgLy8gcHJvcGVydGllcyBibGFja2xpc3RlZCBhbmQgd2lsbCBub3QgYmUgYm91bmQgdG8gdGhlIHRhZyBpbnN0YW5jZVxuICAgICAgdmFyIHByb3BzQmxhY2tsaXN0ID0gWydpbml0JywgJ19fcHJvdG9fXyddO1xuXG4gICAgICBtaXggPSBpc1N0cmluZyhtaXgpID8gbWl4aW4obWl4KSA6IG1peDtcblxuICAgICAgLy8gY2hlY2sgaWYgdGhlIG1peGluIGlzIGEgZnVuY3Rpb25cbiAgICAgIGlmIChpc0Z1bmN0aW9uKG1peCkpIHtcbiAgICAgICAgLy8gY3JlYXRlIHRoZSBuZXcgbWl4aW4gaW5zdGFuY2VcbiAgICAgICAgaW5zdGFuY2UgPSBuZXcgbWl4KCk7XG4gICAgICB9IGVsc2UgeyBpbnN0YW5jZSA9IG1peDsgfVxuXG4gICAgICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5zdGFuY2UpO1xuXG4gICAgICAvLyBidWlsZCBtdWx0aWxldmVsIHByb3RvdHlwZSBpbmhlcml0YW5jZSBjaGFpbiBwcm9wZXJ0eSBsaXN0XG4gICAgICBkbyB7IHByb3BzID0gcHJvcHMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaiB8fCBpbnN0YW5jZSkpOyB9XG4gICAgICB3aGlsZSAob2JqID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaiB8fCBpbnN0YW5jZSkpXG5cbiAgICAgIC8vIGxvb3AgdGhlIGtleXMgaW4gdGhlIGZ1bmN0aW9uIHByb3RvdHlwZSBvciB0aGUgYWxsIG9iamVjdCBrZXlzXG4gICAgICBlYWNoKHByb3BzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIC8vIGJpbmQgbWV0aG9kcyB0byB0YWdcbiAgICAgICAgLy8gYWxsb3cgbWl4aW5zIHRvIG92ZXJyaWRlIG90aGVyIHByb3BlcnRpZXMvcGFyZW50IG1peGluc1xuICAgICAgICBpZiAoIWNvbnRhaW5zKHByb3BzQmxhY2tsaXN0LCBrZXkpKSB7XG4gICAgICAgICAgLy8gY2hlY2sgZm9yIGdldHRlcnMvc2V0dGVyc1xuICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gZ2V0UHJvcERlc2NyaXB0b3IoaW5zdGFuY2UsIGtleSkgfHwgZ2V0UHJvcERlc2NyaXB0b3IocHJvdG8sIGtleSk7XG4gICAgICAgICAgdmFyIGhhc0dldHRlclNldHRlciA9IGRlc2NyaXB0b3IgJiYgKGRlc2NyaXB0b3IuZ2V0IHx8IGRlc2NyaXB0b3Iuc2V0KTtcblxuICAgICAgICAgIC8vIGFwcGx5IG1ldGhvZCBvbmx5IGlmIGl0IGRvZXMgbm90IGFscmVhZHkgZXhpc3Qgb24gdGhlIGluc3RhbmNlXG4gICAgICAgICAgaWYgKCF0YWckJDEuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBoYXNHZXR0ZXJTZXR0ZXIpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YWckJDEsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhZyQkMVtrZXldID0gaXNGdW5jdGlvbihpbnN0YW5jZVtrZXldKSA/XG4gICAgICAgICAgICAgIGluc3RhbmNlW2tleV0uYmluZCh0YWckJDEpIDpcbiAgICAgICAgICAgICAgaW5zdGFuY2Vba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBpbml0IG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBhdXRvbWF0aWNhbGx5XG4gICAgICBpZiAoaW5zdGFuY2UuaW5pdClcbiAgICAgICAgeyBpbnN0YW5jZS5pbml0LmJpbmQodGFnJCQxKSh0YWckJDEub3B0cyk7IH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0YWckJDFcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlIHRoZSBwb3NpdGlvbiBvZiBhIGN1c3RvbSB0YWcgaW4gaXRzIHBhcmVudCB0YWdcbiAgICogQHRoaXMgVGFnXG4gICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gdGFnTmFtZSAtIGtleSB3aGVyZSB0aGUgdGFnIHdhcyBzdG9yZWRcbiAgICogQHBhcmFtICAgeyBOdW1iZXIgfSBuZXdQb3MgLSBpbmRleCB3aGVyZSB0aGUgbmV3IHRhZyB3aWxsIGJlIHN0b3JlZFxuICAgKi9cbiAgZnVuY3Rpb24gbW92ZUNoaWxkKHRhZ05hbWUsIG5ld1Bvcykge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICB2YXIgdGFncztcbiAgICAvLyBubyBwYXJlbnQgbm8gbW92ZVxuICAgIGlmICghcGFyZW50KSB7IHJldHVybiB9XG5cbiAgICB0YWdzID0gcGFyZW50LnRhZ3NbdGFnTmFtZV07XG5cbiAgICBpZiAoaXNBcnJheSh0YWdzKSlcbiAgICAgIHsgdGFncy5zcGxpY2UobmV3UG9zLCAwLCB0YWdzLnNwbGljZSh0YWdzLmluZGV4T2YodGhpcyksIDEpWzBdKTsgfVxuICAgIGVsc2UgeyBhcnJheWlzaEFkZChwYXJlbnQudGFncywgdGFnTmFtZSwgdGhpcyk7IH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlIHZpcnR1YWwgdGFnIGFuZCBhbGwgY2hpbGQgbm9kZXNcbiAgICogQHRoaXMgVGFnXG4gICAqIEBwYXJhbSB7IE5vZGUgfSBzcmMgIC0gdGhlIG5vZGUgdGhhdCB3aWxsIGRvIHRoZSBpbnNlcnRpbmdcbiAgICogQHBhcmFtIHsgVGFnIH0gdGFyZ2V0IC0gaW5zZXJ0IGJlZm9yZSB0aGlzIHRhZydzIGZpcnN0IGNoaWxkXG4gICAqL1xuICBmdW5jdGlvbiBtb3ZlVmlydHVhbChzcmMsIHRhcmdldCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGVsID0gdGhpcy5fXy5oZWFkO1xuICAgIHZhciBzaWI7XG4gICAgdmFyIGZyYWcgPSBjcmVhdGVGcmFnbWVudCgpO1xuXG4gICAgd2hpbGUgKGVsKSB7XG4gICAgICBzaWIgPSBlbC5uZXh0U2libGluZztcbiAgICAgIGZyYWcuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgZWwgPSBzaWI7XG4gICAgICBpZiAoZWwgPT09IHRoaXMkMS5fXy50YWlsKSB7XG4gICAgICAgIGZyYWcuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICBzcmMuaW5zZXJ0QmVmb3JlKGZyYWcsIHRhcmdldC5fXy5oZWFkKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCB0aGUgaXRlbSBsb29wZWQgaW50byBhbiBvYmplY3QgdXNlZCB0byBleHRlbmQgdGhlIGNoaWxkIHRhZyBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gZXhwciAtIG9iamVjdCBjb250YWluaW5nIHRoZSBrZXlzIHVzZWQgdG8gZXh0ZW5kIHRoZSBjaGlsZHJlbiB0YWdzXG4gICAqIEBwYXJhbSAgIHsgKiB9IGtleSAtIHZhbHVlIHRvIGFzc2lnbiB0byB0aGUgbmV3IG9iamVjdCByZXR1cm5lZFxuICAgKiBAcGFyYW0gICB7ICogfSB2YWwgLSB2YWx1ZSBjb250YWluaW5nIHRoZSBwb3NpdGlvbiBvZiB0aGUgaXRlbSBpbiB0aGUgYXJyYXlcbiAgICogQHJldHVybnMgeyBPYmplY3QgfSAtIG5ldyBvYmplY3QgY29udGFpbmluZyB0aGUgdmFsdWVzIG9mIHRoZSBvcmlnaW5hbCBpdGVtXG4gICAqXG4gICAqIFRoZSB2YXJpYWJsZXMgJ2tleScgYW5kICd2YWwnIGFyZSBhcmJpdHJhcnkuXG4gICAqIFRoZXkgZGVwZW5kIG9uIHRoZSBjb2xsZWN0aW9uIHR5cGUgbG9vcGVkIChBcnJheSwgT2JqZWN0KVxuICAgKiBhbmQgb24gdGhlIGV4cHJlc3Npb24gdXNlZCBvbiB0aGUgZWFjaCB0YWdcbiAgICpcbiAgICovXG4gIGZ1bmN0aW9uIG1raXRlbShleHByLCBrZXksIHZhbCkge1xuICAgIHZhciBpdGVtID0ge307XG4gICAgaXRlbVtleHByLmtleV0gPSBrZXk7XG4gICAgaWYgKGV4cHIucG9zKSB7IGl0ZW1bZXhwci5wb3NdID0gdmFsOyB9XG4gICAgcmV0dXJuIGl0ZW1cbiAgfVxuXG4gIC8qKlxuICAgKiBVbm1vdW50IHRoZSByZWR1bmRhbnQgdGFnc1xuICAgKiBAcGFyYW0gICB7IEFycmF5IH0gaXRlbXMgLSBhcnJheSBjb250YWluaW5nIHRoZSBjdXJyZW50IGl0ZW1zIHRvIGxvb3BcbiAgICogQHBhcmFtICAgeyBBcnJheSB9IHRhZ3MgLSBhcnJheSBjb250YWluaW5nIGFsbCB0aGUgY2hpbGRyZW4gdGFnc1xuICAgKi9cbiAgZnVuY3Rpb24gdW5tb3VudFJlZHVuZGFudChpdGVtcywgdGFncywgZmlsdGVyZWRJdGVtc0NvdW50KSB7XG4gICAgdmFyIGkgPSB0YWdzLmxlbmd0aDtcbiAgICB2YXIgaiA9IGl0ZW1zLmxlbmd0aCAtIGZpbHRlcmVkSXRlbXNDb3VudDtcblxuICAgIHdoaWxlIChpID4gaikge1xuICAgICAgaS0tO1xuICAgICAgcmVtb3ZlLmFwcGx5KHRhZ3NbaV0sIFt0YWdzLCBpXSk7XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogUmVtb3ZlIGEgY2hpbGQgdGFnXG4gICAqIEB0aGlzIFRhZ1xuICAgKiBAcGFyYW0gICB7IEFycmF5IH0gdGFncyAtIHRhZ3MgY29sbGVjdGlvblxuICAgKiBAcGFyYW0gICB7IE51bWJlciB9IGkgLSBpbmRleCBvZiB0aGUgdGFnIHRvIHJlbW92ZVxuICAgKi9cbiAgZnVuY3Rpb24gcmVtb3ZlKHRhZ3MsIGkpIHtcbiAgICB0YWdzLnNwbGljZShpLCAxKTtcbiAgICB0aGlzLnVubW91bnQoKTtcbiAgICBhcnJheWlzaFJlbW92ZSh0aGlzLnBhcmVudCwgdGhpcywgdGhpcy5fXy50YWdOYW1lLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlIHRoZSBuZXN0ZWQgY3VzdG9tIHRhZ3MgaW4gbm9uIGN1c3RvbSBsb29wIHRhZ3NcbiAgICogQHRoaXMgVGFnXG4gICAqIEBwYXJhbSAgIHsgTnVtYmVyIH0gaSAtIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIGxvb3AgdGFnXG4gICAqL1xuICBmdW5jdGlvbiBtb3ZlTmVzdGVkVGFncyhpKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBlYWNoKE9iamVjdC5rZXlzKHRoaXMudGFncyksIGZ1bmN0aW9uICh0YWdOYW1lKSB7XG4gICAgICBtb3ZlQ2hpbGQuYXBwbHkodGhpcyQxLnRhZ3NbdGFnTmFtZV0sIFt0YWdOYW1lLCBpXSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTW92ZSBhIGNoaWxkIHRhZ1xuICAgKiBAdGhpcyBUYWdcbiAgICogQHBhcmFtICAgeyBIVE1MRWxlbWVudCB9IHJvb3QgLSBkb20gbm9kZSBjb250YWluaW5nIGFsbCB0aGUgbG9vcCBjaGlsZHJlblxuICAgKiBAcGFyYW0gICB7IFRhZyB9IG5leHRUYWcgLSBpbnN0YW5jZSBvZiB0aGUgbmV4dCB0YWcgcHJlY2VkaW5nIHRoZSBvbmUgd2Ugd2FudCB0byBtb3ZlXG4gICAqIEBwYXJhbSAgIHsgQm9vbGVhbiB9IGlzVmlydHVhbCAtIGlzIGl0IGEgdmlydHVhbCB0YWc/XG4gICAqL1xuICBmdW5jdGlvbiBtb3ZlKHJvb3QsIG5leHRUYWcsIGlzVmlydHVhbCkge1xuICAgIGlmIChpc1ZpcnR1YWwpXG4gICAgICB7IG1vdmVWaXJ0dWFsLmFwcGx5KHRoaXMsIFtyb290LCBuZXh0VGFnXSk7IH1cbiAgICBlbHNlXG4gICAgICB7IHNhZmVJbnNlcnQocm9vdCwgdGhpcy5yb290LCBuZXh0VGFnLnJvb3QpOyB9XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0IGFuZCBtb3VudCBhIGNoaWxkIHRhZ1xuICAgKiBAdGhpcyBUYWdcbiAgICogQHBhcmFtICAgeyBIVE1MRWxlbWVudCB9IHJvb3QgLSBkb20gbm9kZSBjb250YWluaW5nIGFsbCB0aGUgbG9vcCBjaGlsZHJlblxuICAgKiBAcGFyYW0gICB7IFRhZyB9IG5leHRUYWcgLSBpbnN0YW5jZSBvZiB0aGUgbmV4dCB0YWcgcHJlY2VkaW5nIHRoZSBvbmUgd2Ugd2FudCB0byBpbnNlcnRcbiAgICogQHBhcmFtICAgeyBCb29sZWFuIH0gaXNWaXJ0dWFsIC0gaXMgaXQgYSB2aXJ0dWFsIHRhZz9cbiAgICovXG4gIGZ1bmN0aW9uIGluc2VydChyb290LCBuZXh0VGFnLCBpc1ZpcnR1YWwpIHtcbiAgICBpZiAoaXNWaXJ0dWFsKVxuICAgICAgeyBtYWtlVmlydHVhbC5hcHBseSh0aGlzLCBbcm9vdCwgbmV4dFRhZ10pOyB9XG4gICAgZWxzZVxuICAgICAgeyBzYWZlSW5zZXJ0KHJvb3QsIHRoaXMucm9vdCwgbmV4dFRhZy5yb290KTsgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZCBhIG5ldyB0YWcgaW50byB0aGUgRE9NXG4gICAqIEB0aGlzIFRhZ1xuICAgKiBAcGFyYW0gICB7IEhUTUxFbGVtZW50IH0gcm9vdCAtIGRvbSBub2RlIGNvbnRhaW5pbmcgYWxsIHRoZSBsb29wIGNoaWxkcmVuXG4gICAqIEBwYXJhbSAgIHsgQm9vbGVhbiB9IGlzVmlydHVhbCAtIGlzIGl0IGEgdmlydHVhbCB0YWc/XG4gICAqL1xuICBmdW5jdGlvbiBhcHBlbmQocm9vdCwgaXNWaXJ0dWFsKSB7XG4gICAgaWYgKGlzVmlydHVhbClcbiAgICAgIHsgbWFrZVZpcnR1YWwuY2FsbCh0aGlzLCByb290KTsgfVxuICAgIGVsc2VcbiAgICAgIHsgcm9vdC5hcHBlbmRDaGlsZCh0aGlzLnJvb3QpOyB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB2YWx1ZSB3ZSB3YW50IHRvIHVzZSB0byBsb29rdXAgdGhlIHBvc3Rpb24gb2Ygb3VyIGl0ZW1zIGluIHRoZSBjb2xsZWN0aW9uXG4gICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gIGtleUF0dHIgICAgICAgICAtIGxvb2t1cCBzdHJpbmcgb3IgZXhwcmVzc2lvblxuICAgKiBAcGFyYW0gICB7ICogfSAgICAgICBvcmlnaW5hbEl0ZW0gICAgLSBvcmlnaW5hbCBpdGVtIGZyb20gdGhlIGNvbGxlY3Rpb25cbiAgICogQHBhcmFtICAgeyBPYmplY3QgfSAga2V5ZWRJdGVtICAgICAgIC0gb2JqZWN0IGNyZWF0ZWQgYnkgcmlvdCB2aWEgeyBpdGVtLCBpIGluIGNvbGxlY3Rpb24gfVxuICAgKiBAcGFyYW0gICB7IEJvb2xlYW4gfSBoYXNLZXlBdHRyRXhwciAgLSBmbGFnIHRvIGNoZWNrIHdoZXRoZXIgdGhlIGtleSBpcyBhbiBleHByZXNzaW9uXG4gICAqIEByZXR1cm5zIHsgKiB9IHZhbHVlIHRoYXQgd2Ugd2lsbCB1c2UgdG8gZmlndXJlIG91dCB0aGUgaXRlbSBwb3NpdGlvbiB2aWEgY29sbGVjdGlvbi5pbmRleE9mXG4gICAqL1xuICBmdW5jdGlvbiBnZXRJdGVtSWQoa2V5QXR0ciwgb3JpZ2luYWxJdGVtLCBrZXllZEl0ZW0sIGhhc0tleUF0dHJFeHByKSB7XG4gICAgaWYgKGtleUF0dHIpIHtcbiAgICAgIHJldHVybiBoYXNLZXlBdHRyRXhwciA/ICB0bXBsKGtleUF0dHIsIGtleWVkSXRlbSkgOiAgb3JpZ2luYWxJdGVtW2tleUF0dHJdXG4gICAgfVxuXG4gICAgcmV0dXJuIG9yaWdpbmFsSXRlbVxuICB9XG5cbiAgLyoqXG4gICAqIE1hbmFnZSB0YWdzIGhhdmluZyB0aGUgJ2VhY2gnXG4gICAqIEBwYXJhbSAgIHsgSFRNTEVsZW1lbnQgfSBkb20gLSBET00gbm9kZSB3ZSBuZWVkIHRvIGxvb3BcbiAgICogQHBhcmFtICAgeyBUYWcgfSBwYXJlbnQgLSBwYXJlbnQgdGFnIGluc3RhbmNlIHdoZXJlIHRoZSBkb20gbm9kZSBpcyBjb250YWluZWRcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSBleHByIC0gc3RyaW5nIGNvbnRhaW5lZCBpbiB0aGUgJ2VhY2gnIGF0dHJpYnV0ZVxuICAgKiBAcmV0dXJucyB7IE9iamVjdCB9IGV4cHJlc3Npb24gb2JqZWN0IGZvciB0aGlzIGVhY2ggbG9vcFxuICAgKi9cbiAgZnVuY3Rpb24gX2VhY2goZG9tLCBwYXJlbnQsIGV4cHIpIHtcbiAgICB2YXIgbXVzdFJlb3JkZXIgPSB0eXBlb2YgZ2V0QXR0cmlidXRlKGRvbSwgTE9PUF9OT19SRU9SREVSX0RJUkVDVElWRSkgIT09IFRfU1RSSU5HIHx8IHJlbW92ZUF0dHJpYnV0ZShkb20sIExPT1BfTk9fUkVPUkRFUl9ESVJFQ1RJVkUpO1xuICAgIHZhciBrZXlBdHRyID0gZ2V0QXR0cmlidXRlKGRvbSwgS0VZX0RJUkVDVElWRSk7XG4gICAgdmFyIGhhc0tleUF0dHJFeHByID0ga2V5QXR0ciA/IHRtcGwuaGFzRXhwcihrZXlBdHRyKSA6IGZhbHNlO1xuICAgIHZhciB0YWdOYW1lID0gZ2V0TmFtZShkb20pO1xuICAgIHZhciBpbXBsID0gX19UQUdfSU1QTFt0YWdOYW1lXTtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IGRvbS5wYXJlbnROb2RlO1xuICAgIHZhciBwbGFjZWhvbGRlciA9IGNyZWF0ZURPTVBsYWNlaG9sZGVyKCk7XG4gICAgdmFyIGNoaWxkID0gZ2V0KGRvbSk7XG4gICAgdmFyIGlmRXhwciA9IGdldEF0dHJpYnV0ZShkb20sIENPTkRJVElPTkFMX0RJUkVDVElWRSk7XG4gICAgdmFyIHRhZ3MgPSBbXTtcbiAgICB2YXIgaXNMb29wID0gdHJ1ZTtcbiAgICB2YXIgaW5uZXJIVE1MID0gZG9tLmlubmVySFRNTDtcbiAgICB2YXIgaXNBbm9ueW1vdXMgPSAhX19UQUdfSU1QTFt0YWdOYW1lXTtcbiAgICB2YXIgaXNWaXJ0dWFsID0gZG9tLnRhZ05hbWUgPT09ICdWSVJUVUFMJztcbiAgICB2YXIgb2xkSXRlbXMgPSBbXTtcbiAgICB2YXIgaGFzS2V5cztcblxuICAgIC8vIHJlbW92ZSB0aGUgZWFjaCBwcm9wZXJ0eSBmcm9tIHRoZSBvcmlnaW5hbCB0YWdcbiAgICByZW1vdmVBdHRyaWJ1dGUoZG9tLCBMT09QX0RJUkVDVElWRSk7XG4gICAgcmVtb3ZlQXR0cmlidXRlKGRvbSwgS0VZX0RJUkVDVElWRSk7XG5cbiAgICAvLyBwYXJzZSB0aGUgZWFjaCBleHByZXNzaW9uXG4gICAgZXhwciA9IHRtcGwubG9vcEtleXMoZXhwcik7XG4gICAgZXhwci5pc0xvb3AgPSB0cnVlO1xuXG4gICAgaWYgKGlmRXhwcikgeyByZW1vdmVBdHRyaWJ1dGUoZG9tLCBDT05ESVRJT05BTF9ESVJFQ1RJVkUpOyB9XG5cbiAgICAvLyBpbnNlcnQgYSBtYXJrZWQgd2hlcmUgdGhlIGxvb3AgdGFncyB3aWxsIGJlIGluamVjdGVkXG4gICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUocGxhY2Vob2xkZXIsIGRvbSk7XG4gICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkb20pO1xuXG4gICAgZXhwci51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGVFYWNoKCkge1xuICAgICAgLy8gZ2V0IHRoZSBuZXcgaXRlbXMgY29sbGVjdGlvblxuICAgICAgZXhwci52YWx1ZSA9IHRtcGwoZXhwci52YWwsIHBhcmVudCk7XG5cbiAgICAgIHZhciBpdGVtcyA9IGV4cHIudmFsdWU7XG4gICAgICB2YXIgZnJhZyA9IGNyZWF0ZUZyYWdtZW50KCk7XG4gICAgICB2YXIgaXNPYmplY3QgPSAhaXNBcnJheShpdGVtcykgJiYgIWlzU3RyaW5nKGl0ZW1zKTtcbiAgICAgIHZhciByb290ID0gcGxhY2Vob2xkZXIucGFyZW50Tm9kZTtcbiAgICAgIHZhciB0bXBJdGVtcyA9IFtdO1xuXG4gICAgICAvLyBpZiB0aGlzIERPTSB3YXMgcmVtb3ZlZCB0aGUgdXBkYXRlIGhlcmUgaXMgdXNlbGVzc1xuICAgICAgLy8gdGhpcyBjb25kaXRpb24gZml4ZXMgYWxzbyBhIHdlaXJkIGFzeW5jIGlzc3VlIG9uIElFIGluIG91ciB1bml0IHRlc3RcbiAgICAgIGlmICghcm9vdCkgeyByZXR1cm4gfVxuXG4gICAgICAvLyBvYmplY3QgbG9vcC4gYW55IGNoYW5nZXMgY2F1c2UgZnVsbCByZWRyYXdcbiAgICAgIGlmIChpc09iamVjdCkge1xuICAgICAgICBoYXNLZXlzID0gaXRlbXMgfHwgZmFsc2U7XG4gICAgICAgIGl0ZW1zID0gaGFzS2V5cyA/XG4gICAgICAgICAgT2JqZWN0LmtleXMoaXRlbXMpLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBta2l0ZW0oZXhwciwgaXRlbXNba2V5XSwga2V5KTsgfSkgOiBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhc0tleXMgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gc3RvcmUgdGhlIGFtb3VudCBvZiBmaWx0ZXJlZCBpdGVtc1xuICAgICAgdmFyIGZpbHRlcmVkSXRlbXNDb3VudCA9IDA7XG5cbiAgICAgIC8vIGxvb3AgYWxsIHRoZSBuZXcgaXRlbXNcbiAgICAgIGVhY2goaXRlbXMsIGZ1bmN0aW9uIChfaXRlbSwgaSkge1xuICAgICAgICBpIC09IGZpbHRlcmVkSXRlbXNDb3VudDtcblxuICAgICAgICB2YXIgaXRlbSA9ICFoYXNLZXlzICYmIGV4cHIua2V5ID8gbWtpdGVtKGV4cHIsIF9pdGVtLCBpKSA6IF9pdGVtO1xuXG4gICAgICAgIC8vIHNraXAgdGhpcyBpdGVtIGJlY2F1c2UgaXQgbXVzdCBiZSBmaWx0ZXJlZFxuICAgICAgICBpZiAoaWZFeHByICYmICF0bXBsKGlmRXhwciwgZXh0ZW5kKGNyZWF0ZShwYXJlbnQpLCBpdGVtKSkpIHtcbiAgICAgICAgICBmaWx0ZXJlZEl0ZW1zQ291bnQgKys7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlbUlkID0gZ2V0SXRlbUlkKGtleUF0dHIsIF9pdGVtLCBpdGVtLCBoYXNLZXlBdHRyRXhwcik7XG4gICAgICAgIC8vIHJlb3JkZXIgb25seSBpZiB0aGUgaXRlbXMgYXJlIG9iamVjdHNcbiAgICAgICAgdmFyIGRvUmVvcmRlciA9IG11c3RSZW9yZGVyICYmIHR5cGVvZiBfaXRlbSA9PT0gVF9PQkpFQ1QgJiYgIWhhc0tleXM7XG4gICAgICAgIHZhciBvbGRQb3MgPSBvbGRJdGVtcy5pbmRleE9mKGl0ZW1JZCk7XG4gICAgICAgIHZhciBpc05ldyA9IG9sZFBvcyA9PT0gLTE7XG4gICAgICAgIHZhciBwb3MgPSAhaXNOZXcgJiYgZG9SZW9yZGVyID8gb2xkUG9zIDogaTtcbiAgICAgICAgLy8gZG9lcyBhIHRhZyBleGlzdCBpbiB0aGlzIHBvc2l0aW9uP1xuICAgICAgICB2YXIgdGFnID0gdGFnc1twb3NdO1xuICAgICAgICB2YXIgbXVzdEFwcGVuZCA9IGkgPj0gb2xkSXRlbXMubGVuZ3RoO1xuICAgICAgICB2YXIgbXVzdENyZWF0ZSA9ICBkb1Jlb3JkZXIgJiYgaXNOZXcgfHwgIWRvUmVvcmRlciAmJiAhdGFnO1xuXG4gICAgICAgIC8vIG5ldyB0YWdcbiAgICAgICAgaWYgKG11c3RDcmVhdGUpIHtcbiAgICAgICAgICB0YWcgPSBjcmVhdGVUYWcoaW1wbCwge1xuICAgICAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgICAgICBpc0xvb3A6IGlzTG9vcCxcbiAgICAgICAgICAgIGlzQW5vbnltb3VzOiBpc0Fub255bW91cyxcbiAgICAgICAgICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgICAgICAgICByb290OiBkb20uY2xvbmVOb2RlKGlzQW5vbnltb3VzKSxcbiAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICB9LCBpbm5lckhUTUwpO1xuXG4gICAgICAgICAgLy8gbW91bnQgdGhlIHRhZ1xuICAgICAgICAgIHRhZy5tb3VudCgpO1xuXG4gICAgICAgICAgaWYgKG11c3RBcHBlbmQpXG4gICAgICAgICAgICB7IGFwcGVuZC5hcHBseSh0YWcsIFtmcmFnIHx8IHJvb3QsIGlzVmlydHVhbF0pOyB9XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgeyBpbnNlcnQuYXBwbHkodGFnLCBbcm9vdCwgdGFnc1tpXSwgaXNWaXJ0dWFsXSk7IH1cblxuICAgICAgICAgIGlmICghbXVzdEFwcGVuZCkgeyBvbGRJdGVtcy5zcGxpY2UoaSwgMCwgaXRlbSk7IH1cbiAgICAgICAgICB0YWdzLnNwbGljZShpLCAwLCB0YWcpO1xuICAgICAgICAgIGlmIChjaGlsZCkgeyBhcnJheWlzaEFkZChwYXJlbnQudGFncywgdGFnTmFtZSwgdGFnLCB0cnVlKTsgfVxuICAgICAgICB9IGVsc2UgaWYgKHBvcyAhPT0gaSAmJiBkb1Jlb3JkZXIpIHtcbiAgICAgICAgICAvLyBtb3ZlXG4gICAgICAgICAgaWYgKGtleUF0dHIgfHwgY29udGFpbnMoaXRlbXMsIG9sZEl0ZW1zW3Bvc10pKSB7XG4gICAgICAgICAgICBtb3ZlLmFwcGx5KHRhZywgW3Jvb3QsIHRhZ3NbaV0sIGlzVmlydHVhbF0pO1xuICAgICAgICAgICAgLy8gbW92ZSB0aGUgb2xkIHRhZyBpbnN0YW5jZVxuICAgICAgICAgICAgdGFncy5zcGxpY2UoaSwgMCwgdGFncy5zcGxpY2UocG9zLCAxKVswXSk7XG4gICAgICAgICAgICAvLyBtb3ZlIHRoZSBvbGQgaXRlbVxuICAgICAgICAgICAgb2xkSXRlbXMuc3BsaWNlKGksIDAsIG9sZEl0ZW1zLnNwbGljZShwb3MsIDEpWzBdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB1cGRhdGUgdGhlIHBvc2l0aW9uIGF0dHJpYnV0ZSBpZiBpdCBleGlzdHNcbiAgICAgICAgICBpZiAoZXhwci5wb3MpIHsgdGFnW2V4cHIucG9zXSA9IGk7IH1cblxuICAgICAgICAgIC8vIGlmIHRoZSBsb29wIHRhZ3MgYXJlIG5vdCBjdXN0b21cbiAgICAgICAgICAvLyB3ZSBuZWVkIHRvIG1vdmUgYWxsIHRoZWlyIGN1c3RvbSB0YWdzIGludG8gdGhlIHJpZ2h0IHBvc2l0aW9uXG4gICAgICAgICAgaWYgKCFjaGlsZCAmJiB0YWcudGFncykgeyBtb3ZlTmVzdGVkVGFncy5jYWxsKHRhZywgaSk7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNhY2hlIHRoZSBvcmlnaW5hbCBpdGVtIHRvIHVzZSBpdCBpbiB0aGUgZXZlbnRzIGJvdW5kIHRvIHRoaXMgbm9kZVxuICAgICAgICAvLyBhbmQgaXRzIGNoaWxkcmVuXG4gICAgICAgIGV4dGVuZCh0YWcuX18sIHtcbiAgICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIHBhcmVudDogcGFyZW50XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRtcEl0ZW1zW2ldID0gaXRlbUlkO1xuXG4gICAgICAgIGlmICghbXVzdENyZWF0ZSkgeyB0YWcudXBkYXRlKGl0ZW0pOyB9XG4gICAgICB9KTtcblxuICAgICAgLy8gcmVtb3ZlIHRoZSByZWR1bmRhbnQgdGFnc1xuICAgICAgdW5tb3VudFJlZHVuZGFudChpdGVtcywgdGFncywgZmlsdGVyZWRJdGVtc0NvdW50KTtcblxuICAgICAgLy8gY2xvbmUgdGhlIGl0ZW1zIGFycmF5XG4gICAgICBvbGRJdGVtcyA9IHRtcEl0ZW1zLnNsaWNlKCk7XG5cbiAgICAgIHJvb3QuaW5zZXJ0QmVmb3JlKGZyYWcsIHBsYWNlaG9sZGVyKTtcbiAgICB9O1xuXG4gICAgZXhwci51bm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZWFjaCh0YWdzLCBmdW5jdGlvbiAodCkgeyB0LnVubW91bnQoKTsgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBleHByXG4gIH1cblxuICB2YXIgUmVmRXhwciA9IHtcbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KGRvbSwgcGFyZW50LCBhdHRyTmFtZSwgYXR0clZhbHVlKSB7XG4gICAgICB0aGlzLmRvbSA9IGRvbTtcbiAgICAgIHRoaXMuYXR0ciA9IGF0dHJOYW1lO1xuICAgICAgdGhpcy5yYXdWYWx1ZSA9IGF0dHJWYWx1ZTtcbiAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgdGhpcy5oYXNFeHAgPSB0bXBsLmhhc0V4cHIoYXR0clZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIHZhciBvbGQgPSB0aGlzLnZhbHVlO1xuICAgICAgdmFyIGN1c3RvbVBhcmVudCA9IHRoaXMucGFyZW50ICYmIGdldEltbWVkaWF0ZUN1c3RvbVBhcmVudCh0aGlzLnBhcmVudCk7XG4gICAgICAvLyBpZiB0aGUgcmVmZXJlbmNlZCBlbGVtZW50IGlzIGEgY3VzdG9tIHRhZywgdGhlbiB3ZSBzZXQgdGhlIHRhZyBpdHNlbGYsIHJhdGhlciB0aGFuIERPTVxuICAgICAgdmFyIHRhZ09yRG9tID0gdGhpcy5kb20uX19yZWYgfHwgdGhpcy50YWcgfHwgdGhpcy5kb207XG5cbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmhhc0V4cCA/IHRtcGwodGhpcy5yYXdWYWx1ZSwgdGhpcy5wYXJlbnQpIDogdGhpcy5yYXdWYWx1ZTtcblxuICAgICAgLy8gdGhlIG5hbWUgY2hhbmdlZCwgc28gd2UgbmVlZCB0byByZW1vdmUgaXQgZnJvbSB0aGUgb2xkIGtleSAoaWYgcHJlc2VudClcbiAgICAgIGlmICghaXNCbGFuayhvbGQpICYmIGN1c3RvbVBhcmVudCkgeyBhcnJheWlzaFJlbW92ZShjdXN0b21QYXJlbnQucmVmcywgb2xkLCB0YWdPckRvbSk7IH1cbiAgICAgIGlmICghaXNCbGFuayh0aGlzLnZhbHVlKSAmJiBpc1N0cmluZyh0aGlzLnZhbHVlKSkge1xuICAgICAgICAvLyBhZGQgaXQgdG8gdGhlIHJlZnMgb2YgcGFyZW50IHRhZyAodGhpcyBiZWhhdmlvciB3YXMgY2hhbmdlZCA+PTMuMClcbiAgICAgICAgaWYgKGN1c3RvbVBhcmVudCkgeyBhcnJheWlzaEFkZChcbiAgICAgICAgICBjdXN0b21QYXJlbnQucmVmcyxcbiAgICAgICAgICB0aGlzLnZhbHVlLFxuICAgICAgICAgIHRhZ09yRG9tLFxuICAgICAgICAgIC8vIHVzZSBhbiBhcnJheSBpZiBpdCdzIGEgbG9vcGVkIG5vZGUgYW5kIHRoZSByZWYgaXMgbm90IGFuIGV4cHJlc3Npb25cbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHRoaXMucGFyZW50Ll9fLmluZGV4XG4gICAgICAgICk7IH1cblxuICAgICAgICBpZiAodGhpcy52YWx1ZSAhPT0gb2xkKSB7XG4gICAgICAgICAgc2V0QXR0cmlidXRlKHRoaXMuZG9tLCB0aGlzLmF0dHIsIHRoaXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1vdmVBdHRyaWJ1dGUodGhpcy5kb20sIHRoaXMuYXR0cik7XG4gICAgICB9XG5cbiAgICAgIC8vIGNhY2hlIHRoZSByZWYgYm91bmQgdG8gdGhpcyBkb20gbm9kZVxuICAgICAgLy8gdG8gcmV1c2UgaXQgaW4gZnV0dXJlIChzZWUgYWxzbyAjMjMyOSlcbiAgICAgIGlmICghdGhpcy5kb20uX19yZWYpIHsgdGhpcy5kb20uX19yZWYgPSB0YWdPckRvbTsgfVxuICAgIH0sXG4gICAgdW5tb3VudDogZnVuY3Rpb24gdW5tb3VudCgpIHtcbiAgICAgIHZhciB0YWdPckRvbSA9IHRoaXMudGFnIHx8IHRoaXMuZG9tO1xuICAgICAgdmFyIGN1c3RvbVBhcmVudCA9IHRoaXMucGFyZW50ICYmIGdldEltbWVkaWF0ZUN1c3RvbVBhcmVudCh0aGlzLnBhcmVudCk7XG4gICAgICBpZiAoIWlzQmxhbmsodGhpcy52YWx1ZSkgJiYgY3VzdG9tUGFyZW50KVxuICAgICAgICB7IGFycmF5aXNoUmVtb3ZlKGN1c3RvbVBhcmVudC5yZWZzLCB0aGlzLnZhbHVlLCB0YWdPckRvbSk7IH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHJlZiBkaXJlY3RpdmVcbiAgICogQHBhcmFtICAgeyBIVE1MRWxlbWVudCB9IGRvbSAtIGRvbSBub2RlIGhhdmluZyB0aGUgcmVmIGF0dHJpYnV0ZVxuICAgKiBAcGFyYW0gICB7IFRhZyB9IGNvbnRleHQgLSB0YWcgaW5zdGFuY2Ugd2hlcmUgdGhlIERPTSBub2RlIGlzIGxvY2F0ZWRcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSBhdHRyTmFtZSAtIGVpdGhlciAncmVmJyBvciAnZGF0YS1yZWYnXG4gICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gYXR0clZhbHVlIC0gdmFsdWUgb2YgdGhlIHJlZiBhdHRyaWJ1dGVcbiAgICogQHJldHVybnMgeyBSZWZFeHByIH0gYSBuZXcgUmVmRXhwciBvYmplY3RcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZVJlZkRpcmVjdGl2ZShkb20sIHRhZywgYXR0ck5hbWUsIGF0dHJWYWx1ZSkge1xuICAgIHJldHVybiBjcmVhdGUoUmVmRXhwcikuaW5pdChkb20sIHRhZywgYXR0ck5hbWUsIGF0dHJWYWx1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIHRoZSB1bm1vdW50IG1ldGhvZCBvbiBhbGwgdGhlIGV4cHJlc3Npb25zXG4gICAqIEBwYXJhbSAgIHsgQXJyYXkgfSBleHByZXNzaW9ucyAtIERPTSBleHByZXNzaW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gdW5tb3VudEFsbChleHByZXNzaW9ucykge1xuICAgIGVhY2goZXhwcmVzc2lvbnMsIGZ1bmN0aW9uIChleHByKSB7XG4gICAgICBpZiAoZXhwci51bm1vdW50KSB7IGV4cHIudW5tb3VudCh0cnVlKTsgfVxuICAgICAgZWxzZSBpZiAoZXhwci50YWdOYW1lKSB7IGV4cHIudGFnLnVubW91bnQodHJ1ZSk7IH1cbiAgICAgIGVsc2UgaWYgKGV4cHIudW5tb3VudCkgeyBleHByLnVubW91bnQoKTsgfVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIElmRXhwciA9IHtcbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KGRvbSwgdGFnLCBleHByKSB7XG4gICAgICByZW1vdmVBdHRyaWJ1dGUoZG9tLCBDT05ESVRJT05BTF9ESVJFQ1RJVkUpO1xuICAgICAgZXh0ZW5kKHRoaXMsIHsgdGFnOiB0YWcsIGV4cHI6IGV4cHIsIHN0dWI6IGNyZWF0ZURPTVBsYWNlaG9sZGVyKCksIHByaXN0aW5lOiBkb20gfSk7XG4gICAgICB2YXIgcCA9IGRvbS5wYXJlbnROb2RlO1xuICAgICAgcC5pbnNlcnRCZWZvcmUodGhpcy5zdHViLCBkb20pO1xuICAgICAgcC5yZW1vdmVDaGlsZChkb20pO1xuXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUkJDEoKSB7XG4gICAgICB0aGlzLnZhbHVlID0gdG1wbCh0aGlzLmV4cHIsIHRoaXMudGFnKTtcblxuICAgICAgaWYgKHRoaXMudmFsdWUgJiYgIXRoaXMuY3VycmVudCkgeyAvLyBpbnNlcnRcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5wcmlzdGluZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgIHRoaXMuc3R1Yi5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmN1cnJlbnQsIHRoaXMuc3R1Yik7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBwYXJzZUV4cHJlc3Npb25zLmFwcGx5KHRoaXMudGFnLCBbdGhpcy5jdXJyZW50LCB0cnVlXSk7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLnZhbHVlICYmIHRoaXMuY3VycmVudCkgeyAvLyByZW1vdmVcbiAgICAgICAgdW5tb3VudEFsbCh0aGlzLmV4cHJlc3Npb25zKTtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudC5fdGFnKSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50Ll90YWcudW5tb3VudCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gW107XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnZhbHVlKSB7IHVwZGF0ZS5jYWxsKHRoaXMudGFnLCB0aGlzLmV4cHJlc3Npb25zKTsgfVxuICAgIH0sXG4gICAgdW5tb3VudDogZnVuY3Rpb24gdW5tb3VudCgpIHtcbiAgICAgIHVubW91bnRBbGwodGhpcy5leHByZXNzaW9ucyB8fCBbXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBpZiBkaXJlY3RpdmVcbiAgICogQHBhcmFtICAgeyBIVE1MRWxlbWVudCB9IGRvbSAtIGlmIHJvb3QgZG9tIG5vZGVcbiAgICogQHBhcmFtICAgeyBUYWcgfSBjb250ZXh0IC0gdGFnIGluc3RhbmNlIHdoZXJlIHRoZSBET00gbm9kZSBpcyBsb2NhdGVkXG4gICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gYXR0ciAtIGlmIGV4cHJlc3Npb25cbiAgICogQHJldHVybnMgeyBJRkV4cHIgfSBhIG5ldyBJZkV4cHIgb2JqZWN0XG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVJZkRpcmVjdGl2ZShkb20sIHRhZywgYXR0cikge1xuICAgIHJldHVybiBjcmVhdGUoSWZFeHByKS5pbml0KGRvbSwgdGFnLCBhdHRyKVxuICB9XG5cbiAgLyoqXG4gICAqIFdhbGsgdGhlIHRhZyBET00gdG8gZGV0ZWN0IHRoZSBleHByZXNzaW9ucyB0byBldmFsdWF0ZVxuICAgKiBAdGhpcyBUYWdcbiAgICogQHBhcmFtICAgeyBIVE1MRWxlbWVudCB9IHJvb3QgLSByb290IHRhZyB3aGVyZSB3ZSB3aWxsIHN0YXJ0IGRpZ2dpbmcgdGhlIGV4cHJlc3Npb25zXG4gICAqIEBwYXJhbSAgIHsgQm9vbGVhbiB9IG11c3RJbmNsdWRlUm9vdCAtIGZsYWcgdG8gZGVjaWRlIHdoZXRoZXIgdGhlIHJvb3QgbXVzdCBiZSBwYXJzZWQgYXMgd2VsbFxuICAgKiBAcmV0dXJucyB7IEFycmF5IH0gYWxsIHRoZSBleHByZXNzaW9ucyBmb3VuZFxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9ucyhyb290LCBtdXN0SW5jbHVkZVJvb3QpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBleHByZXNzaW9ucyA9IFtdO1xuXG4gICAgd2Fsa05vZGVzKHJvb3QsIGZ1bmN0aW9uIChkb20pIHtcbiAgICAgIHZhciB0eXBlID0gZG9tLm5vZGVUeXBlO1xuICAgICAgdmFyIGF0dHI7XG4gICAgICB2YXIgdGFnSW1wbDtcblxuICAgICAgaWYgKCFtdXN0SW5jbHVkZVJvb3QgJiYgZG9tID09PSByb290KSB7IHJldHVybiB9XG5cbiAgICAgIC8vIHRleHQgbm9kZVxuICAgICAgaWYgKHR5cGUgPT09IDMgJiYgZG9tLnBhcmVudE5vZGUudGFnTmFtZSAhPT0gJ1NUWUxFJyAmJiB0bXBsLmhhc0V4cHIoZG9tLm5vZGVWYWx1ZSkpXG4gICAgICAgIHsgZXhwcmVzc2lvbnMucHVzaCh7ZG9tOiBkb20sIGV4cHI6IGRvbS5ub2RlVmFsdWV9KTsgfVxuXG4gICAgICBpZiAodHlwZSAhPT0gMSkgeyByZXR1cm4gfVxuXG4gICAgICB2YXIgaXNWaXJ0dWFsID0gZG9tLnRhZ05hbWUgPT09ICdWSVJUVUFMJztcblxuICAgICAgLy8gbG9vcC4gZWFjaCBkb2VzIGl0J3Mgb3duIHRoaW5nIChmb3Igbm93KVxuICAgICAgaWYgKGF0dHIgPSBnZXRBdHRyaWJ1dGUoZG9tLCBMT09QX0RJUkVDVElWRSkpIHtcbiAgICAgICAgaWYoaXNWaXJ0dWFsKSB7IHNldEF0dHJpYnV0ZShkb20sICdsb29wVmlydHVhbCcsIHRydWUpOyB9IC8vIGlnbm9yZSBoZXJlLCBoYW5kbGVkIGluIF9lYWNoXG4gICAgICAgIGV4cHJlc3Npb25zLnB1c2goX2VhY2goZG9tLCB0aGlzJDEsIGF0dHIpKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIC8vIGlmLWF0dHJzIGJlY29tZSB0aGUgbmV3IHBhcmVudC4gQW55IGZvbGxvd2luZyBleHByZXNzaW9ucyAoZWl0aGVyIG9uIHRoZSBjdXJyZW50XG4gICAgICAvLyBlbGVtZW50LCBvciBiZWxvdyBpdCkgYmVjb21lIGNoaWxkcmVuIG9mIHRoaXMgZXhwcmVzc2lvbi5cbiAgICAgIGlmIChhdHRyID0gZ2V0QXR0cmlidXRlKGRvbSwgQ09ORElUSU9OQUxfRElSRUNUSVZFKSkge1xuICAgICAgICBleHByZXNzaW9ucy5wdXNoKGNyZWF0ZUlmRGlyZWN0aXZlKGRvbSwgdGhpcyQxLCBhdHRyKSk7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBpZiAoYXR0ciA9IGdldEF0dHJpYnV0ZShkb20sIElTX0RJUkVDVElWRSkpIHtcbiAgICAgICAgaWYgKHRtcGwuaGFzRXhwcihhdHRyKSkge1xuICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goe1xuICAgICAgICAgICAgaXNSdGFnOiB0cnVlLFxuICAgICAgICAgICAgZXhwcjogYXR0cixcbiAgICAgICAgICAgIGRvbTogZG9tLFxuICAgICAgICAgICAgYXR0cnM6IFtdLnNsaWNlLmNhbGwoZG9tLmF0dHJpYnV0ZXMpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBpZiB0aGlzIGlzIGEgdGFnLCBzdG9wIHRyYXZlcnNpbmcgaGVyZS5cbiAgICAgIC8vIHdlIGlnbm9yZSB0aGUgcm9vdCwgc2luY2UgcGFyc2VFeHByZXNzaW9ucyBpcyBjYWxsZWQgd2hpbGUgd2UncmUgbW91bnRpbmcgdGhhdCByb290XG4gICAgICB0YWdJbXBsID0gZ2V0KGRvbSk7XG5cbiAgICAgIGlmKGlzVmlydHVhbCkge1xuICAgICAgICBpZihnZXRBdHRyaWJ1dGUoZG9tLCAndmlydHVhbGl6ZWQnKSkge2RvbS5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGRvbSk7IH0gLy8gdGFnIGNyZWF0ZWQsIHJlbW92ZSBmcm9tIGRvbVxuICAgICAgICBpZighdGFnSW1wbCAmJiAhZ2V0QXR0cmlidXRlKGRvbSwgJ3ZpcnR1YWxpemVkJykgJiYgIWdldEF0dHJpYnV0ZShkb20sICdsb29wVmlydHVhbCcpKSAgLy8gb2sgdG8gY3JlYXRlIHZpcnR1YWwgdGFnXG4gICAgICAgICAgeyB0YWdJbXBsID0geyB0bXBsOiBkb20ub3V0ZXJIVE1MIH07IH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRhZ0ltcGwgJiYgKGRvbSAhPT0gcm9vdCB8fCBtdXN0SW5jbHVkZVJvb3QpKSB7XG4gICAgICAgIHZhciBoYXNJc0RpcmVjdGl2ZSA9IGdldEF0dHJpYnV0ZShkb20sIElTX0RJUkVDVElWRSk7XG4gICAgICAgIGlmKGlzVmlydHVhbCAmJiAhaGFzSXNEaXJlY3RpdmUpIHsgLy8gaGFuZGxlZCBpbiB1cGRhdGVcbiAgICAgICAgICAvLyBjYW4gbm90IHJlbW92ZSBhdHRyaWJ1dGUgbGlrZSBkaXJlY3RpdmVzXG4gICAgICAgICAgLy8gc28gZmxhZyBmb3IgcmVtb3ZhbCBhZnRlciBjcmVhdGlvbiB0byBwcmV2ZW50IG1heGltdW0gc3RhY2sgZXJyb3JcbiAgICAgICAgICBzZXRBdHRyaWJ1dGUoZG9tLCAndmlydHVhbGl6ZWQnLCB0cnVlKTtcbiAgICAgICAgICB2YXIgdGFnID0gY3JlYXRlVGFnKFxuICAgICAgICAgICAge3RtcGw6IGRvbS5vdXRlckhUTUx9LFxuICAgICAgICAgICAge3Jvb3Q6IGRvbSwgcGFyZW50OiB0aGlzJDF9LFxuICAgICAgICAgICAgZG9tLmlubmVySFRNTFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKHRhZyk7IC8vIG5vIHJldHVybiwgYW5vbnltb3VzIHRhZywga2VlcCBwYXJzaW5nXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGhhc0lzRGlyZWN0aXZlICYmIGlzVmlydHVhbClcbiAgICAgICAgICAgIHsgd2FybigoXCJWaXJ0dWFsIHRhZ3Mgc2hvdWxkbid0IGJlIHVzZWQgdG9nZXRoZXIgd2l0aCB0aGUgXFxcIlwiICsgSVNfRElSRUNUSVZFICsgXCJcXFwiIGF0dHJpYnV0ZSAtIGh0dHBzOi8vZ2l0aHViLmNvbS9yaW90L3Jpb3QvaXNzdWVzLzI1MTFcIikpOyB9XG5cbiAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKFxuICAgICAgICAgICAgaW5pdENoaWxkKFxuICAgICAgICAgICAgICB0YWdJbXBsLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcm9vdDogZG9tLFxuICAgICAgICAgICAgICAgIHBhcmVudDogdGhpcyQxXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGRvbS5pbm5lckhUTUwsXG4gICAgICAgICAgICAgIHRoaXMkMVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gYXR0cmlidXRlIGV4cHJlc3Npb25zXG4gICAgICBwYXJzZUF0dHJpYnV0ZXMuYXBwbHkodGhpcyQxLCBbZG9tLCBkb20uYXR0cmlidXRlcywgZnVuY3Rpb24gKGF0dHIsIGV4cHIpIHtcbiAgICAgICAgaWYgKCFleHByKSB7IHJldHVybiB9XG4gICAgICAgIGV4cHJlc3Npb25zLnB1c2goZXhwcik7XG4gICAgICB9XSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZXhwcmVzc2lvbnNcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyBgZm5gIGZvciBldmVyeSBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudC4gSWYgdGhhdCBhdHRyIGhhcyBhbiBleHByZXNzaW9uLFxuICAgKiBpdCBpcyBhbHNvIHBhc3NlZCB0byBmbi5cbiAgICogQHRoaXMgVGFnXG4gICAqIEBwYXJhbSAgIHsgSFRNTEVsZW1lbnQgfSBkb20gLSBkb20gbm9kZSB0byBwYXJzZVxuICAgKiBAcGFyYW0gICB7IEFycmF5IH0gYXR0cnMgLSBhcnJheSBvZiBhdHRyaWJ1dGVzXG4gICAqIEBwYXJhbSAgIHsgRnVuY3Rpb24gfSBmbiAtIGNhbGxiYWNrIHRvIGV4ZWMgb24gYW55IGl0ZXJhdGlvblxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VBdHRyaWJ1dGVzKGRvbSwgYXR0cnMsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBlYWNoKGF0dHJzLCBmdW5jdGlvbiAoYXR0cikge1xuICAgICAgaWYgKCFhdHRyKSB7IHJldHVybiBmYWxzZSB9XG5cbiAgICAgIHZhciBuYW1lID0gYXR0ci5uYW1lO1xuICAgICAgdmFyIGJvb2wgPSBpc0Jvb2xBdHRyKG5hbWUpO1xuICAgICAgdmFyIGV4cHI7XG5cbiAgICAgIGlmIChjb250YWlucyhSRUZfRElSRUNUSVZFUywgbmFtZSkgJiYgZG9tLnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gWUlFTERfVEFHKSB7XG4gICAgICAgIGV4cHIgPSAgY3JlYXRlUmVmRGlyZWN0aXZlKGRvbSwgdGhpcyQxLCBuYW1lLCBhdHRyLnZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAodG1wbC5oYXNFeHByKGF0dHIudmFsdWUpKSB7XG4gICAgICAgIGV4cHIgPSB7ZG9tOiBkb20sIGV4cHI6IGF0dHIudmFsdWUsIGF0dHI6IG5hbWUsIGJvb2w6IGJvb2x9O1xuICAgICAgfVxuXG4gICAgICBmbihhdHRyLCBleHByKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYW5hZ2UgdGhlIG1vdW50IHN0YXRlIG9mIGEgdGFnIHRyaWdnZXJpbmcgYWxzbyB0aGUgb2JzZXJ2YWJsZSBldmVudHNcbiAgICogQHRoaXMgVGFnXG4gICAqIEBwYXJhbSB7IEJvb2xlYW4gfSB2YWx1ZSAtIC4ub2YgdGhlIGlzTW91bnRlZCBmbGFnXG4gICAqL1xuICBmdW5jdGlvbiBzZXRNb3VudFN0YXRlKHZhbHVlKSB7XG4gICAgdmFyIHJlZiA9IHRoaXMuX187XG4gICAgdmFyIGlzQW5vbnltb3VzID0gcmVmLmlzQW5vbnltb3VzO1xuXG4gICAgZGVmaW5lKHRoaXMsICdpc01vdW50ZWQnLCB2YWx1ZSk7XG5cbiAgICBpZiAoIWlzQW5vbnltb3VzKSB7XG4gICAgICBpZiAodmFsdWUpIHsgdGhpcy50cmlnZ2VyKCdtb3VudCcpOyB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCd1bm1vdW50Jyk7XG4gICAgICAgIHRoaXMub2ZmKCcqJyk7XG4gICAgICAgIHRoaXMuX18ud2FzQ3JlYXRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNb3VudCB0aGUgY3VycmVudCB0YWcgaW5zdGFuY2VcbiAgICogQHJldHVybnMgeyBUYWcgfSB0aGUgY3VycmVudCB0YWcgaW5zdGFuY2VcbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBvbmVudE1vdW50KHRhZyQkMSwgZG9tLCBleHByZXNzaW9ucywgb3B0cykge1xuICAgIHZhciBfXyA9IHRhZyQkMS5fXztcbiAgICB2YXIgcm9vdCA9IF9fLnJvb3Q7XG4gICAgcm9vdC5fdGFnID0gdGFnJCQxOyAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSB0YWcganVzdCBjcmVhdGVkXG5cbiAgICAvLyBSZWFkIGFsbCB0aGUgYXR0cnMgb24gdGhpcyBpbnN0YW5jZS4gVGhpcyBnaXZlIHVzIHRoZSBpbmZvIHdlIG5lZWQgZm9yIHVwZGF0ZU9wdHNcbiAgICBwYXJzZUF0dHJpYnV0ZXMuYXBwbHkoX18ucGFyZW50LCBbcm9vdCwgcm9vdC5hdHRyaWJ1dGVzLCBmdW5jdGlvbiAoYXR0ciwgZXhwcikge1xuICAgICAgaWYgKCFfXy5pc0Fub255bW91cyAmJiBSZWZFeHByLmlzUHJvdG90eXBlT2YoZXhwcikpIHsgZXhwci50YWcgPSB0YWckJDE7IH1cbiAgICAgIGF0dHIuZXhwciA9IGV4cHI7XG4gICAgICBfXy5pbnN0QXR0cnMucHVzaChhdHRyKTtcbiAgICB9XSk7XG5cbiAgICAvLyB1cGRhdGUgdGhlIHJvb3QgYWRkaW5nIGN1c3RvbSBhdHRyaWJ1dGVzIGNvbWluZyBmcm9tIHRoZSBjb21waWxlclxuICAgIHdhbGtBdHRyaWJ1dGVzKF9fLmltcGwuYXR0cnMsIGZ1bmN0aW9uIChrLCB2KSB7IF9fLmltcGxBdHRycy5wdXNoKHtuYW1lOiBrLCB2YWx1ZTogdn0pOyB9KTtcbiAgICBwYXJzZUF0dHJpYnV0ZXMuYXBwbHkodGFnJCQxLCBbcm9vdCwgX18uaW1wbEF0dHJzLCBmdW5jdGlvbiAoYXR0ciwgZXhwcikge1xuICAgICAgaWYgKGV4cHIpIHsgZXhwcmVzc2lvbnMucHVzaChleHByKTsgfVxuICAgICAgZWxzZSB7IHNldEF0dHJpYnV0ZShyb290LCBhdHRyLm5hbWUsIGF0dHIudmFsdWUpOyB9XG4gICAgfV0pO1xuXG4gICAgLy8gaW5pdGlhbGlhdGlvblxuICAgIHVwZGF0ZU9wdHMuYXBwbHkodGFnJCQxLCBbX18uaXNMb29wLCBfXy5wYXJlbnQsIF9fLmlzQW5vbnltb3VzLCBvcHRzLCBfXy5pbnN0QXR0cnNdKTtcblxuICAgIC8vIGFkZCBnbG9iYWwgbWl4aW5zXG4gICAgdmFyIGdsb2JhbE1peGluID0gbWl4aW4oR0xPQkFMX01JWElOKTtcblxuICAgIGlmIChnbG9iYWxNaXhpbiAmJiAhX18uc2tpcEFub255bW91cykge1xuICAgICAgZm9yICh2YXIgaSBpbiBnbG9iYWxNaXhpbikge1xuICAgICAgICBpZiAoZ2xvYmFsTWl4aW4uaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICB0YWckJDEubWl4aW4oZ2xvYmFsTWl4aW5baV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKF9fLmltcGwuZm4pIHsgX18uaW1wbC5mbi5jYWxsKHRhZyQkMSwgb3B0cyk7IH1cblxuICAgIGlmICghX18uc2tpcEFub255bW91cykgeyB0YWckJDEudHJpZ2dlcignYmVmb3JlLW1vdW50Jyk7IH1cblxuICAgIC8vIHBhcnNlIGxheW91dCBhZnRlciBpbml0LiBmbiBtYXkgY2FsY3VsYXRlIGFyZ3MgZm9yIG5lc3RlZCBjdXN0b20gdGFnc1xuICAgIGVhY2gocGFyc2VFeHByZXNzaW9ucy5hcHBseSh0YWckJDEsIFtkb20sIF9fLmlzQW5vbnltb3VzXSksIGZ1bmN0aW9uIChlKSB7IHJldHVybiBleHByZXNzaW9ucy5wdXNoKGUpOyB9KTtcblxuICAgIHRhZyQkMS51cGRhdGUoX18uaXRlbSk7XG5cbiAgICBpZiAoIV9fLmlzQW5vbnltb3VzICYmICFfXy5pc0lubGluZSkge1xuICAgICAgd2hpbGUgKGRvbS5maXJzdENoaWxkKSB7IHJvb3QuYXBwZW5kQ2hpbGQoZG9tLmZpcnN0Q2hpbGQpOyB9XG4gICAgfVxuXG4gICAgZGVmaW5lKHRhZyQkMSwgJ3Jvb3QnLCByb290KTtcblxuICAgIC8vIGlmIHdlIG5lZWQgdG8gd2FpdCB0aGF0IHRoZSBwYXJlbnQgXCJtb3VudFwiIG9yIFwidXBkYXRlZFwiIGV2ZW50IGdldHMgdHJpZ2dlcmVkXG4gICAgaWYgKCFfXy5za2lwQW5vbnltb3VzICYmIHRhZyQkMS5wYXJlbnQpIHtcbiAgICAgIHZhciBwID0gZ2V0SW1tZWRpYXRlQ3VzdG9tUGFyZW50KHRhZyQkMS5wYXJlbnQpO1xuICAgICAgcC5vbmUoIXAuaXNNb3VudGVkID8gJ21vdW50JyA6ICd1cGRhdGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRNb3VudFN0YXRlLmNhbGwodGFnJCQxLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvdGhlcndpc2UgaXQncyBub3QgYSBjaGlsZCB0YWcgd2UgY2FuIHRyaWdnZXIgaXRzIG1vdW50IGV2ZW50XG4gICAgICBzZXRNb3VudFN0YXRlLmNhbGwodGFnJCQxLCB0cnVlKTtcbiAgICB9XG5cbiAgICB0YWckJDEuX18ud2FzQ3JlYXRlZCA9IHRydWU7XG5cbiAgICByZXR1cm4gdGFnJCQxXG4gIH1cblxuICAvKipcbiAgICogVW5tb3VudCB0aGUgdGFnIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7IEJvb2xlYW4gfSBtdXN0S2VlcFJvb3QgLSBpZiBpdCdzIHRydWUgdGhlIHJvb3Qgbm9kZSB3aWxsIG5vdCBiZSByZW1vdmVkXG4gICAqIEByZXR1cm5zIHsgVGFnIH0gdGhlIGN1cnJlbnQgdGFnIGluc3RhbmNlXG4gICAqL1xuICBmdW5jdGlvbiB0YWdVbm1vdW50KHRhZywgbXVzdEtlZXBSb290LCBleHByZXNzaW9ucykge1xuICAgIHZhciBfXyA9IHRhZy5fXztcbiAgICB2YXIgcm9vdCA9IF9fLnJvb3Q7XG4gICAgdmFyIHRhZ0luZGV4ID0gX19UQUdTX0NBQ0hFLmluZGV4T2YodGFnKTtcbiAgICB2YXIgcCA9IHJvb3QucGFyZW50Tm9kZTtcblxuICAgIGlmICghX18uc2tpcEFub255bW91cykgeyB0YWcudHJpZ2dlcignYmVmb3JlLXVubW91bnQnKTsgfVxuXG4gICAgLy8gY2xlYXIgYWxsIGF0dHJpYnV0ZXMgY29taW5nIGZyb20gdGhlIG1vdW50ZWQgdGFnXG4gICAgd2Fsa0F0dHJpYnV0ZXMoX18uaW1wbC5hdHRycywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGlmIChzdGFydHNXaXRoKG5hbWUsIEFUVFJTX1BSRUZJWCkpXG4gICAgICAgIHsgbmFtZSA9IG5hbWUuc2xpY2UoQVRUUlNfUFJFRklYLmxlbmd0aCk7IH1cblxuICAgICAgcmVtb3ZlQXR0cmlidXRlKHJvb3QsIG5hbWUpO1xuICAgIH0pO1xuXG4gICAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgdGFnLl9fLmxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChkb20pIHtcbiAgICAgIE9iamVjdC5rZXlzKGRvbVtSSU9UX0VWRU5UU19LRVldKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBkb21bUklPVF9FVkVOVFNfS0VZXVtldmVudE5hbWVdKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gcmVtb3ZlIHRhZyBpbnN0YW5jZSBmcm9tIHRoZSBnbG9iYWwgdGFncyBjYWNoZSBjb2xsZWN0aW9uXG4gICAgaWYgKHRhZ0luZGV4ICE9PSAtMSkgeyBfX1RBR1NfQ0FDSEUuc3BsaWNlKHRhZ0luZGV4LCAxKTsgfVxuXG4gICAgLy8gY2xlYW4gdXAgdGhlIHBhcmVudCB0YWdzIG9iamVjdFxuICAgIGlmIChfXy5wYXJlbnQgJiYgIV9fLmlzQW5vbnltb3VzKSB7XG4gICAgICB2YXIgcHRhZyA9IGdldEltbWVkaWF0ZUN1c3RvbVBhcmVudChfXy5wYXJlbnQpO1xuXG4gICAgICBpZiAoX18uaXNWaXJ0dWFsKSB7XG4gICAgICAgIE9iamVjdFxuICAgICAgICAgIC5rZXlzKHRhZy50YWdzKVxuICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uICh0YWdOYW1lKSB7IHJldHVybiBhcnJheWlzaFJlbW92ZShwdGFnLnRhZ3MsIHRhZ05hbWUsIHRhZy50YWdzW3RhZ05hbWVdKTsgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnJheWlzaFJlbW92ZShwdGFnLnRhZ3MsIF9fLnRhZ05hbWUsIHRhZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdW5tb3VudCBhbGwgdGhlIHZpcnR1YWwgZGlyZWN0aXZlc1xuICAgIGlmICh0YWcuX18udmlydHMpIHtcbiAgICAgIGVhY2godGFnLl9fLnZpcnRzLCBmdW5jdGlvbiAodikge1xuICAgICAgICBpZiAodi5wYXJlbnROb2RlKSB7IHYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh2KTsgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gYWxsb3cgZXhwcmVzc2lvbnMgdG8gdW5tb3VudCB0aGVtc2VsdmVzXG4gICAgdW5tb3VudEFsbChleHByZXNzaW9ucyk7XG4gICAgZWFjaChfXy5pbnN0QXR0cnMsIGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLmV4cHIgJiYgYS5leHByLnVubW91bnQgJiYgYS5leHByLnVubW91bnQoKTsgfSk7XG5cbiAgICAvLyBjbGVhciB0aGUgdGFnIGh0bWwgaWYgaXQncyBuZWNlc3NhcnlcbiAgICBpZiAobXVzdEtlZXBSb290KSB7IHNldElubmVySFRNTChyb290LCAnJyk7IH1cbiAgICAvLyBvdGhlcndpc2UgZGV0YWNoIHRoZSByb290IHRhZyBmcm9tIHRoZSBET01cbiAgICBlbHNlIGlmIChwKSB7IHAucmVtb3ZlQ2hpbGQocm9vdCk7IH1cblxuICAgIC8vIGN1c3RvbSBpbnRlcm5hbCB1bm1vdW50IGZ1bmN0aW9uIHRvIGF2b2lkIHJlbHlpbmcgb24gdGhlIG9ic2VydmFibGVcbiAgICBpZiAoX18ub25Vbm1vdW50KSB7IF9fLm9uVW5tb3VudCgpOyB9XG5cbiAgICAvLyB3ZWlyZCBmaXggZm9yIGEgd2VpcmQgZWRnZSBjYXNlICMyNDA5IGFuZCAjMjQzNlxuICAgIC8vIHNvbWUgdXNlcnMgbWlnaHQgdXNlIHlvdXIgc29mdHdhcmUgbm90IGFzIHlvdSd2ZSBleHBlY3RlZFxuICAgIC8vIHNvIEkgbmVlZCB0byBhZGQgdGhlc2UgZGlydHkgaGFja3MgdG8gbWl0aWdhdGUgdW5leHBlY3RlZCBpc3N1ZXNcbiAgICBpZiAoIXRhZy5pc01vdW50ZWQpIHsgc2V0TW91bnRTdGF0ZS5jYWxsKHRhZywgdHJ1ZSk7IH1cblxuICAgIHNldE1vdW50U3RhdGUuY2FsbCh0YWcsIGZhbHNlKTtcblxuICAgIGRlbGV0ZSByb290Ll90YWc7XG5cbiAgICByZXR1cm4gdGFnXG4gIH1cblxuICAvKipcbiAgICogVGFnIGNyZWF0aW9uIGZhY3RvcnkgZnVuY3Rpb25cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7IE9iamVjdCB9IGltcGwgLSBpdCBjb250YWlucyB0aGUgdGFnIHRlbXBsYXRlLCBhbmQgbG9naWNcbiAgICogQHBhcmFtIHsgT2JqZWN0IH0gY29uZiAtIHRhZyBvcHRpb25zXG4gICAqIEBwYXJhbSB7IFN0cmluZyB9IGlubmVySFRNTCAtIGh0bWwgdGhhdCBldmVudHVhbGx5IHdlIG5lZWQgdG8gaW5qZWN0IGluIHRoZSB0YWdcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZVRhZyhpbXBsLCBjb25mLCBpbm5lckhUTUwpIHtcbiAgICBpZiAoIGltcGwgPT09IHZvaWQgMCApIGltcGwgPSB7fTtcbiAgICBpZiAoIGNvbmYgPT09IHZvaWQgMCApIGNvbmYgPSB7fTtcblxuICAgIHZhciB0YWcgPSBjb25mLmNvbnRleHQgfHwge307XG4gICAgdmFyIG9wdHMgPSBleHRlbmQoe30sIGNvbmYub3B0cyk7XG4gICAgdmFyIHBhcmVudCA9IGNvbmYucGFyZW50O1xuICAgIHZhciBpc0xvb3AgPSBjb25mLmlzTG9vcDtcbiAgICB2YXIgaXNBbm9ueW1vdXMgPSAhIWNvbmYuaXNBbm9ueW1vdXM7XG4gICAgdmFyIHNraXBBbm9ueW1vdXMgPSBzZXR0aW5ncy5za2lwQW5vbnltb3VzVGFncyAmJiBpc0Fub255bW91cztcbiAgICB2YXIgaXRlbSA9IGNvbmYuaXRlbTtcbiAgICAvLyBhdmFpbGFibGUgb25seSBmb3IgdGhlIGxvb3BlZCBub2Rlc1xuICAgIHZhciBpbmRleCA9IGNvbmYuaW5kZXg7XG4gICAgLy8gQWxsIGF0dHJpYnV0ZXMgb24gdGhlIFRhZyB3aGVuIGl0J3MgZmlyc3QgcGFyc2VkXG4gICAgdmFyIGluc3RBdHRycyA9IFtdO1xuICAgIC8vIGV4cHJlc3Npb25zIG9uIHRoaXMgdHlwZSBvZiBUYWdcbiAgICB2YXIgaW1wbEF0dHJzID0gW107XG4gICAgdmFyIGV4cHJlc3Npb25zID0gW107XG4gICAgdmFyIHJvb3QgPSBjb25mLnJvb3Q7XG4gICAgdmFyIHRhZ05hbWUgPSBjb25mLnRhZ05hbWUgfHwgZ2V0TmFtZShyb290KTtcbiAgICB2YXIgaXNWaXJ0dWFsID0gdGFnTmFtZSA9PT0gJ3ZpcnR1YWwnO1xuICAgIHZhciBpc0lubGluZSA9ICFpc1ZpcnR1YWwgJiYgIWltcGwudG1wbDtcbiAgICB2YXIgZG9tO1xuXG4gICAgLy8gbWFrZSB0aGlzIHRhZyBvYnNlcnZhYmxlXG4gICAgaWYgKCFza2lwQW5vbnltb3VzKSB7IG9ic2VydmFibGUodGFnKTsgfVxuICAgIC8vIG9ubHkgY2FsbCB1bm1vdW50IGlmIHdlIGhhdmUgYSB2YWxpZCBfX1RBR19JTVBMIChoYXMgbmFtZSBwcm9wZXJ0eSlcbiAgICBpZiAoaW1wbC5uYW1lICYmIHJvb3QuX3RhZykgeyByb290Ll90YWcudW5tb3VudCh0cnVlKTsgfVxuXG4gICAgLy8gbm90IHlldCBtb3VudGVkXG4gICAgZGVmaW5lKHRhZywgJ2lzTW91bnRlZCcsIGZhbHNlKTtcblxuICAgIGRlZmluZSh0YWcsICdfXycsIHtcbiAgICAgIGltcGw6IGltcGwsXG4gICAgICByb290OiByb290LFxuICAgICAgc2tpcEFub255bW91czogc2tpcEFub255bW91cyxcbiAgICAgIGltcGxBdHRyczogaW1wbEF0dHJzLFxuICAgICAgaXNBbm9ueW1vdXM6IGlzQW5vbnltb3VzLFxuICAgICAgaW5zdEF0dHJzOiBpbnN0QXR0cnMsXG4gICAgICBpbm5lckhUTUw6IGlubmVySFRNTCxcbiAgICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgICBpbmRleDogaW5kZXgsXG4gICAgICBpc0xvb3A6IGlzTG9vcCxcbiAgICAgIGlzSW5saW5lOiBpc0lubGluZSxcbiAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgIC8vIHRhZ3MgaGF2aW5nIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgLy8gaXQgd291bGQgYmUgYmV0dGVyIHRvIHVzZSB3ZWFrIG1hcHMgaGVyZSBidXQgd2UgY2FuIG5vdCBpbnRyb2R1Y2UgYnJlYWtpbmcgY2hhbmdlcyBub3dcbiAgICAgIGxpc3RlbmVyczogW10sXG4gICAgICAvLyB0aGVzZSB2YXJzIHdpbGwgYmUgbmVlZGVkIG9ubHkgZm9yIHRoZSB2aXJ0dWFsIHRhZ3NcbiAgICAgIHZpcnRzOiBbXSxcbiAgICAgIHdhc0NyZWF0ZWQ6IGZhbHNlLFxuICAgICAgdGFpbDogbnVsbCxcbiAgICAgIGhlYWQ6IG51bGxcbiAgICB9KTtcblxuICAgIC8vIGNyZWF0ZSBhIHVuaXF1ZSBpZCB0byB0aGlzIHRhZ1xuICAgIC8vIGl0IGNvdWxkIGJlIGhhbmR5IHRvIHVzZSBpdCBhbHNvIHRvIGltcHJvdmUgdGhlIHZpcnR1YWwgZG9tIHJlbmRlcmluZyBzcGVlZFxuICAgIGRlZmluZSh0YWcsICdfcmlvdF9pZCcsIHVpZCgpKTsgLy8gYmFzZSAxIGFsbG93cyB0ZXN0ICF0Ll9yaW90X2lkXG4gICAgZGVmaW5lKHRhZywgJ3Jvb3QnLCByb290KTtcbiAgICBleHRlbmQodGFnLCB7IG9wdHM6IG9wdHMgfSwgaXRlbSk7XG4gICAgLy8gcHJvdGVjdCB0aGUgXCJ0YWdzXCIgYW5kIFwicmVmc1wiIHByb3BlcnR5IGZyb20gYmVpbmcgb3ZlcnJpZGRlblxuICAgIGRlZmluZSh0YWcsICdwYXJlbnQnLCBwYXJlbnQgfHwgbnVsbCk7XG4gICAgZGVmaW5lKHRhZywgJ3RhZ3MnLCB7fSk7XG4gICAgZGVmaW5lKHRhZywgJ3JlZnMnLCB7fSk7XG5cbiAgICBpZiAoaXNJbmxpbmUgfHwgaXNMb29wICYmIGlzQW5vbnltb3VzKSB7XG4gICAgICBkb20gPSByb290O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWlzVmlydHVhbCkgeyByb290LmlubmVySFRNTCA9ICcnOyB9XG4gICAgICBkb20gPSBta2RvbShpbXBsLnRtcGwsIGlubmVySFRNTCwgaXNTdmcocm9vdCkpO1xuICAgIH1cblxuICAgIGRlZmluZSh0YWcsICd1cGRhdGUnLCBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gY29tcG9uZW50VXBkYXRlKHRhZywgZGF0YSwgZXhwcmVzc2lvbnMpOyB9KTtcbiAgICBkZWZpbmUodGFnLCAnbWl4aW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbWl4aW5zID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoIGxlbi0tICkgbWl4aW5zWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgIHJldHVybiBjb21wb25lbnRNaXhpbi5hcHBseSh2b2lkIDAsIFsgdGFnIF0uY29uY2F0KCBtaXhpbnMgKSk7XG4gICAgfSk7XG4gICAgZGVmaW5lKHRhZywgJ21vdW50JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcG9uZW50TW91bnQodGFnLCBkb20sIGV4cHJlc3Npb25zLCBvcHRzKTsgfSk7XG4gICAgZGVmaW5lKHRhZywgJ3VubW91bnQnLCBmdW5jdGlvbiAobXVzdEtlZXBSb290KSB7IHJldHVybiB0YWdVbm1vdW50KHRhZywgbXVzdEtlZXBSb290LCBleHByZXNzaW9ucyk7IH0pO1xuXG4gICAgcmV0dXJuIHRhZ1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdW50IGEgdGFnIGNyZWF0aW5nIG5ldyBUYWcgaW5zdGFuY2VcbiAgICogQHBhcmFtICAgeyBPYmplY3QgfSByb290IC0gZG9tIG5vZGUgd2hlcmUgdGhlIHRhZyB3aWxsIGJlIG1vdW50ZWRcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSB0YWdOYW1lIC0gbmFtZSBvZiB0aGUgcmlvdCB0YWcgd2Ugd2FudCB0byBtb3VudFxuICAgKiBAcGFyYW0gICB7IE9iamVjdCB9IG9wdHMgLSBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIFRhZyBpbnN0YW5jZVxuICAgKiBAcGFyYW0gICB7IE9iamVjdCB9IGN0eCAtIG9wdGlvbmFsIGNvbnRleHQgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZXh0ZW5kIGFuIGV4aXN0aW5nIGNsYXNzICggdXNlZCBpbiByaW90LlRhZyApXG4gICAqIEByZXR1cm5zIHsgVGFnIH0gYSBuZXcgVGFnIGluc3RhbmNlXG4gICAqL1xuICBmdW5jdGlvbiBtb3VudCQxKHJvb3QsIHRhZ05hbWUsIG9wdHMsIGN0eCkge1xuICAgIHZhciBpbXBsID0gX19UQUdfSU1QTFt0YWdOYW1lXTtcbiAgICB2YXIgaW1wbENsYXNzID0gX19UQUdfSU1QTFt0YWdOYW1lXS5jbGFzcztcbiAgICB2YXIgY29udGV4dCA9IGN0eCB8fCAoaW1wbENsYXNzID8gY3JlYXRlKGltcGxDbGFzcy5wcm90b3R5cGUpIDoge30pO1xuICAgIC8vIGNhY2hlIHRoZSBpbm5lciBIVE1MIHRvIGZpeCAjODU1XG4gICAgdmFyIGlubmVySFRNTCA9IHJvb3QuX2lubmVySFRNTCA9IHJvb3QuX2lubmVySFRNTCB8fCByb290LmlubmVySFRNTDtcbiAgICB2YXIgY29uZiA9IGV4dGVuZCh7IHJvb3Q6IHJvb3QsIG9wdHM6IG9wdHMsIGNvbnRleHQ6IGNvbnRleHQgfSwgeyBwYXJlbnQ6IG9wdHMgPyBvcHRzLnBhcmVudCA6IG51bGwgfSk7XG4gICAgdmFyIHRhZztcblxuICAgIGlmIChpbXBsICYmIHJvb3QpIHsgdGFnID0gY3JlYXRlVGFnKGltcGwsIGNvbmYsIGlubmVySFRNTCk7IH1cblxuICAgIGlmICh0YWcgJiYgdGFnLm1vdW50KSB7XG4gICAgICB0YWcubW91bnQodHJ1ZSk7XG4gICAgICAvLyBhZGQgdGhpcyB0YWcgdG8gdGhlIHZpcnR1YWxEb20gdmFyaWFibGVcbiAgICAgIGlmICghY29udGFpbnMoX19UQUdTX0NBQ0hFLCB0YWcpKSB7IF9fVEFHU19DQUNIRS5wdXNoKHRhZyk7IH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFnXG4gIH1cblxuXG5cbiAgdmFyIHRhZ3MgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgYXJyYXlpc2hBZGQ6IGFycmF5aXNoQWRkLFxuICAgIGdldFRhZ05hbWU6IGdldE5hbWUsXG4gICAgaW5oZXJpdFBhcmVudFByb3BzOiBpbmhlcml0UGFyZW50UHJvcHMsXG4gICAgbW91bnRUbzogbW91bnQkMSxcbiAgICBzZWxlY3RUYWdzOiBxdWVyeSxcbiAgICBhcnJheWlzaFJlbW92ZTogYXJyYXlpc2hSZW1vdmUsXG4gICAgZ2V0VGFnOiBnZXQsXG4gICAgaW5pdENoaWxkVGFnOiBpbml0Q2hpbGQsXG4gICAgbW92ZUNoaWxkVGFnOiBtb3ZlQ2hpbGQsXG4gICAgbWFrZVJlcGxhY2VWaXJ0dWFsOiBtYWtlUmVwbGFjZVZpcnR1YWwsXG4gICAgZ2V0SW1tZWRpYXRlQ3VzdG9tUGFyZW50VGFnOiBnZXRJbW1lZGlhdGVDdXN0b21QYXJlbnQsXG4gICAgbWFrZVZpcnR1YWw6IG1ha2VWaXJ0dWFsLFxuICAgIG1vdmVWaXJ0dWFsOiBtb3ZlVmlydHVhbCxcbiAgICB1bm1vdW50QWxsOiB1bm1vdW50QWxsLFxuICAgIGNyZWF0ZUlmRGlyZWN0aXZlOiBjcmVhdGVJZkRpcmVjdGl2ZSxcbiAgICBjcmVhdGVSZWZEaXJlY3RpdmU6IGNyZWF0ZVJlZkRpcmVjdGl2ZVxuICB9KTtcblxuICAvKipcbiAgICogUmlvdCBwdWJsaWMgYXBpXG4gICAqL1xuICB2YXIgc2V0dGluZ3MkMSA9IHNldHRpbmdzO1xuICB2YXIgdXRpbCA9IHtcbiAgICB0bXBsOiB0bXBsLFxuICAgIGJyYWNrZXRzOiBicmFja2V0cyxcbiAgICBzdHlsZU1hbmFnZXI6IHN0eWxlTWFuYWdlcixcbiAgICB2ZG9tOiBfX1RBR1NfQ0FDSEUsXG4gICAgc3R5bGVOb2RlOiBzdHlsZU1hbmFnZXIuc3R5bGVOb2RlLFxuICAgIC8vIGV4cG9ydCB0aGUgcmlvdCBpbnRlcm5hbCB1dGlscyBhcyB3ZWxsXG4gICAgZG9tOiBkb20sXG4gICAgY2hlY2s6IGNoZWNrLFxuICAgIG1pc2M6IG1pc2MsXG4gICAgdGFnczogdGFnc1xuICB9O1xuXG4gIC8vIGV4cG9ydCB0aGUgY29yZSBwcm9wcy9tZXRob2RzXG4gIHZhciBUYWckMSA9IFRhZztcbiAgdmFyIHRhZyQxID0gdGFnO1xuICB2YXIgdGFnMiQxID0gdGFnMjtcbiAgdmFyIG1vdW50JDIgPSBtb3VudDtcbiAgdmFyIG1peGluJDEgPSBtaXhpbjtcbiAgdmFyIHVwZGF0ZSQyID0gdXBkYXRlJDE7XG4gIHZhciB1bnJlZ2lzdGVyJDEgPSB1bnJlZ2lzdGVyO1xuICB2YXIgdmVyc2lvbiQxID0gdmVyc2lvbjtcbiAgdmFyIG9ic2VydmFibGUkMSA9IG9ic2VydmFibGU7XG5cbiAgdmFyIHJpb3QkMSA9IGV4dGVuZCh7fSwgY29yZSwge1xuICAgIG9ic2VydmFibGU6IG9ic2VydmFibGUsXG4gICAgc2V0dGluZ3M6IHNldHRpbmdzJDEsXG4gICAgdXRpbDogdXRpbCxcbiAgfSlcblxuICBleHBvcnRzLnNldHRpbmdzID0gc2V0dGluZ3MkMTtcbiAgZXhwb3J0cy51dGlsID0gdXRpbDtcbiAgZXhwb3J0cy5UYWcgPSBUYWckMTtcbiAgZXhwb3J0cy50YWcgPSB0YWckMTtcbiAgZXhwb3J0cy50YWcyID0gdGFnMiQxO1xuICBleHBvcnRzLm1vdW50ID0gbW91bnQkMjtcbiAgZXhwb3J0cy5taXhpbiA9IG1peGluJDE7XG4gIGV4cG9ydHMudXBkYXRlID0gdXBkYXRlJDI7XG4gIGV4cG9ydHMudW5yZWdpc3RlciA9IHVucmVnaXN0ZXIkMTtcbiAgZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbiQxO1xuICBleHBvcnRzLm9ic2VydmFibGUgPSBvYnNlcnZhYmxlJDE7XG4gIGV4cG9ydHMuZGVmYXVsdCA9IHJpb3QkMTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmlvdC9yaW90LmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n")},,,,,,,,,function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _riot = __webpack_require__(0);\n\nvar _riot2 = _interopRequireDefault(_riot);\n\n__webpack_require__(10);\n\n__webpack_require__(11);\n\n__webpack_require__(12);\n\n__webpack_require__(13);\n\n__webpack_require__(14);\n\n__webpack_require__(15);\n\n__webpack_require__(16);\n\n__webpack_require__(17);\n\n__webpack_require__(18);\n\n__webpack_require__(19);\n\n__webpack_require__(20);\n\n__webpack_require__(21);\n\n__webpack_require__(22);\n\n__webpack_require__(23);\n\n__webpack_require__(24);\n\n__webpack_require__(25);\n\n__webpack_require__(26);\n\n__webpack_require__(27);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_riot2.default.mount('*');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9pbmRleC5qcz82YzY2Il0sIm5hbWVzIjpbIm1vdW50Il0sIm1hcHBpbmdzIjoiOztBQUFBOzs7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFFQSxlQUFLQSxLQUFMLENBQVcsR0FBWCIsImZpbGUiOiI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHJpb3QgZnJvbSAncmlvdCdcbmltcG9ydCBcInJpb3QtaG90LXJlbG9hZFwiXG5cbmltcG9ydCAnLi90YWdzL3RvZG8udGFnJ1xuaW1wb3J0ICcuL3RhZ3MvaWNvbi50YWcnXG5pbXBvcnQgJy4vY2FyZHMvYnQtY2FyZHMtZWxtLnRhZydcbmltcG9ydCAnLi91cGxvYWRzL2J0LXVwbG9hZC50YWcnXG5pbXBvcnQgJy4vdXBsb2Fkcy9idC11cGxvYWQtcm91bmRlZC50YWcnXG5pbXBvcnQgJy4vY29uZmlybS1hY3Rpb25zL2J0LWNvbmZpcm0tYWN0aW9uLnRhZydcbmltcG9ydCAnLi9zY3JvbGwvYnQtc2Nyb2xsLXVwLnRhZydcbmltcG9ydCAnLi9pbWFnZXMvYnQtaW1hZ2UudGFnJ1xuaW1wb3J0ICcuL2VsbS9idC1lbG0tbGVhZC50YWcnXG5pbXBvcnQgJy4vdHJ1bmNhdGUvYnQtdHJ1bmNhdGUudGFnJ1xuaW1wb3J0ICcuL3N2Z3MvYnQtc3ZnLWljb24udGFnJ1xuaW1wb3J0ICcuL3N2Z3MvYnQtaWNvbi50YWcnXG5pbXBvcnQgJy4vc3Zncy9idC1pY29uLWJ5dGVzLnRhZydcbmltcG9ydCAnLi9zdmdzL2J0LWljb24tbWF0ZXJpYWwudGFnJ1xuaW1wb3J0ICcuL2xvYWRlcnMvc3Bpbi1sb2FkZXIvYnQtbG9hZGVyLXNwaW4udGFnJ1xuaW1wb3J0ICcuL3NlbGVjdGlvbnMvZHJvcGRvd24vYnQtZHJvcGRvd24udGFnJ1xuaW1wb3J0ICcuL2xvYWRlcnMvcHJvY2Vzc2luZy9idC1sb2FkZXItcHJvY2Vzc2luZy50YWcnXG5cbnJpb3QubW91bnQoJyonKVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbXBvbmVudHMvaW5kZXguanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9\n")},function(module,exports,__webpack_require__){eval("(function (global, factory) {\n\t true ? factory(exports, __webpack_require__(0)) :\n\ttypeof define === 'function' && define.amd ? define(['exports', 'riot'], factory) :\n\t(factory((global.riotHotReload = global.riotHotReload || {}),global.riot));\n}(this, (function (exports,riot) { 'use strict';\n\nvar nonState = 'isMounted opts'.split(' ');\n\nfunction reload(name) {\n  riot.util.styleManager.inject();\n\n  var elems = document.querySelectorAll((name + \", [data-is=\" + name + \"]\"));\n  var tags = [];\n\n  for (var i = 0; i < elems.length; i++) {\n    var el = elems[i], oldTag = el._tag, v;\n    reload.trigger('before-unmount', oldTag);\n    oldTag.unmount(true); // detach the old tag\n\n    // reset the innerHTML and attributes to how they were before mount\n    el.innerHTML = oldTag.__.innerHTML;\n    (oldTag.__.instAttrs || []).map(function(attr) {\n      el.setAttribute(attr.name, attr.value);\n    });\n\n    // copy options for creating the new tag\n    var newOpts = {};\n    for(key in oldTag.opts) {\n      newOpts[key] = oldTag.opts[key];\n    }\n    newOpts.parent = oldTag.parent;\n\n    // create the new tag\n    reload.trigger('before-mount', newOpts, oldTag);\n    var newTag = riot.mount(el, newOpts)[0];\n\n    // copy state from the old to new tag\n    for(var key in oldTag) {\n      v = oldTag[key];\n      if (~nonState.indexOf(key)) { continue }\n      newTag[key] = v;\n    }\n    newTag.update();\n    tags.push(newTag);\n    reload.trigger('after-mount', newTag, oldTag);\n  }\n\n  return tags\n}\n\nriot.observable(reload);\nriot.reload = reload;\nif (riot.default) { riot.default.reload = reload; }\n\nexports.reload = reload;\nexports['default'] = reload;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmlvdC1ob3QtcmVsb2FkL2luZGV4LmpzPzc2OTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVELENBQUMsaUNBQWlDOztBQUVsQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQiw4QkFBOEI7O0FBRWpEO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7O0FBRTVELENBQUMiLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ3Jpb3QnKSkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ3Jpb3QnXSwgZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgoZ2xvYmFsLnJpb3RIb3RSZWxvYWQgPSBnbG9iYWwucmlvdEhvdFJlbG9hZCB8fCB7fSksZ2xvYmFsLnJpb3QpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLHJpb3QpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgbm9uU3RhdGUgPSAnaXNNb3VudGVkIG9wdHMnLnNwbGl0KCcgJyk7XG5cbmZ1bmN0aW9uIHJlbG9hZChuYW1lKSB7XG4gIHJpb3QudXRpbC5zdHlsZU1hbmFnZXIuaW5qZWN0KCk7XG5cbiAgdmFyIGVsZW1zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgobmFtZSArIFwiLCBbZGF0YS1pcz1cIiArIG5hbWUgKyBcIl1cIikpO1xuICB2YXIgdGFncyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWwgPSBlbGVtc1tpXSwgb2xkVGFnID0gZWwuX3RhZywgdjtcbiAgICByZWxvYWQudHJpZ2dlcignYmVmb3JlLXVubW91bnQnLCBvbGRUYWcpO1xuICAgIG9sZFRhZy51bm1vdW50KHRydWUpOyAvLyBkZXRhY2ggdGhlIG9sZCB0YWdcblxuICAgIC8vIHJlc2V0IHRoZSBpbm5lckhUTUwgYW5kIGF0dHJpYnV0ZXMgdG8gaG93IHRoZXkgd2VyZSBiZWZvcmUgbW91bnRcbiAgICBlbC5pbm5lckhUTUwgPSBvbGRUYWcuX18uaW5uZXJIVE1MO1xuICAgIChvbGRUYWcuX18uaW5zdEF0dHJzIHx8IFtdKS5tYXAoZnVuY3Rpb24oYXR0cikge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHIubmFtZSwgYXR0ci52YWx1ZSk7XG4gICAgfSk7XG5cbiAgICAvLyBjb3B5IG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSBuZXcgdGFnXG4gICAgdmFyIG5ld09wdHMgPSB7fTtcbiAgICBmb3Ioa2V5IGluIG9sZFRhZy5vcHRzKSB7XG4gICAgICBuZXdPcHRzW2tleV0gPSBvbGRUYWcub3B0c1trZXldO1xuICAgIH1cbiAgICBuZXdPcHRzLnBhcmVudCA9IG9sZFRhZy5wYXJlbnQ7XG5cbiAgICAvLyBjcmVhdGUgdGhlIG5ldyB0YWdcbiAgICByZWxvYWQudHJpZ2dlcignYmVmb3JlLW1vdW50JywgbmV3T3B0cywgb2xkVGFnKTtcbiAgICB2YXIgbmV3VGFnID0gcmlvdC5tb3VudChlbCwgbmV3T3B0cylbMF07XG5cbiAgICAvLyBjb3B5IHN0YXRlIGZyb20gdGhlIG9sZCB0byBuZXcgdGFnXG4gICAgZm9yKHZhciBrZXkgaW4gb2xkVGFnKSB7XG4gICAgICB2ID0gb2xkVGFnW2tleV07XG4gICAgICBpZiAofm5vblN0YXRlLmluZGV4T2Yoa2V5KSkgeyBjb250aW51ZSB9XG4gICAgICBuZXdUYWdba2V5XSA9IHY7XG4gICAgfVxuICAgIG5ld1RhZy51cGRhdGUoKTtcbiAgICB0YWdzLnB1c2gobmV3VGFnKTtcbiAgICByZWxvYWQudHJpZ2dlcignYWZ0ZXItbW91bnQnLCBuZXdUYWcsIG9sZFRhZyk7XG4gIH1cblxuICByZXR1cm4gdGFnc1xufVxuXG5yaW90Lm9ic2VydmFibGUocmVsb2FkKTtcbnJpb3QucmVsb2FkID0gcmVsb2FkO1xuaWYgKHJpb3QuZGVmYXVsdCkgeyByaW90LmRlZmF1bHQucmVsb2FkID0gcmVsb2FkOyB9XG5cbmV4cG9ydHMucmVsb2FkID0gcmVsb2FkO1xuZXhwb3J0c1snZGVmYXVsdCddID0gcmVsb2FkO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmlvdC1ob3QtcmVsb2FkL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///10\n")},function(module,exports,__webpack_require__){eval("\n    var riot = __webpack_require__(0)\n    riot.tag2('bt-todo', '<p id=\"findMe\" class=\"title is-1\">Demo Components : {opts.hello}</p>', 'bt-todo #findMe,[data-is=\"bt-todo\"] #findMe{ color: blue; } bt-todo #findMe.title,[data-is=\"bt-todo\"] #findMe.title{ text-transform: uppercase; }', '', function(opts) {\n\n   this.on('mount', function() {\n    var test3 = document.getElementById('findMe')\n    console.log('mount...', test3, opts.hello)\n  })\n\n});\n\n    \n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy90YWdzL3RvZG8udGFnP2YxMzgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBeUJBO0NBUE07Q0FIRjtBQVFGO0NBZEEiLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8YnQtdG9kbz5cblxuICA8cCBpZD1cImZpbmRNZVwiIGNsYXNzPVwidGl0bGUgaXMtMVwiPkRlbW8gQ29tcG9uZW50cyA6IHtvcHRzLmhlbGxvfTwvcD5cblxuICA8c2NyaXB0PlxuXG4gICB0aGlzLm9uKCdtb3VudCcsIGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ZXN0MyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmaW5kTWUnKVxuICAgIGNvbnNvbGUubG9nKCdtb3VudC4uLicsIHRlc3QzLCBvcHRzLmhlbGxvKVxuICB9KVxuXG5cbiAgPC9zY3JpcHQ+XG4gIDxzdHlsZSB0eXBlPVwidGV4dC9zY3NzXCI+XG5cbiAgICAjZmluZE1lIHtcbiAgICAgIGNvbG9yOiBibHVlO1xuXG4gICAgICAmLnRpdGxlIHtcbiAgICAgICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgPC9zdHlsZT5cblxuPC9idC10b2RvPlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbXBvbmVudHMvdGFncy90b2RvLnRhZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///11\n")},function(module,exports,__webpack_require__){eval("\n    var riot = __webpack_require__(0)\n    riot.tag2('bt-icon', '<svg class=\"{class}\"> <use xmlnsxlink http: www w3 org 1999 xlink xlink:href=\"{icon}\"></use> </svg>', '', 'class=\"components\"', function(opts) {\n\n\t\tthis.url = opts.url || '/icons/bytesize-symbols.min.svg#'\n\t\tthis.icon = this.url + opts.svg\n\t\tthis.class = opts.classNames ? 'animated fadeIn '+opts.classNames : 'svg-elm-64 animated fadeIn'\n\t\tconst getSvg = document.querySelector('use')\n\n\t\tconsole.log('svg', getSvg);\n\n});\n\n    \n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy90YWdzL2ljb24udGFnPzU3NjYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBRUU7Q0FJQTtDQVFGO0FBTkU7Q0FDQTtDQUVBIiwiZmlsZSI6IjEyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiPGJ0LWljb24gY2xhc3M9XCJjb21wb25lbnRzXCI+XG5cdDxzdmcgY2xhc3M9e2NsYXNzIH0+XG5cdFx0PHVzZSB4bWxuc1hsaW5rXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgeGxpbms6aHJlZj17IGljb24gfT48L3VzZT5cblx0PC9zdmc+XG5cdDxzY3JpcHQ+XG5cblx0XHR0aGlzLnVybCA9IG9wdHMudXJsIHx8ICcvaWNvbnMvYnl0ZXNpemUtc3ltYm9scy5taW4uc3ZnIydcblx0XHR0aGlzLmljb24gPSB0aGlzLnVybCArIG9wdHMuc3ZnXG5cdFx0dGhpcy5jbGFzcyA9IG9wdHMuY2xhc3NOYW1lcyA/ICdhbmltYXRlZCBmYWRlSW4gJytvcHRzLmNsYXNzTmFtZXMgOiAnc3ZnLWVsbS02NCBhbmltYXRlZCBmYWRlSW4nXG5cdFx0Y29uc3QgZ2V0U3ZnID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcigndXNlJylcblxuXHRcdGNvbnNvbGUubG9nKCdzdmcnLCBnZXRTdmcpO1xuXG5cdDwvc2NyaXB0PlxuPC9idC1pY29uPlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbXBvbmVudHMvdGFncy9pY29uLnRhZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///12\n")},function(module,exports,__webpack_require__){eval('\n    var riot = __webpack_require__(0)\n    riot.tag2(\'bt-card\', \'<div class="{cardClasses}"> <yield from="header"></yield> <div class="{opts.contentClasses || ⁗card-elm-content⁗}"> <yield></yield> </div> <yield from="footer"></yield> </div>\', \'bt-card .card-elm,[data-is="bt-card"] .card-elm,bt-card .card-elm-content > *,[data-is="bt-card"] .card-elm-content > *{ display: flex; align-items: center; justify-content: center; height: 100%; width: 100%; } bt-card .card-elm > *,[data-is="bt-card"] .card-elm > *,bt-card .card-elm-content > * > *,[data-is="bt-card"] .card-elm-content > * > *{ padding: 0 0px; flex-grow: 1; } bt-card .card-elm-header,[data-is="bt-card"] .card-elm-header{ justify-content: flex-start; } bt-card .card-elm,[data-is="bt-card"] .card-elm,bt-card .card-elm-content > *,[data-is="bt-card"] .card-elm-content > *{ flex-direction: column; overflow: hidden; } bt-card .card-elm,[data-is="bt-card"] .card-elm{ box-shadow: 1px 2px 6px rgba(0, 0, 0, 0.2); } bt-card bts-card-elm,[data-is="bt-card"] bts-card-elm,bt-card bts-card-elm-header,[data-is="bt-card"] bts-card-elm-header,bt-card bts-card-elm-content,[data-is="bt-card"] bts-card-elm-content{ width: 100%; height: 100%; } bt-card .card-elm,[data-is="bt-card"] .card-elm{ border-radius: 2px; } bt-card .card-elm > *,[data-is="bt-card"] .card-elm > *{ width: 100% important; padding: 0; margin: 0; } bt-card .card-elm-header,[data-is="bt-card"] .card-elm-header{ padding: 10px 20px; font-weight: 500; width: 100% important; } bt-card .card-elm-content,[data-is="bt-card"] .card-elm-content{ height: 100% important; } bt-card .card-elm-content > *,[data-is="bt-card"] .card-elm-content > *{ padding: 20px 20px; }\', \'\', function(opts) {\n\t\tconst customClasses = opts.elmClass || "";\n\t\tthis.cardClasses = "card-elm " + customClasses;\n});\n\n    \n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9jYXJkcy9idC1jYXJkcy1lbG0udGFnPzYxZmUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBT0M7Q0FPQTtDQUNEIiwiZmlsZSI6IjEzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiPGJ0LWNhcmQ+XG5cdDxkaXYgY2xhc3M9eyBjYXJkQ2xhc3NlcyB9PlxuXHRcdDx5aWVsZCBmcm9tPVwiaGVhZGVyXCI+PC95aWVsZD5cblx0XHQ8ZGl2IGNsYXNzPXsgb3B0cy5jb250ZW50Q2xhc3NlcyB8fCBcImNhcmQtZWxtLWNvbnRlbnRcIn0+XG5cdFx0XHQ8eWllbGQ+PC95aWVsZD5cblx0XHQ8L2Rpdj5cblx0XHQ8eWllbGQgZnJvbT1cImZvb3RlclwiPjwveWllbGQ+XG5cdDwvZGl2PlxuXHQ8c2NyaXB0PlxuXHRcdGNvbnN0IGN1c3RvbUNsYXNzZXMgPSBvcHRzLmVsbUNsYXNzIHx8IFwiXCI7XG5cdFx0dGhpcy5jYXJkQ2xhc3NlcyA9IFwiY2FyZC1lbG0gXCIgKyBjdXN0b21DbGFzc2VzO1xuXHQ8L3NjcmlwdD5cblx0PHN0eWxlIHR5cGU9XCJ0ZXh0L3Njc3NcIj5cblx0QGltcG9ydCBcIi4vX2NhcmRzLnNjc3NcIjtcblx0PC9zdHlsZT5cbjwvYnQtY2FyZD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21wb25lbnRzL2NhcmRzL2J0LWNhcmRzLWVsbS50YWciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///13\n')},function(module,exports,__webpack_require__){eval('\n    var riot = __webpack_require__(0)\n    riot.tag2(\'bt-upload\', \'<div class="upload-elm"> <label for="{opts.fieldName || ⁗upload⁗}" class="{uploadStyle}"> <input type="file" class="{opts.fileClass || ⁗file-elm⁗}" name="{opts.fieldName || ⁗upload⁗}" change="{detectChange}"> <span class="{labelStyle}"> <div class="upload"> <yield>Upload</yield> </div> </span> <span class="file-elm-placeholder"> <div class="placeholder">{placeholder}</div> </span> </label> </div>\', \'bt-upload,[data-is="bt-upload"],bt-upload .upload-elm,[data-is="bt-upload"] .upload-elm,bt-upload .upload-elm [type=file],[data-is="bt-upload"] .upload-elm [type=file],bt-upload .upload-elm label,[data-is="bt-upload"] .upload-elm label,bt-upload .file-elm-placeholder,[data-is="bt-upload"] .file-elm-placeholder{ width: 100%; } bt-upload,[data-is="bt-upload"],bt-upload .upload-elm,[data-is="bt-upload"] .upload-elm,bt-upload .upload-elm [type=file],[data-is="bt-upload"] .upload-elm [type=file],bt-upload .upload-elm label,[data-is="bt-upload"] .upload-elm label,bt-upload .file-elm-placeholder,[data-is="bt-upload"] .file-elm-placeholder{ height: 100%; } bt-upload .file-elm-label,[data-is="bt-upload"] .file-elm-label{ overflow: hidden; white-space: nowrap; text-overflow: ellipsis; width: 100%; } bt-upload .upload-elm,[data-is="bt-upload"] .upload-elm{ position: relative; height: 50px; } bt-upload .upload-elm [type=file],[data-is="bt-upload"] .upload-elm [type=file]{ left: 0; outline: none; position: absolute; top: 0; opacity: 0; cursor: pointer; } bt-upload .upload-elm label,[data-is="bt-upload"] .upload-elm label{ display: flex; align-items: stretch; justify-content: flex-start; overflow: hidden; } bt-upload .file-elm-label,[data-is="bt-upload"] .file-elm-label{ display: flex; align-items: center; justify-content: center; min-width: 18%; max-width: 20%; padding: 0 20px; } bt-upload .file-elm-placeholder,[data-is="bt-upload"] .file-elm-placeholder{ display: flex; align-items: center; padding: 0 20px; }\', \'\', function(opts) {\n\n\t\tconst placeHolder = opts.uploadPlaceholder || "Please select a file to upload";\n\t\tconst placeHolderClass = opts.placeholderClasses || "file-elm-placeholder";\n\t\tconst elmColor = opts.color || "lightgray";\n\t\tconst labelClass = opts.labelClasses || "";\n\t\tconst classes = opts.elmClass || ""\n\n\t\tthis.placeholder = placeHolder;\n\t\tthis.labelStyle = "file-elm-label " + labelClass + " " + elmColor+"-elm";\n\t\tthis.uploadStyle = \'elm-border elm-border-\'+ elmColor + " " + classes;\n\n\t\tthis.detectChange = function(e)\n\t\t{\n\t\t\tthis.placeholder = e.target.files[0].name;\n\t\t}.bind(this)\n\n});\n\n    \n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy91cGxvYWRzL2J0LXVwbG9hZC50YWc/MDFlNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUErQkU7Q0FiQTtDQUNBO0FBQ0E7Q0FDQTtDQVlEO0NBVEM7Q0FDQTtDQWNGO0FBWEU7O0NBRUMiLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8YnQtdXBsb2FkPlxuXG5cdDxkaXYgY2xhc3M9XCJ1cGxvYWQtZWxtXCI+XG5cdFx0PGxhYmVsIGZvcj17IG9wdHMuZmllbGROYW1lIHx8IFwidXBsb2FkXCIgfSBjbGFzcz17IHVwbG9hZFN0eWxlIH0+XG5cdFx0XHQ8aW5wdXQgdHlwZT1cImZpbGVcIiBjbGFzcz17IG9wdHMuZmlsZUNsYXNzIHx8IFwiZmlsZS1lbG1cIiB9IG5hbWU9eyBvcHRzLmZpZWxkTmFtZSB8fCBcInVwbG9hZFwiIH0gY2hhbmdlPXsgZGV0ZWN0Q2hhbmdlIH0gPlxuXHRcdFx0PHNwYW4gY2xhc3M9eyBsYWJlbFN0eWxlIH0+XG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJ1cGxvYWRcIj5cblx0XHRcdFx0XHRcdDx5aWVsZD5VcGxvYWQ8L3lpZWxkPlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdDwvc3Bhbj5cblx0XHRcdDxzcGFuIGNsYXNzPVwiZmlsZS1lbG0tcGxhY2Vob2xkZXJcIj5cblx0XHRcdFx0PGRpdiBjbGFzcz1cInBsYWNlaG9sZGVyXCI+eyBwbGFjZWhvbGRlciB9PC9kaXY+XG5cdFx0XHQ8L3NwYW4+XG5cdFx0PC9sYWJlbD5cblx0PC9kaXY+XG5cblx0PHNjcmlwdD5cblxuXHRcdGNvbnN0IHBsYWNlSG9sZGVyID0gb3B0cy51cGxvYWRQbGFjZWhvbGRlciB8fCBcIlBsZWFzZSBzZWxlY3QgYSBmaWxlIHRvIHVwbG9hZFwiO1xuXHRcdGNvbnN0IHBsYWNlSG9sZGVyQ2xhc3MgPSBvcHRzLnBsYWNlaG9sZGVyQ2xhc3NlcyB8fCBcImZpbGUtZWxtLXBsYWNlaG9sZGVyXCI7XG5cdFx0Y29uc3QgZWxtQ29sb3IgPSBvcHRzLmNvbG9yIHx8IFwibGlnaHRncmF5XCI7XG5cdFx0Y29uc3QgbGFiZWxDbGFzcyA9IG9wdHMubGFiZWxDbGFzc2VzIHx8IFwiXCI7XG5cdFx0Y29uc3QgY2xhc3NlcyA9IG9wdHMuZWxtQ2xhc3MgfHwgXCJcIlxuXG5cdFx0dGhpcy5wbGFjZWhvbGRlciA9IHBsYWNlSG9sZGVyO1xuXHRcdHRoaXMubGFiZWxTdHlsZSA9IFwiZmlsZS1lbG0tbGFiZWwgXCIgKyBsYWJlbENsYXNzICsgXCIgXCIgKyBlbG1Db2xvcitcIi1lbG1cIjtcblx0XHR0aGlzLnVwbG9hZFN0eWxlID0gJ2VsbS1ib3JkZXIgZWxtLWJvcmRlci0nKyBlbG1Db2xvciArIFwiIFwiICsgY2xhc3NlcztcblxuXHRcdGRldGVjdENoYW5nZShlKVxuXHRcdHtcblx0XHRcdHRoaXMucGxhY2Vob2xkZXIgPSBlLnRhcmdldC5maWxlc1swXS5uYW1lO1xuXHRcdH1cblxuXHQ8L3NjcmlwdD5cblxuXHQ8c3R5bGUgdHlwZT1cInRleHQvc2Nzc1wiPlxuXHRAaW1wb3J0IFwiLi9fc3R5bGUuc2Nzc1wiXG5cdDwvc3R5bGU+XG5cbjwvYnQtdXBsb2FkPlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbXBvbmVudHMvdXBsb2Fkcy9idC11cGxvYWQudGFnIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///14\n')},function(module,exports,__webpack_require__){eval('\n    var riot = __webpack_require__(0)\n    riot.tag2(\'bt-upload-rounded\', \'<div data-is="bt-upload" color="{opts.color || ⁗red⁗}" elm-class="{styles}" placeholder-classes="{placeholderClasses || ⁗file-elm-placeholder⁗}" label-classes="{opts.labelClasses || ⁗⁗}" upload-placeholder="{opts.placeholder || ⁗Please select a file to upload⁗}"> <yield></yield> </div>\', \'\', \'\', function(opts) {\n\t\tconst classes = opts.elmClass || \'\';\n\t\tthis.styles = "elm-rds-rounded " + classes;\n});\n\n    \n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy91cGxvYWRzL2J0LXVwbG9hZC1yb3VuZGVkLnRhZz9jYTk4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQVNDO0NBSUE7Q0FDRCIsImZpbGUiOiIxNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIjxidC11cGxvYWQtcm91bmRlZD5cblx0PGRpdlxuXHRkYXRhLWlzPVwiYnQtdXBsb2FkXCJcblx0Y29sb3I9eyBvcHRzLmNvbG9yIHx8IFwicmVkXCIgfVxuXHRlbG0tY2xhc3M9eyBzdHlsZXMgfVxuXHRwbGFjZWhvbGRlci1jbGFzc2VzPXsgcGxhY2Vob2xkZXJDbGFzc2VzIHx8IFwiZmlsZS1lbG0tcGxhY2Vob2xkZXJcIiB9XG5cdGxhYmVsLWNsYXNzZXM9eyBvcHRzLmxhYmVsQ2xhc3NlcyB8fCBcIlwiIH1cbiAgICB1cGxvYWQtcGxhY2Vob2xkZXI9eyBvcHRzLnBsYWNlaG9sZGVyIHx8IFwiUGxlYXNlIHNlbGVjdCBhIGZpbGUgdG8gdXBsb2FkXCJ9IH0+XG5cdFx0PHlpZWxkPjwveWllbGQ+XG5cdDwvZGl2PlxuXHQ8c2NyaXB0PlxuXHRcdGNvbnN0IGNsYXNzZXMgPSBvcHRzLmVsbUNsYXNzIHx8ICcnO1xuXHRcdHRoaXMuc3R5bGVzID0gXCJlbG0tcmRzLXJvdW5kZWQgXCIgKyBjbGFzc2VzO1xuXHQ8L3NjcmlwdD5cbjwvYnQtdXBsb2FkLXJvdW5kZWQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29tcG9uZW50cy91cGxvYWRzL2J0LXVwbG9hZC1yb3VuZGVkLnRhZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///15\n')},function(module,exports,__webpack_require__){eval('\n    var riot = __webpack_require__(0)\n    riot.tag2(\'bt-btn-confirm\', \'<a if="{urlLink}" href="{urlLink}" onclick="{handleClickActions}" class="confirm-link {elmClass}"> {buttonLabel} </a> <button if="{!urlLink}" type="{opts.type || ⁗submit⁗}" class="confirm-button {elmClass}" onclick="{handleClickActions}"> {buttonLabel} </button>\', \'bt-btn-confirm,[data-is="bt-btn-confirm"]{ display: inline-block }\', \'\', function(opts) {\nconst classes = opts.elmClass || "";\n\n\t\tthis.urlLink = opts.url || "";\n\t\tthis.buttonLabel = opts.label || "Delete";\n\t\tthis.confirmation = opts.confirmation || "Confirm";\n\t\tthis.timer = opts.timeout || 3000;\n\t\tthis.elmClass = \'button \' + classes;\n\n\t\tthis.handleClickActions = function(e) {\n\t\t\tconst elm = e.target;\n\n\t\t\tif (this.confirmation === elm.textContent.trim()) {\n\t\t\t\telm.textContent = this.buttonLabel;\n\t\t\t} else {\n\n\t\t\t\telm.textContent = this.confirmation;\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\telm.textContent = this.buttonLabel;\n\t\t\t\t}, this.timer);\n\t\t\t\te.preventDefault();\n\t\t\t}\n\t\t}.bind(this)\n\n\t\tthis.on(\'mount\', () => {\n\n\t\t});\n});\n\n    \n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9jb25maXJtLWFjdGlvbnMvYnQtY29uZmlybS1hY3Rpb24udGFnPzI5MzEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBYUU7Q0FGQTtDQUNDOzs7O0NBSkY7O0NBTUE7O0FBUEM7O0NBV0YiLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8YnQtYnRuLWNvbmZpcm0+XG5cblx0PGEgaWY9eyB1cmxMaW5rIH0gaHJlZj1cInsgdXJsTGluayB9XCIgb25jbGljaz17IGhhbmRsZUNsaWNrQWN0aW9ucyB9IGNsYXNzPVwiY29uZmlybS1saW5rIHsgZWxtQ2xhc3MgfVwiPlxuXHRcdHsgYnV0dG9uTGFiZWwgfVxuXHQ8L2E+XG5cblx0PGJ1dHRvbiBpZj17ICF1cmxMaW5rIH0gdHlwZT17IG9wdHMudHlwZSB8fCBcInN1Ym1pdFwiIH0gY2xhc3M9XCJjb25maXJtLWJ1dHRvbiB7IGVsbUNsYXNzIH1cIiBvbmNsaWNrPXsgaGFuZGxlQ2xpY2tBY3Rpb25zIH0+XG5cdFx0eyBidXR0b25MYWJlbCB9XG5cdDwvYnV0dG9uPlxuXG5cdDxzdHlsZT5cblx0XHQ6c2NvcGUge1xuXHRcdFx0ZGlzcGxheTogaW5saW5lLWJsb2NrXG5cdFx0fVxuXHQ8L3N0eWxlPlxuXG5cdDxzY3JpcHQgc3JjPVwiLi9jb25maXJtLmpzXCI+PC9zY3JpcHQ+XG5cbjwvYnQtYnRuLWNvbmZpcm0+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29tcG9uZW50cy9jb25maXJtLWFjdGlvbnMvYnQtY29uZmlybS1hY3Rpb24udGFnIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///16\n')},function(module,exports,__webpack_require__){eval('\n    var riot = __webpack_require__(0)\n    riot.tag2(\'bt-scroll-up\', \'<div> <a href="#body" data-scroll class="{toggleButton + ⁗ ⁗ + classes}"> <yield></yield> </a> </div>\', \'bt-scroll-up .back-to-top,[data-is="bt-scroll-up"] .back-to-top{ position: fixed; z-index: 7; bottom: 160px; right: 60px; transition: all 0.7s ease; } bt-scroll-up a.back-to-top,[data-is="bt-scroll-up"] a.back-to-top{ color: gray; } bt-scroll-up a.back-to-top:hover,[data-is="bt-scroll-up"] a.back-to-top:hover{ color: #1a1a1a; }\', \'\', function(opts) {\nthis.toggleButton = "elm-hide";\nthis.classes = opts.elmClass || "back-to-top animated bounceInUp";\n\nconst screenH = window.innerHeight;\n\nthis.on("mount", () => {\n  elm = this.root.querySelector(".back-to-top");\n\n  window.addEventListener("scroll", e => {\n    if (window.pageYOffset > screenH) {\n      elm.classList.remove("elm-hide");\n    } else {\n      elm.classList.add("elm-hide");\n    }\n  });\n});\n});\n\n    \n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9zY3JvbGwvYnQtc2Nyb2xsLXVwLnRhZz8xNTEwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUtDO0NBTUE7Ozs7O0NBQ0Q7QUFKQzs7Q0FMRSIsImZpbGUiOiIxNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIjxidC1zY3JvbGwtdXA+XG5cdDxkaXY+XG5cdFx0PGEgaHJlZj1cIiNib2R5XCIgZGF0YS1zY3JvbGwgY2xhc3M9eyB0b2dnbGVCdXR0b24gKyBcIiBcIiArIGNsYXNzZXMgfT5cblx0XHRcdDx5aWVsZD48L3lpZWxkPlxuXHRcdDwvYT5cblx0PC9kaXY+XG5cdDxzY3JpcHQgc3JjPVwiLi9pbmRleC5qc1wiPlxuXG5cdDwvc2NyaXB0PlxuXHQ8c3R5bGUgdHlwZT1cInNjc3NcIj5cblx0QGltcG9ydCBcIi4vc2Nyb2xsXCI7XG5cdDwvc3R5bGU+XG48L2J0LXNjcm9sbC11cD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21wb25lbnRzL3Njcm9sbC9idC1zY3JvbGwtdXAudGFnIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///17\n')},function(module,exports,__webpack_require__){eval('\n    var riot = __webpack_require__(0)\n    riot.tag2(\'bt-image\', \'<figure class="animated fadeIn figure-elm {elmClass}" riot-style="{styles}"> <img riot-src="{opts.src || src}" alt="{opts.alt}" class="img-elm"> <figcaption class="{captionStyle}"> <yield></yield> </figcaption> </figure>\', \'bt-image .figure-elm,[data-is="bt-image"] .figure-elm{ overflow: hidden; position: relative; display: inline-block; margin: 0; padding: 0; } bt-image .figure-elm *,[data-is="bt-image"] .figure-elm *{ -webkit-transition: all 0.35s; transition: all 0.35s; -webkit-box-sizing: border-box; box-sizing: border-box; } bt-image .figure-elm figcaption,[data-is="bt-image"] .figure-elm figcaption{ color: azure; position: absolute; top: 0; bottom: 5px; left: 0; right: 0; padding: 20px; background-image: -webkit-linear-gradient(bottom, rgba(0, 0, 0, 0.7) 0%, transparent 100%); background-image: linear-gradient(to top, rgba(0, 0, 0, 0.7) 0%, transparent 100%); display: flex; flex-direction: column; } bt-image .figure-elm .centered,[data-is="bt-image"] .figure-elm .centered{ justify-content: center; align-items: center; } bt-image .figure-elm .top,[data-is="bt-image"] .figure-elm .top{ justify-content: flex-start; } bt-image .figure-elm .bottom,[data-is="bt-image"] .figure-elm .bottom{ justify-content: flex-end; } bt-image .figure-elm .left,[data-is="bt-image"] .figure-elm .left{ align-items: flex-start; } bt-image .figure-elm .right,[data-is="bt-image"] .figure-elm .right{ align-items: flex-end; }\', \'\', function(opts) {\n\t\tconst classes = opts.elmClass || "";\n\t\tthis.captionStyle = opts.captionStyle || \'bottom-right\';\n\t\tthis.elmClass = classes\n\t\tthis.src = \'//source.unsplash.com/collection/1278495/1300x400\';\n\t\tthis.styles = {\n\t\t\theight: opts.height || "100%",\n\t\t\twidth: opts.width || "100%"\n\t\t};\n});\n\n    \n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9pbWFnZXMvYnQtaW1hZ2UudGFnP2U5ZjYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBd0JBO0NBZEU7Q0FRRDtDQU5DO0NBQ0E7Q0FTRDtDQVBFO0NBQ0E7Q0FDRCIsImZpbGUiOiIxOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIjxidC1pbWFnZT5cblxuXHQ8ZmlndXJlIGNsYXNzPVwiYW5pbWF0ZWQgZmFkZUluIGZpZ3VyZS1lbG0geyBlbG1DbGFzcyB9XCIgc3R5bGU9eyBzdHlsZXMgfT5cblx0XHQ8aW1nIHNyYz17IG9wdHMuc3JjIHx8IHNyYyB9IGFsdD17IG9wdHMuYWx0IH0gY2xhc3M9XCJpbWctZWxtXCI+XG5cdFx0PGZpZ2NhcHRpb24gY2xhc3M9eyBjYXB0aW9uU3R5bGUgfT5cblx0XHRcdDx5aWVsZD48L3lpZWxkPlxuXHRcdDwvZmlnY2FwdGlvbj5cblx0PC9maWd1cmU+XG5cblx0PHNjcmlwdD5cblx0XHRjb25zdCBjbGFzc2VzID0gb3B0cy5lbG1DbGFzcyB8fCBcIlwiO1xuXHRcdHRoaXMuY2FwdGlvblN0eWxlID0gb3B0cy5jYXB0aW9uU3R5bGUgfHwgJ2JvdHRvbS1yaWdodCc7XG5cdFx0dGhpcy5lbG1DbGFzcyA9IGNsYXNzZXNcblx0XHR0aGlzLnNyYyA9ICcvL3NvdXJjZS51bnNwbGFzaC5jb20vY29sbGVjdGlvbi8xMjc4NDk1LzEzMDB4NDAwJztcblx0XHR0aGlzLnN0eWxlcyA9IHtcblx0XHRcdGhlaWdodDogb3B0cy5oZWlnaHQgfHwgXCIxMDAlXCIsXG5cdFx0XHR3aWR0aDogb3B0cy53aWR0aCB8fCBcIjEwMCVcIlxuXHRcdH07XG5cdDwvc2NyaXB0PlxuXG5cdDxzdHlsZSB0eXBlPVwidGV4dC9zY3NzXCI+XG5cdFx0QGltcG9ydCAnLi9pbWcuc2Nzcyc7XG5cdDwvc3R5bGU+XG5cbjwvYnQtaW1hZ2U+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29tcG9uZW50cy9pbWFnZXMvYnQtaW1hZ2UudGFnIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///18\n')},function(module,exports,__webpack_require__){eval("\n    var riot = __webpack_require__(0)\n    riot.tag2('bt-elm-lead', '<div class=\"{opts.elmClass || ⁗ block-elm-small ⁗ + ⁗flex-elm animated fadeIn⁗}\"> <yield></yield> </div>', '', '', function(opts) {\n});\n\n    \n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9lbG0vYnQtZWxtLWxlYWQudGFnP2EwNDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBU0EiLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8YnQtZWxtLWxlYWQ+XG5cblx0PGRpdiBjbGFzcz17IG9wdHMuZWxtQ2xhc3MgfHwgXCIgYmxvY2stZWxtLXNtYWxsIFwiICsgXCJmbGV4LWVsbSBhbmltYXRlZCBmYWRlSW5cIiB9PlxuXHRcdDx5aWVsZD48L3lpZWxkPlxuXHQ8L2Rpdj5cblxuXHQ8c2NyaXB0PlxuXHQ8L3NjcmlwdD5cblxuPC9idC1lbG0tbGVhZD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21wb25lbnRzL2VsbS9idC1lbG0tbGVhZC50YWciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///19\n")},function(module,exports,__webpack_require__){eval("\n    var riot = __webpack_require__(0)\n    riot.tag2('bt-truncate', '<span class=\"{opts.elmClass || \\' \\' + ⁗ truncate⁗}\"> <yield></yield> </span>', 'bt-truncate,[data-is=\"bt-truncate\"]{ display: inline; }', '', function(opts) {\nthis.on('mount', function() {\n\n\tconst content = this.root.querySelector('.truncate');\n\tconst limit = opts.limit || 30;\n\tconst after = opts.after || '...';\n\n\ttruncate(content, limit, after);\n\n})\n\nconst truncate = function (elm, limit, after = \"...\") {\n\tif(!elm || !limit) return;\n\t let truncated = elm.textContent.trim()\n\t truncated = truncated.split(' ').slice(0, limit);\n\t truncated = truncated.join(' ') + (after ? after : \" \");\n\t elm.textContent = truncated;\n}\n});\n\n    \n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy90cnVuY2F0ZS9idC10cnVuY2F0ZS50YWc/YmU2ZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFPRzs7Q0FDRDtDQUVBOzs7Ozs7Q0FEQTs7O0FBRUYiLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8YnQtdHJ1bmNhdGU+XG5cdDxzcGFuIGNsYXNzPXsgb3B0cy5lbG1DbGFzcyB8fCAnICcgKyBcIiB0cnVuY2F0ZVwiIH0+XG5cdFx0PHlpZWxkPjwveWllbGQ+XG5cdDwvc3Bhbj5cblx0XHQ8c3R5bGU+XG5cdFx0XHQ6c2NvcGUge1xuXHRcdFx0XHRkaXNwbGF5OiBpbmxpbmU7XG5cdFx0XHR9XG5cdFx0PC9zdHlsZT5cblx0XHQ8c2NyaXB0IHNyYz1cIi4vaW5kZXguanNcIj5cblx0XHQ8L3NjcmlwdD5cbjwvYnQtdHJ1bmNhdGU+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29tcG9uZW50cy90cnVuY2F0ZS9idC10cnVuY2F0ZS50YWciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///20\n")},function(module,exports,__webpack_require__){eval("\n    var riot = __webpack_require__(0)\n    riot.tag2('bt-svg-icon', '<use href=\"{src +⁗#⁗+ icon}\"></use>', 'bt-svg-icon,[data-is=\"bt-svg-icon\"]{ display: inline-block; }', '', function(opts) {\n    this.src = opts.src || \"/icons/material-icons.svg\"\n    this.icon = opts.icon || \"circle\"\n});\n\n    \n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9zdmdzL2J0LXN2Zy1pY29uLnRhZz8wNmFiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQVNRO0NBRVI7Q0FESSIsImZpbGUiOiIyMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIjxidC1zdmctaWNvbj5cbiAgICA8dXNlIGhyZWY9eyBzcmMgK1wiI1wiKyBpY29uIH0+PC91c2U+XG4gICAgPHNjcmlwdD5cbiAgICB0aGlzLnNyYyA9IG9wdHMuc3JjIHx8IFwiL2ljb25zL21hdGVyaWFsLWljb25zLnN2Z1wiXG4gICAgdGhpcy5pY29uID0gb3B0cy5pY29uIHx8IFwiY2lyY2xlXCJcbiAgICA8L3NjcmlwdD5cbiAgICA8c3R5bGU+XG4gICAgICAgIDpzY29wZSB7XG4gICAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIH1cbiAgICA8L3N0eWxlPlxuPC9idC1zdmctaWNvbj5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21wb25lbnRzL3N2Z3MvYnQtc3ZnLWljb24udGFnIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///21\n")},function(module,exports,__webpack_require__){eval('\n    var riot = __webpack_require__(0)\n    riot.tag2(\'bt-icon\', \'<svg class="{elmClass}"> <use xlink:href="{icon}"></use> </svg>\', \'bt-icon,[data-is="bt-icon"]{ display: inline-flex; overflow: hidden; } bt-icon .bt-icon-tiny,[data-is="bt-icon"] .bt-icon-tiny{ width: 1rem; height: 1rem; stroke-width: 2px; } bt-icon .bt-icon,[data-is="bt-icon"] .bt-icon{ width: 2rem; height: 2rem; stroke-width: 2px; } bt-icon .bt-icon-sm,[data-is="bt-icon"] .bt-icon-sm{ width: 1.5rem; height: 1.5rem; } bt-icon .bt-icon-md,[data-is="bt-icon"] .bt-icon-md{ width: 3rem; height: 3rem; } bt-icon .bt-icon-lg,[data-is="bt-icon"] .bt-icon-lg{ width: 4rem; height: 4rem; }\', \'\', function(opts) {\n\t\tconst name = opts.icon || \'account-circle\'\n\t\tconst src = opts.srcFile || \'/icons/material-icons.svg\'\n\t\tconst elmClass = opts.iconClass || \'\'\n\t\tthis.icon = src + "#" + name\n\t\tthis.elmClass = \'bt-icon \' + elmClass\n});\n\n    \n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9zdmdzL2J0LWljb24udGFnPzlkMWYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBZ0JFO0NBR0U7Q0FERjtDQUxNO0NBRUw7Q0FLSCIsImZpbGUiOiIyMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIjxidC1pY29uPlxuXHQ8c3ZnIGNsYXNzPXsgZWxtQ2xhc3MgfT5cblx0XHQ8dXNlIHhsaW5rOmhyZWY9eyBpY29uIH0+PC91c2U+XG5cdDwvc3ZnPlxuXHQ8c2NyaXB0PlxuXHRcdGNvbnN0IG5hbWUgPSBvcHRzLmljb24gfHwgJ2FjY291bnQtY2lyY2xlJ1xuXHRcdGNvbnN0IHNyYyA9IG9wdHMuc3JjRmlsZSB8fCAnL2ljb25zL21hdGVyaWFsLWljb25zLnN2Zydcblx0XHRjb25zdCBlbG1DbGFzcyA9IG9wdHMuaWNvbkNsYXNzIHx8ICcnXG5cdFx0dGhpcy5pY29uID0gc3JjICsgXCIjXCIgKyBuYW1lXG5cdFx0dGhpcy5lbG1DbGFzcyA9ICdidC1pY29uICcgKyBlbG1DbGFzc1xuXHQ8L3NjcmlwdD5cblx0PHN0eWxlIHR5cGU9XCJ0ZXh0L3Njc3NcIj5cblxuICAgICAgICA6c2NvcGUge1xuXHRcdFx0ZGlzcGxheTogaW5saW5lLWZsZXg7XG5cdFx0XHRvdmVyZmxvdzogaGlkZGVuO1xuXHRcdH1cblxuXHRcdEBpbXBvcnQgJy4vc3R5bGUuc2Nzcyc7XG4gICAgPC9zdHlsZT5cbjwvYnQtaWNvbj5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21wb25lbnRzL3N2Z3MvYnQtaWNvbi50YWciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///22\n')},function(module,exports,__webpack_require__){eval("\n    var riot = __webpack_require__(0)\n    riot.tag2('bt-icon-bytes', '<div data-is=\"bt-icon\" class=\"{opts.iconClass || \\'bt-icon-lg\\'}\" src-file=\"/icons/bytesize-symbols.min.svg\" icon=\"{opts.icon \t    || \\'i-info\\'}\" icon-class=\"{opts.iconClass || \\'bt-icon-lg\\'}\"> </div>', 'bt-icon-bytes .icon-bytes,[data-is=\"bt-icon-bytes\"] .icon-bytes{ stroke-width: 2px; }', '', function(opts) {\n});\n\n    \n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9zdmdzL2J0LWljb24tYnl0ZXMudGFnPzk1YzUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBU0EiLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8YnQtaWNvbi1ieXRlcz5cblx0PGRpdiBkYXRhLWlzPVwiYnQtaWNvblwiIGNsYXNzPXsgb3B0cy5pY29uQ2xhc3MgfHwgJ2J0LWljb24tbGcnfSBzcmMtZmlsZT1cIi9pY29ucy9ieXRlc2l6ZS1zeW1ib2xzLm1pbi5zdmdcIiBpY29uPXsgb3B0cy5pY29uXG5cdCAgICB8fCAnaS1pbmZvJyB9IGljb24tY2xhc3M9eyBvcHRzLmljb25DbGFzcyB8fCAnYnQtaWNvbi1sZyd9PlxuXHQ8L2Rpdj5cblx0PHN0eWxlPlxuXHRcdC5pY29uLWJ5dGVzIHtcblx0XHRcdHN0cm9rZS13aWR0aDogMnB4O1xuXHRcdH1cblx0PC9zdHlsZT5cbjwvYnQtaWNvbi1ieXRlcz5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21wb25lbnRzL3N2Z3MvYnQtaWNvbi1ieXRlcy50YWciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///23\n")},function(module,exports,__webpack_require__){eval("\n    var riot = __webpack_require__(0)\n    riot.tag2('bt-icon-material', '<div data-is=\"bt-icon\" class=\"{opts.iconClass || \\'bt-icon-md\\'}\" riot-src=\"{opts.src || \\'icons/materials-icons.svg\\'}\" icon=\"{icon || \\'account-circle\\'}\" icon-class=\"{opts.iconClass || \\'bt-icon-md\\'}\"> </div>', '', '', function(opts) {\n});\n\n    \n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9zdmdzL2J0LWljb24tbWF0ZXJpYWwudGFnP2YwNzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBUUEiLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8YnQtaWNvbi1tYXRlcmlhbD5cblx0PGRpdiBkYXRhLWlzPVwiYnQtaWNvblwiXG5cdGNsYXNzPXsgb3B0cy5pY29uQ2xhc3MgfHwgJ2J0LWljb24tbWQnfVxuXHRzcmM9eyBvcHRzLnNyYyB8fCAnaWNvbnMvbWF0ZXJpYWxzLWljb25zLnN2ZycgfVxuXHRpY29uPXsgaWNvbiB8fCAnYWNjb3VudC1jaXJjbGUnIH1cblx0aWNvbi1jbGFzcz17IG9wdHMuaWNvbkNsYXNzIHx8ICdidC1pY29uLW1kJ30+XG5cdDwvZGl2PlxuXHQ8c2NyaXB0Pjwvc2NyaXB0PlxuPC9idC1pY29uLW1hdGVyaWFsPlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbXBvbmVudHMvc3Zncy9idC1pY29uLW1hdGVyaWFsLnRhZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///24\n")},function(module,exports,__webpack_require__){eval("\n    var riot = __webpack_require__(0)\n    riot.tag2('bt-loader-spin', '<div class=\"bt-spin-loader\"></div>', 'bt-loader-spin .bt-spin-loader,[data-is=\"bt-loader-spin\"] .bt-spin-loader{ display: inline-block; width: 50px; height: 50px; border: 3px solid rgba(0, 0, 0, 0.3); border-radius: 50%; border-top-color: #fff; animation: spin-loader 1s ease-in-out infinite; -webkit-animation: spin-loader 1s ease-in-out infinite; } @keyframes spin-loader { to { -webkit-transform: rotate(360deg); } } @-webkit-keyframes spin-loader { to { -webkit-transform: rotate(360deg); } }', '', function(opts) {\n});\n\n    \n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9sb2FkZXJzL3NwaW4tbG9hZGVyL2J0LWxvYWRlci1zcGluLnRhZz85YTRkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBIiwiZmlsZSI6IjI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiPGJ0LWxvYWRlci1zcGluPlxuPGRpdiBjbGFzcz1cImJ0LXNwaW4tbG9hZGVyXCI+PC9kaXY+XG48c3R5bGUgdHlwZT1cInRleHQvc2Nzc1wiPlxuQGltcG9ydCAnLi9idC1zcGluLWxvYWRlci5zY3NzJztcbjwvc3R5bGU+XG48L2J0LWxvYWRlci1zcGluPlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbXBvbmVudHMvbG9hZGVycy9zcGluLWxvYWRlci9idC1sb2FkZXItc3Bpbi50YWciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///25\n")},function(module,exports,__webpack_require__){eval('\n    var riot = __webpack_require__(0)\n    riot.tag2(\'bt-dropdown\', \'<div id="bt-address-select" class="bt-address-select"> <h7 class="mb-1">Selected Address</h7> <div class="form-group my-2"> <textarea name="address" class="form-control bt-address-selected text-info border-0 p-2" rows="4" disabled readonly>Dalii Y. Muhammad Jhiriad Holdings Co. 73, Jalan Cilaki. #1123 Bandung 40115 Indonesia </textarea> </div> <div class="address-dropdown"> <div class="container-fluid-"> <h7 class="mb-2">Select from Address Book</h7> <button type="button" class="address-dropdown-btn border border-gray p-2 text-left mt-2"> <i class="ion-arrow-down-b"></i> Select Address </button> <div class="bt-address-list d-none border border-gray mt-2"> <div class="col-md-12 my-2"> <p class="text-info "> <a href="" class="bt-address-option"> Putri Y. Muhammad <br> Jhiriad Holdings Co. <br> 73, Jalan Cilaki. #1123 <br> Bandung 40115 <br> Indonesia <br> </a> </p> <hr> <p class="text-info "> <a href="/ " class="bt-address-option"> Putri Y. Muhammad Alu <br> Jhiriad Holdings Co. <br> 73, Jalan Cilaki. #1123 <br> Bandung 40115 <br> Indonesia <br> </a> </p> <hr> <p class="text-info "> <a href="#" class="bt-address-option"> Putri Y. Muhammad Alu <br> Jhiriad Holdings Co. <br> 73, Jalan Cilaki. #1123 <br> Bandung 40115 <br> Indonesia <br> </a> </p> </div> </div> </div> </div>\', \'bt-dropdown,[data-is="bt-dropdown"]{ width: 100%; max-width: 360px; display: block; } bt-dropdown .bt-address-select,[data-is="bt-dropdown"] .bt-address-select{ width: 100%; } bt-dropdown .bt-address-select .form-control:disabled,[data-is="bt-dropdown"] .bt-address-select .form-control:disabled,bt-dropdown .bt-address-select .form-control[readonly],[data-is="bt-dropdown"] .bt-address-select .form-control[readonly]{ background-color: #fff; } bt-dropdown .address-dropdown,[data-is="bt-dropdown"] .address-dropdown{ position: relative; width: 100%; } bt-dropdown .address-dropdown-btn,[data-is="bt-dropdown"] .address-dropdown-btn{ background-color: transparent; width: 100%; cursor: pointer; } bt-dropdown .bt-address-list,[data-is="bt-dropdown"] .bt-address-list{ -webkit-transition: all 2s ease-out; -moz-transition: all 2s ease-out; -o-transition: all 2s ease-out; transition: all 2s ease-out; position: absolute; z-index: 99; left: 0px; background-color: #fff; width: 100%; height: 260px; overflow: auto; } bt-dropdown .d-none,[data-is="bt-dropdown"] .d-none{ display: none; }\', \'\', function(opts) {\n});\n\n    \n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9zZWxlY3Rpb25zL2Ryb3Bkb3duL2J0LWRyb3Bkb3duLnRhZz83MDM2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWVBIiwiZmlsZSI6IjI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiPGJ0LWRyb3Bkb3duPlxuXHQ8ZGl2IGlkPVwiYnQtYWRkcmVzcy1zZWxlY3RcIiBjbGFzcz1cImJ0LWFkZHJlc3Mtc2VsZWN0XCI+XG5cblx0XHQ8aDcgY2xhc3M9XCJtYi0xXCI+U2VsZWN0ZWQgQWRkcmVzczwvaDc+XG5cdFx0PGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgbXktMlwiPlxuXHRcdFx0PHRleHRhcmVhIG5hbWU9XCJhZGRyZXNzXCIgY2xhc3M9XCJmb3JtLWNvbnRyb2wgYnQtYWRkcmVzcy1zZWxlY3RlZCB0ZXh0LWluZm8gYm9yZGVyLTAgcC0yXCIgcm93cz1cIjRcIiBkaXNhYmxlZCByZWFkb25seT5EYWxpaSBZLiBNdWhhbW1hZFxuXHRcdFx0XHRKaGlyaWFkIEhvbGRpbmdzIENvLlxuXHRcdFx0XHQ3MywgSmFsYW4gQ2lsYWtpLiAjMTEyM1xuXHRcdFx0XHRCYW5kdW5nIDQwMTE1XG5cdFx0XHRcdEluZG9uZXNpYVxuXHRcdFx0PC90ZXh0YXJlYT5cblx0XHQ8L2Rpdj5cblxuXHRcdDxkaXYgY2xhc3M9XCJhZGRyZXNzLWRyb3Bkb3duXCI+XG5cdFx0XHQ8ZGl2IGNsYXNzPVwiY29udGFpbmVyLWZsdWlkLVwiPlxuPGg3IGNsYXNzPVwibWItMlwiPlNlbGVjdCBmcm9tIEFkZHJlc3MgQm9vazwvaDc+XG5cdFx0XHRcdDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYWRkcmVzcy1kcm9wZG93bi1idG4gYm9yZGVyIGJvcmRlci1ncmF5IHAtMiB0ZXh0LWxlZnQgbXQtMlwiPlxuXHRcdFx0XHRcdDxpIGNsYXNzPVwiaW9uLWFycm93LWRvd24tYlwiPjwvaT4gU2VsZWN0IEFkZHJlc3Ncblx0XHRcdFx0PC9idXR0b24+XG5cblx0XHRcdFx0PGRpdiBjbGFzcz1cImJ0LWFkZHJlc3MtbGlzdCBkLW5vbmUgYm9yZGVyIGJvcmRlci1ncmF5IG10LTJcIj5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiY29sLW1kLTEyIG15LTJcIj5cblx0XHRcdFx0XHRcdDxwIGNsYXNzPVwidGV4dC1pbmZvIFwiPlxuXHRcdFx0XHRcdFx0XHQ8YSBocmVmPVwiXCIgY2xhc3M9XCJidC1hZGRyZXNzLW9wdGlvblwiPlxuXHRcdFx0XHRcdFx0XHRcdFB1dHJpIFkuIE11aGFtbWFkXG5cdFx0XHRcdFx0XHRcdFx0PGJyPiBKaGlyaWFkIEhvbGRpbmdzIENvLlxuXHRcdFx0XHRcdFx0XHRcdDxicj4gNzMsIEphbGFuIENpbGFraS4gIzExMjNcblx0XHRcdFx0XHRcdFx0XHQ8YnI+IEJhbmR1bmcgNDAxMTVcblx0XHRcdFx0XHRcdFx0XHQ8YnI+IEluZG9uZXNpYVxuXHRcdFx0XHRcdFx0XHRcdDxicj5cblx0XHRcdFx0XHRcdFx0PC9hPlxuXHRcdFx0XHRcdFx0PC9wPlxuXHRcdFx0XHRcdFx0PGhyPlxuXHRcdFx0XHRcdFx0PHAgY2xhc3M9XCJ0ZXh0LWluZm8gXCI+XG5cdFx0XHRcdFx0XHRcdDxhIGhyZWY9XCIvIFwiIGNsYXNzPVwiYnQtYWRkcmVzcy1vcHRpb25cIj5cblx0XHRcdFx0XHRcdFx0XHRQdXRyaSBZLiBNdWhhbW1hZCBBbHVcblx0XHRcdFx0XHRcdFx0XHQ8YnI+IEpoaXJpYWQgSG9sZGluZ3MgQ28uXG5cdFx0XHRcdFx0XHRcdFx0PGJyPiA3MywgSmFsYW4gQ2lsYWtpLiAjMTEyM1xuXHRcdFx0XHRcdFx0XHRcdDxicj4gQmFuZHVuZyA0MDExNVxuXHRcdFx0XHRcdFx0XHRcdDxicj4gSW5kb25lc2lhXG5cdFx0XHRcdFx0XHRcdFx0PGJyPlxuXHRcdFx0XHRcdFx0XHQ8L2E+XG5cdFx0XHRcdFx0XHQ8L3A+XG5cdFx0XHRcdFx0XHQ8aHI+XG5cdFx0XHRcdFx0XHQ8cCBjbGFzcz1cInRleHQtaW5mbyBcIj5cblx0XHRcdFx0XHRcdFx0PGEgaHJlZj1cIiNcIiBjbGFzcz1cImJ0LWFkZHJlc3Mtb3B0aW9uXCI+XG5cdFx0XHRcdFx0XHRcdFx0UHV0cmkgWS4gTXVoYW1tYWQgQWx1XG5cdFx0XHRcdFx0XHRcdFx0PGJyPiBKaGlyaWFkIEhvbGRpbmdzIENvLlxuXHRcdFx0XHRcdFx0XHRcdDxicj4gNzMsIEphbGFuIENpbGFraS4gIzExMjNcblx0XHRcdFx0XHRcdFx0XHQ8YnI+IEJhbmR1bmcgNDAxMTVcblx0XHRcdFx0XHRcdFx0XHQ8YnI+IEluZG9uZXNpYVxuXHRcdFx0XHRcdFx0XHRcdDxicj5cblx0XHRcdFx0XHRcdFx0PC9hPlxuXHRcdFx0XHRcdFx0PC9wPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0PC9kaXY+XG5cdFx0PC9kaXY+XG5cdFx0PHN0eWxlIHR5cGU9XCJ0ZXh0L3Njc3NcIj5cblx0XHRcdEBpbXBvcnQgXCIuL2Ryb3Bkb3duLnNjc3NcIjtcblx0XHQ8L3N0eWxlPlxuPC9idC1kcm9wZG93bj5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21wb25lbnRzL3NlbGVjdGlvbnMvZHJvcGRvd24vYnQtZHJvcGRvd24udGFnIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///26\n')},function(module,exports,__webpack_require__){eval('\n    var riot = __webpack_require__(0)\n    riot.tag2(\'bt-loader-processing\', \'<div class="bt-loader-processing"> <div class="bt-processing"> <div class="loader--label">Processing... </div> <div class="loader--background"> <div class="loader--bar"> </div> </div> </div> </div>\', \'bt-loader-processing .bt-loader-processing,[data-is="bt-loader-processing"] .bt-loader-processing{ text-align: center; margin: auto; } bt-loader-processing .bt-loader-processing .loader--label,[data-is="bt-loader-processing"] .bt-loader-processing .loader--label{ padding-bottom: 10px; color: black; font-size: 20px; font-weight: bold; color: #527eef; font-family: Lato; } bt-loader-processing .bt-loader-processing .bt-processing,[data-is="bt-loader-processing"] .bt-loader-processing .bt-processing{ height: 100%; width: 100%; position: absolute; left: 0; overflow: hidden; display: inline-block; } bt-loader-processing .bt-loader-processing .loader--background,[data-is="bt-loader-processing"] .bt-loader-processing .loader--background{ background: rgba(225, 230, 249, 0.5); height: 10px; display: inline-block; width: 100%; left: 0; top: 0; position: relative; z-index: -1; } bt-loader-processing .bt-loader-processing .loader--bar,[data-is="bt-loader-processing"] .bt-loader-processing .loader--bar{ top: -10px; height: 10px; position: relative; width: 0%; display: inline-block; background-image: linear-gradient(to right, #5452eb, #50a0f1); animation: growth 1.5s ease-in infinite; } @keyframes growth { to { width: 100%; } }\', \'\', function(opts) {\nthis.on("mount", e => {\n  var labelValue = document.getElementsByClassName("loader--label")[0];\n  var loader = document.getElementsByClassName("loader")[0];\n  setTimeout(function() {\n    labelValue.text = loader.width;\n  }, 200);\n});\n});\n\n    \n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9sb2FkZXJzL3Byb2Nlc3NpbmcvYnQtbG9hZGVyLXByb2Nlc3NpbmcudGFnP2VjOTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBVUM7Q0FJQTtDQUNEO0NBRkM7O0NBRkEiLCJmaWxlIjoiMjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8YnQtbG9hZGVyLXByb2Nlc3Npbmc+XG5cdDxkaXYgY2xhc3M9XCJidC1sb2FkZXItcHJvY2Vzc2luZ1wiPlxuXHRcdDxkaXYgY2xhc3M9XCJidC1wcm9jZXNzaW5nXCI+XG5cdFx0PGRpdiBjbGFzcz1cImxvYWRlci0tbGFiZWxcIj5Qcm9jZXNzaW5nLi4uXG5cdFx0PC9kaXY+XG5cdFx0PGRpdiBjbGFzcz1cImxvYWRlci0tYmFja2dyb3VuZFwiPlxuXHRcdFx0PGRpdiBjbGFzcz1cImxvYWRlci0tYmFyXCI+XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L2Rpdj5cblx0PC9kaXY+XG5cdDwvZGl2PlxuXHQ8c3R5bGUgdHlwZT1cInRleHQvc2Nzc1wiPlxuXHRcdEBpbXBvcnQgXCIuL19zdHlsZS5zY3NzXCI7XG5cdDwvc3R5bGU+XG5cdDxzY3JpcHQgc3JjPVwiLi9zY3JpcHRzLmpzXCI+PC9zY3JpcHQ+XG48L2J0LWxvYWRlci1wcm9jZXNzaW5nPlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbXBvbmVudHMvbG9hZGVycy9wcm9jZXNzaW5nL2J0LWxvYWRlci1wcm9jZXNzaW5nLnRhZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///27\n')}],[9]);